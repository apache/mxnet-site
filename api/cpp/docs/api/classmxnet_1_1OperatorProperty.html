<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mxnet: mxnet::OperatorProperty Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mxnet
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemxnet.html">mxnet</a></li><li class="navelem"><a class="el" href="classmxnet_1_1OperatorProperty.html">OperatorProperty</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmxnet_1_1OperatorProperty-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mxnet::OperatorProperty Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classmxnet_1_1OperatorProperty.html" title="OperatorProperty is a object that stores all information about Operator. It also contains method to g...">OperatorProperty</a> is a object that stores all information about <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a>. It also contains method to generate context(device) specific operators.  
 <a href="classmxnet_1_1OperatorProperty.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="include_2mxnet_2operator_8h_source.html">operator.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for mxnet::OperatorProperty:</div>
<div class="dyncontent">
<div class="center"><img src="classmxnet_1_1OperatorProperty__coll__graph.png" border="0" usemap="#mxnet_1_1OperatorProperty_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 0 -->
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a610af8e9cb560104301ccd1efa2a96fd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a610af8e9cb560104301ccd1efa2a96fd">~OperatorProperty</a> ()</td></tr>
<tr class="memdesc:a610af8e9cb560104301ccd1efa2a96fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual destructor  <a href="classmxnet_1_1OperatorProperty.html#a610af8e9cb560104301ccd1efa2a96fd">More...</a><br /></td></tr>
<tr class="separator:a610af8e9cb560104301ccd1efa2a96fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb32e0ab03a86517473db0f0630856c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a0fb32e0ab03a86517473db0f0630856c">Init</a> (const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;kwargs)=0</td></tr>
<tr class="memdesc:a0fb32e0ab03a86517473db0f0630856c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a> by setting the parameters This function need to be called before all other functions.  <a href="classmxnet_1_1OperatorProperty.html#a0fb32e0ab03a86517473db0f0630856c">More...</a><br /></td></tr>
<tr class="separator:a0fb32e0ab03a86517473db0f0630856c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704ae43181c8a88bfd0a47e8005f7cb8"><td class="memItemLeft" align="right" valign="top">virtual std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a704ae43181c8a88bfd0a47e8005f7cb8">GetParams</a> () const =0</td></tr>
<tr class="memdesc:a704ae43181c8a88bfd0a47e8005f7cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a map representation of internal parameters. This can be used by Init to recover the state of <a class="el" href="classmxnet_1_1OperatorProperty.html" title="OperatorProperty is a object that stores all information about Operator. It also contains method to g...">OperatorProperty</a>.  <a href="classmxnet_1_1OperatorProperty.html#a704ae43181c8a88bfd0a47e8005f7cb8">More...</a><br /></td></tr>
<tr class="separator:a704ae43181c8a88bfd0a47e8005f7cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01be3a84423800af7e818b45afc748f"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#ad01be3a84423800af7e818b45afc748f">ListArguments</a> () const</td></tr>
<tr class="memdesc:ad01be3a84423800af7e818b45afc748f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get input arguments of the <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a>.  <a href="classmxnet_1_1OperatorProperty.html#ad01be3a84423800af7e818b45afc748f">More...</a><br /></td></tr>
<tr class="separator:ad01be3a84423800af7e818b45afc748f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e52badb93fe965ce961803f2101aa7"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#ab9e52badb93fe965ce961803f2101aa7">ListOutputs</a> () const</td></tr>
<tr class="memdesc:ab9e52badb93fe965ce961803f2101aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of output values of <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a>.  <a href="classmxnet_1_1OperatorProperty.html#ab9e52badb93fe965ce961803f2101aa7">More...</a><br /></td></tr>
<tr class="separator:ab9e52badb93fe965ce961803f2101aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d3a955ffa452a368a9dd4d33ce5a25"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#aa6d3a955ffa452a368a9dd4d33ce5a25">ListAuxiliaryStates</a> () const</td></tr>
<tr class="memdesc:aa6d3a955ffa452a368a9dd4d33ce5a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of auxiliary states of <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a>.  <a href="classmxnet_1_1OperatorProperty.html#aa6d3a955ffa452a368a9dd4d33ce5a25">More...</a><br /></td></tr>
<tr class="separator:aa6d3a955ffa452a368a9dd4d33ce5a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc6e9f04f52b1c05f62fb7357bb95c4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a9fc6e9f04f52b1c05f62fb7357bb95c4">NumOutputs</a> () const</td></tr>
<tr class="separator:a9fc6e9f04f52b1c05f62fb7357bb95c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006f0e2c9b3f934e1f73b242b7e8b062"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a006f0e2c9b3f934e1f73b242b7e8b062">NumVisibleOutputs</a> () const</td></tr>
<tr class="memdesc:a006f0e2c9b3f934e1f73b242b7e8b062"><td class="mdescLeft">&#160;</td><td class="mdescRight">get number of visible return values during Symbol creation. If <a class="el" href="classmxnet_1_1OperatorProperty.html#a006f0e2c9b3f934e1f73b242b7e8b062" title="get number of visible return values during Symbol creation. If NumVisibleOutputs() = k,...">NumVisibleOutputs()</a> = k, and <a class="el" href="classmxnet_1_1OperatorProperty.html#a9fc6e9f04f52b1c05f62fb7357bb95c4">NumOutputs()</a> = n. The first k returns will be presented in the resulting symbol.  <a href="classmxnet_1_1OperatorProperty.html#a006f0e2c9b3f934e1f73b242b7e8b062">More...</a><br /></td></tr>
<tr class="separator:a006f0e2c9b3f934e1f73b242b7e8b062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be455d921fcb9e61ffafc567a31dc39"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a4be455d921fcb9e61ffafc567a31dc39">InferShape</a> (<a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> *in_shape, <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> *out_shape, <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> *aux_shape) const =0</td></tr>
<tr class="memdesc:a4be455d921fcb9e61ffafc567a31dc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">infer the shapes of outputs and unknown input arguments  <a href="classmxnet_1_1OperatorProperty.html#a4be455d921fcb9e61ffafc567a31dc39">More...</a><br /></td></tr>
<tr class="separator:a4be455d921fcb9e61ffafc567a31dc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819b81e14761e9e8b9c888a63c7df1fa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a819b81e14761e9e8b9c888a63c7df1fa">InferType</a> (std::vector&lt; int &gt; *in_type, std::vector&lt; int &gt; *out_type, std::vector&lt; int &gt; *aux_type) const</td></tr>
<tr class="memdesc:a819b81e14761e9e8b9c888a63c7df1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">infer the data types of outputs and unknown input arguments  <a href="classmxnet_1_1OperatorProperty.html#a819b81e14761e9e8b9c888a63c7df1fa">More...</a><br /></td></tr>
<tr class="separator:a819b81e14761e9e8b9c888a63c7df1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38f2f877555ba34b548efd2575cac99"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmxnet_1_1OperatorProperty.html">OperatorProperty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#ab38f2f877555ba34b548efd2575cac99">Copy</a> () const =0</td></tr>
<tr class="memdesc:ab38f2f877555ba34b548efd2575cac99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy this <a class="el" href="classmxnet_1_1OperatorProperty.html" title="OperatorProperty is a object that stores all information about Operator. It also contains method to g...">OperatorProperty</a>.  <a href="classmxnet_1_1OperatorProperty.html#ab38f2f877555ba34b548efd2575cac99">More...</a><br /></td></tr>
<tr class="separator:ab38f2f877555ba34b548efd2575cac99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546ab25ddaae590ca98705ae9abc7ac0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmxnet_1_1Operator.html">Operator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a546ab25ddaae590ca98705ae9abc7ac0">CreateOperator</a> (<a class="el" href="structmxnet_1_1Context.html">Context</a> ctx) const =0</td></tr>
<tr class="memdesc:a546ab25ddaae590ca98705ae9abc7ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a> on specific context.  <a href="classmxnet_1_1OperatorProperty.html#a546ab25ddaae590ca98705ae9abc7ac0">More...</a><br /></td></tr>
<tr class="separator:a546ab25ddaae590ca98705ae9abc7ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7e3e95e522a48e9064858bf084be05"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmxnet_1_1Operator.html">Operator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a1e7e3e95e522a48e9064858bf084be05">CreateOperatorEx</a> (<a class="el" href="structmxnet_1_1Context.html">Context</a> ctx, <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> *in_shape, std::vector&lt; int &gt; *in_type) const</td></tr>
<tr class="memdesc:a1e7e3e95e522a48e9064858bf084be05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a> on specific context and input shape/type.  <a href="classmxnet_1_1OperatorProperty.html#a1e7e3e95e522a48e9064858bf084be05">More...</a><br /></td></tr>
<tr class="separator:a1e7e3e95e522a48e9064858bf084be05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b7df90c0285a1823b463c21e926698"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#ac6b7df90c0285a1823b463c21e926698">TypeString</a> () const =0</td></tr>
<tr class="memdesc:ac6b7df90c0285a1823b463c21e926698"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the type string of the <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a> subclasses override this function.  <a href="classmxnet_1_1OperatorProperty.html#ac6b7df90c0285a1823b463c21e926698">More...</a><br /></td></tr>
<tr class="separator:ac6b7df90c0285a1823b463c21e926698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203b8aa89f254f8e7a91b83d3ed18908"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structmxnet_1_1ResourceRequest.html">ResourceRequest</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a203b8aa89f254f8e7a91b83d3ed18908">ForwardResource</a> (const <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> &amp;in_shape) const</td></tr>
<tr class="memdesc:a203b8aa89f254f8e7a91b83d3ed18908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare additional resource required in forward pass. These additional resources will be presented in <a class="el" href="structmxnet_1_1OpContext.html#a833e95f95cf5e3af9c193b74b500fc5b" title="Resources requested by the operator.">OpContext.requested</a> in the same order of the returned <a class="el" href="structmxnet_1_1Resource.html" title="Resources used by mxnet operations. A resource is something special other than NDArray,...">Resource</a>.  <a href="classmxnet_1_1OperatorProperty.html#a203b8aa89f254f8e7a91b83d3ed18908">More...</a><br /></td></tr>
<tr class="separator:a203b8aa89f254f8e7a91b83d3ed18908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d08b437e69ea9c402725d7f9165ead"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structmxnet_1_1ResourceRequest.html">ResourceRequest</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a84d08b437e69ea9c402725d7f9165ead">BackwardResource</a> (const <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> &amp;in_shape) const</td></tr>
<tr class="memdesc:a84d08b437e69ea9c402725d7f9165ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare additional resource required in backward pass. These additional resources will be presented in <a class="el" href="structmxnet_1_1OpContext.html#a833e95f95cf5e3af9c193b74b500fc5b" title="Resources requested by the operator.">OpContext.requested</a> in the same order of the returned <a class="el" href="structmxnet_1_1Resource.html" title="Resources used by mxnet operations. A resource is something special other than NDArray,...">Resource</a>.  <a href="classmxnet_1_1OperatorProperty.html#a84d08b437e69ea9c402725d7f9165ead">More...</a><br /></td></tr>
<tr class="separator:a84d08b437e69ea9c402725d7f9165ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa205ea6ce962bfa3fcbe73a8f3db5d"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a8aa205ea6ce962bfa3fcbe73a8f3db5d">DeclareBackwardDependency</a> (const std::vector&lt; int &gt; &amp;out_grad, const std::vector&lt; int &gt; &amp;in_data, const std::vector&lt; int &gt; &amp;out_data) const</td></tr>
<tr class="memdesc:a8aa205ea6ce962bfa3fcbe73a8f3db5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare the input requirement of Backward pass.  <a href="classmxnet_1_1OperatorProperty.html#a8aa205ea6ce962bfa3fcbe73a8f3db5d">More...</a><br /></td></tr>
<tr class="separator:a8aa205ea6ce962bfa3fcbe73a8f3db5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91afbc64b53766d2d19236e99d966902"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; int, void * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a91afbc64b53766d2d19236e99d966902">ForwardInplaceOption</a> (const std::vector&lt; int &gt; &amp;in_data, const std::vector&lt; void * &gt; &amp;out_data) const</td></tr>
<tr class="memdesc:a91afbc64b53766d2d19236e99d966902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get possible forward inplace options. This function enables optimization to reuse memory of inputs in output. Only override when necessary, by default in-place is disabled.  <a href="classmxnet_1_1OperatorProperty.html#a91afbc64b53766d2d19236e99d966902">More...</a><br /></td></tr>
<tr class="separator:a91afbc64b53766d2d19236e99d966902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3c0366154cd257a3b76bbcf924ef80"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; int, void * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a2c3c0366154cd257a3b76bbcf924ef80">BackwardInplaceOption</a> (const std::vector&lt; int &gt; &amp;out_grad, const std::vector&lt; int &gt; &amp;in_data, const std::vector&lt; int &gt; &amp;out_data, const std::vector&lt; void * &gt; &amp;in_grad) const</td></tr>
<tr class="memdesc:a2c3c0366154cd257a3b76bbcf924ef80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get possible backward inplace options. This function enables optimization to reuse memory of inputs in output. Only override when necessary, by default in-place is disabled.  <a href="classmxnet_1_1OperatorProperty.html#a2c3c0366154cd257a3b76bbcf924ef80">More...</a><br /></td></tr>
<tr class="separator:a2c3c0366154cd257a3b76bbcf924ef80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5c8df10748a7eee873d4b7eb8d684b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c5c8df10748a7eee873d4b7eb8d684b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a6c5c8df10748a7eee873d4b7eb8d684b">BackwardInputs</a> (const std::vector&lt; T &gt; &amp;out_grad, const std::vector&lt; T &gt; &amp;in_data, const std::vector&lt; T &gt; &amp;out_data) const</td></tr>
<tr class="memdesc:a6c5c8df10748a7eee873d4b7eb8d684b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Backward Input Dependency for generic types of data. Normally T can be pointer of Symbol::DataEntry, or <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface">NDArray</a>. This function will select the result list of T according to DeclareBackwardDependency.  <a href="classmxnet_1_1OperatorProperty.html#a6c5c8df10748a7eee873d4b7eb8d684b">More...</a><br /></td></tr>
<tr class="separator:a6c5c8df10748a7eee873d4b7eb8d684b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149c52bd285e4fa78109a535765a9b7c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ad">ExecType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a149c52bd285e4fa78109a535765a9b7c">exec_type</a> () const</td></tr>
<tr class="separator:a149c52bd285e4fa78109a535765a9b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a15cf1f905b08a008ff38556ef6a35dd0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmxnet_1_1OperatorProperty.html">OperatorProperty</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1OperatorProperty.html#a15cf1f905b08a008ff38556ef6a35dd0">Create</a> (const char *type_name)</td></tr>
<tr class="memdesc:a15cf1f905b08a008ff38556ef6a35dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">create <a class="el" href="classmxnet_1_1OperatorProperty.html" title="OperatorProperty is a object that stores all information about Operator. It also contains method to g...">OperatorProperty</a>  <a href="classmxnet_1_1OperatorProperty.html#a15cf1f905b08a008ff38556ef6a35dd0">More...</a><br /></td></tr>
<tr class="separator:a15cf1f905b08a008ff38556ef6a35dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classmxnet_1_1OperatorProperty.html" title="OperatorProperty is a object that stores all information about Operator. It also contains method to g...">OperatorProperty</a> is a object that stores all information about <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a>. It also contains method to generate context(device) specific operators. </p>
<p>It also contains various functions that can be optimally overriden to provide optimization chance for computation engine. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a610af8e9cb560104301ccd1efa2a96fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610af8e9cb560104301ccd1efa2a96fd">&#9670;&nbsp;</a></span>~OperatorProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual mxnet::OperatorProperty::~OperatorProperty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2c3c0366154cd257a3b76bbcf924ef80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3c0366154cd257a3b76bbcf924ef80">&#9670;&nbsp;</a></span>BackwardInplaceOption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;int, void*&gt; &gt; mxnet::OperatorProperty::BackwardInplaceOption </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get possible backward inplace options. This function enables optimization to reuse memory of inputs in output. Only override when necessary, by default in-place is disabled. </p>
<p>The reason for void* type in the in_grad is to distinguish the order of mappings between the two, compiler will report error when in_data and out_data's order in the pair get reversed.</p>
<div class="fragment"><div class="line"><span class="comment">// The following code says in_grad[0] can share data with in_data[0]</span></div>
<div class="line">vector&lt;pair&lt;int,int&gt; &gt; <a class="code" href="classmxnet_1_1OperatorProperty.html#a2c3c0366154cd257a3b76bbcf924ef80">BackwardInplaceOption</a>(</div>
<div class="line">               <span class="keyword">const</span> std::vector&lt;int&gt; &amp;out_grad,</div>
<div class="line">               <span class="keyword">const</span> std::vector&lt;int&gt; &amp;in_data,</div>
<div class="line">               <span class="keyword">const</span> std::vector&lt;int&gt; &amp;out_data,</div>
<div class="line">               <span class="keyword">const</span> std::vector&lt;int&gt; &amp;in_grad)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keywordflow">return</span> {in_data[0], in_grad[0]}};</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_data</td><td>The input data in forward pass. </td></tr>
    <tr><td class="paramname">out_data</td><td>The output data in forward pass. </td></tr>
    <tr><td class="paramname">in_grad</td><td>Gradient of inputs in backward pass. </td></tr>
    <tr><td class="paramname">out_grad</td><td>Gradient of outputs in backward pass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of pair of that maps input-&gt;output, indicating possible in place operations. </dd></dl>

</div>
</div>
<a id="a6c5c8df10748a7eee873d4b7eb8d684b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5c8df10748a7eee873d4b7eb8d684b">&#9670;&nbsp;</a></span>BackwardInputs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; mxnet::OperatorProperty::BackwardInputs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get Backward Input Dependency for generic types of data. Normally T can be pointer of Symbol::DataEntry, or <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface">NDArray</a>. This function will select the result list of T according to DeclareBackwardDependency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_data</td><td>the input data in forward pass. </td></tr>
    <tr><td class="paramname">out_data</td><td>the output data in forward pass. </td></tr>
    <tr><td class="paramname">out_grad</td><td>gradient of outputs in backward pass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the generic type parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of inputs the Backward Operation depends on. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmxnet_1_1OperatorProperty.html#a8aa205ea6ce962bfa3fcbe73a8f3db5d" title="Declare the input requirement of Backward pass.">DeclareBackwardDependency</a> </dd></dl>

</div>
</div>
<a id="a84d08b437e69ea9c402725d7f9165ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d08b437e69ea9c402725d7f9165ead">&#9670;&nbsp;</a></span>BackwardResource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="structmxnet_1_1ResourceRequest.html">ResourceRequest</a>&gt; mxnet::OperatorProperty::BackwardResource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare additional resource required in backward pass. These additional resources will be presented in <a class="el" href="structmxnet_1_1OpContext.html#a833e95f95cf5e3af9c193b74b500fc5b" title="Resources requested by the operator.">OpContext.requested</a> in the same order of the returned <a class="el" href="structmxnet_1_1Resource.html" title="Resources used by mxnet operations. A resource is something special other than NDArray,...">Resource</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_shape</td><td>The input shape to the operator, corresponds to shapes of in_data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Additional resource request </dd></dl>

</div>
</div>
<a id="ab38f2f877555ba34b548efd2575cac99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38f2f877555ba34b548efd2575cac99">&#9670;&nbsp;</a></span>Copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmxnet_1_1OperatorProperty.html">OperatorProperty</a>* mxnet::OperatorProperty::Copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy this <a class="el" href="classmxnet_1_1OperatorProperty.html" title="OperatorProperty is a object that stores all information about Operator. It also contains method to g...">OperatorProperty</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the copied <a class="el" href="classmxnet_1_1OperatorProperty.html" title="OperatorProperty is a object that stores all information about Operator. It also contains method to g...">OperatorProperty</a> </dd></dl>

</div>
</div>
<a id="a15cf1f905b08a008ff38556ef6a35dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15cf1f905b08a008ff38556ef6a35dd0">&#9670;&nbsp;</a></span>Create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmxnet_1_1OperatorProperty.html">OperatorProperty</a>* mxnet::OperatorProperty::Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create <a class="el" href="classmxnet_1_1OperatorProperty.html" title="OperatorProperty is a object that stores all information about Operator. It also contains method to g...">OperatorProperty</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_name</td><td>the type string of the <a class="el" href="classmxnet_1_1OperatorProperty.html" title="OperatorProperty is a object that stores all information about Operator. It also contains method to g...">OperatorProperty</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new constructed <a class="el" href="classmxnet_1_1OperatorProperty.html" title="OperatorProperty is a object that stores all information about Operator. It also contains method to g...">OperatorProperty</a> </dd></dl>

</div>
</div>
<a id="a546ab25ddaae590ca98705ae9abc7ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546ab25ddaae590ca98705ae9abc7ac0">&#9670;&nbsp;</a></span>CreateOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmxnet_1_1Operator.html">Operator</a>* mxnet::OperatorProperty::CreateOperator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmxnet_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a> on specific context. </p>

</div>
</div>
<a id="a1e7e3e95e522a48e9064858bf084be05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7e3e95e522a48e9064858bf084be05">&#9670;&nbsp;</a></span>CreateOperatorEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmxnet_1_1Operator.html">Operator</a>* mxnet::OperatorProperty::CreateOperatorEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmxnet_1_1Context.html">Context</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> *&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>in_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a> on specific context and input shape/type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>context of this operator </td></tr>
    <tr><td class="paramname">in_shape</td><td>shape of the input ndarrays </td></tr>
    <tr><td class="paramname">in_type</td><td>dtype of the input ndarrays </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created operator </dd></dl>

</div>
</div>
<a id="a8aa205ea6ce962bfa3fcbe73a8f3db5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa205ea6ce962bfa3fcbe73a8f3db5d">&#9670;&nbsp;</a></span>DeclareBackwardDependency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;int&gt; mxnet::OperatorProperty::DeclareBackwardDependency </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare the input requirement of Backward pass. </p>
<p>Only the returned list of variables will be used in Backward. This function is used for memory optimization. It is advised to override and only return what is actually needed. If this function is not overriden, all the variables will be valid in Backward.</p>
<div class="fragment"><div class="line"><span class="comment">// The following code declares Backward need out_grad[0], in_data[0],in_data[1]</span></div>
<div class="line">vector&lt;int&gt; <a class="code" href="classmxnet_1_1OperatorProperty.html#a6c5c8df10748a7eee873d4b7eb8d684b">BackwardInputs</a>(<span class="keyword">const</span> vector&lt;int&gt; &amp;out_grad,</div>
<div class="line">                           <span class="keyword">const</span> vector&lt;int&gt; &amp;in_data,</div>
<div class="line">                           <span class="keyword">const</span> vector&lt;int&gt; &amp;out_data)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keywordflow">return</span> {out_grad[0], in_data[0], in_data[1]};</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_grad</td><td>gradient of outputs in backward pass. </td></tr>
    <tr><td class="paramname">in_data</td><td>the input data in forward pass. </td></tr>
    <tr><td class="paramname">out_data</td><td>the output data in forward pass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer vector indicating the input requirments </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmxnet_1_1OperatorProperty.html#a6c5c8df10748a7eee873d4b7eb8d684b" title="Get Backward Input Dependency for generic types of data. Normally T can be pointer of Symbol::DataEnt...">BackwardInputs</a> </dd></dl>

</div>
</div>
<a id="a149c52bd285e4fa78109a535765a9b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149c52bd285e4fa78109a535765a9b7c">&#9670;&nbsp;</a></span>exec_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacemxnet.html#ad7801fb2dd68294d4c7a9e289bc071ad">ExecType</a> mxnet::OperatorProperty::exec_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>execution type of the operator </dd></dl>

</div>
</div>
<a id="a91afbc64b53766d2d19236e99d966902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91afbc64b53766d2d19236e99d966902">&#9670;&nbsp;</a></span>ForwardInplaceOption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;int, void*&gt; &gt; mxnet::OperatorProperty::ForwardInplaceOption </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get possible forward inplace options. This function enables optimization to reuse memory of inputs in output. Only override when necessary, by default in-place is disabled. </p>
<p>The reason for void* type in the out_data is to distinguish the order of mappings between the two, compiler will report error when in_data and out_data's order in the pair get reversed.</p>
<div class="fragment"><div class="line"><span class="comment">// The following code says out_data[0] can share data with in_data[0]</span></div>
<div class="line">vector&lt;pair&lt;int, void*&gt; &gt; <a class="code" href="classmxnet_1_1OperatorProperty.html#a91afbc64b53766d2d19236e99d966902">ForwardInplaceOption</a>(<span class="keyword">const</span> vector&lt;int&gt; &amp;in_data,</div>
<div class="line">                                               <span class="keyword">const</span> vector&lt;void*&gt; &amp;out_data)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="keywordflow">return</span> {{in_data[0], out_data[0]}};</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_data</td><td>The input data in forward pass. </td></tr>
    <tr><td class="paramname">out_data</td><td>The output data in forward pass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of pair of that maps input-&gt;output, indicating possible in place operations. </dd></dl>

</div>
</div>
<a id="a203b8aa89f254f8e7a91b83d3ed18908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203b8aa89f254f8e7a91b83d3ed18908">&#9670;&nbsp;</a></span>ForwardResource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="structmxnet_1_1ResourceRequest.html">ResourceRequest</a>&gt; mxnet::OperatorProperty::ForwardResource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare additional resource required in forward pass. These additional resources will be presented in <a class="el" href="structmxnet_1_1OpContext.html#a833e95f95cf5e3af9c193b74b500fc5b" title="Resources requested by the operator.">OpContext.requested</a> in the same order of the returned <a class="el" href="structmxnet_1_1Resource.html" title="Resources used by mxnet operations. A resource is something special other than NDArray,...">Resource</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_shape</td><td>The input shape to the operator, corresponds to shapes of in_data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Additional resource request </dd></dl>

</div>
</div>
<a id="a704ae43181c8a88bfd0a47e8005f7cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704ae43181c8a88bfd0a47e8005f7cb8">&#9670;&nbsp;</a></span>GetParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::map&lt;std::string, std::string&gt; mxnet::OperatorProperty::GetParams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a map representation of internal parameters. This can be used by Init to recover the state of <a class="el" href="classmxnet_1_1OperatorProperty.html" title="OperatorProperty is a object that stores all information about Operator. It also contains method to g...">OperatorProperty</a>. </p>

</div>
</div>
<a id="a4be455d921fcb9e61ffafc567a31dc39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be455d921fcb9e61ffafc567a31dc39">&#9670;&nbsp;</a></span>InferShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mxnet::OperatorProperty::InferShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> *&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> *&#160;</td>
          <td class="paramname"><em>out_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> *&#160;</td>
          <td class="paramname"><em>aux_shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>infer the shapes of outputs and unknown input arguments </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_shape</td><td>the shape of input arguments of the operator this should be of same length as the vector returned by DescribeArgs in_shape allows unknown elements, which are checked by shape.ndim() == 0. For unknown shapes, InferShape will try to fill in the correct Shape in in_shape For known shapes, InferShape will check shape consistency</td></tr>
  </table>
  </dd>
</dl>
<p>common practice: set the shape of data input, and usually weight's shape can be inferred</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_shape</td><td>the shape of outputs of the operator InferShape will modify the vector to fill output <a class="el" href="classmxnet_1_1TShape.html" title="A Shape class that is used to represent shape of each tensor.">mxnet::TShape</a> </td></tr>
    <tr><td class="paramname">aux_shape</td><td>the shape of auxiliary states of the operator InferShape will modify the vector to fill output <a class="el" href="classmxnet_1_1TShape.html" title="A Shape class that is used to represent shape of each tensor.">mxnet::TShape</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the shape inference is successful, false if there is not enough information. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">dmlc::Error</td><td>if the known arg_shapes are inconsistent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a819b81e14761e9e8b9c888a63c7df1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819b81e14761e9e8b9c888a63c7df1fa">&#9670;&nbsp;</a></span>InferType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mxnet::OperatorProperty::InferType </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>in_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>out_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>aux_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>infer the data types of outputs and unknown input arguments </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_type</td><td>the type of input arguments of the operator this should be of same length as the vector returned by DescribeArgs in_type allows unknown elements, which are checked by type.ndim() == 0. For unknown types, Infertype will try to fill in the correct type in in_type For known types, Infertype will check type consistency</td></tr>
  </table>
  </dd>
</dl>
<p>common practice: set the type of data input, and usually weight's type can be inferred</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_type</td><td>the type of outputs of the operator Infertype will modify the vector to fill output Ttype </td></tr>
    <tr><td class="paramname">aux_type</td><td>the type of auxiliary states of the operator Infertype will modify the vector to fill output Ttype </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the type inference is successful, false if there is not enough information. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">dmlc::Error</td><td>if the known arg_types are inconsistent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fb32e0ab03a86517473db0f0630856c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb32e0ab03a86517473db0f0630856c">&#9670;&nbsp;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mxnet::OperatorProperty::Init </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kwargs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a> by setting the parameters This function need to be called before all other functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kwargs</td><td>the keyword arguments parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad01be3a84423800af7e818b45afc748f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01be3a84423800af7e818b45afc748f">&#9670;&nbsp;</a></span>ListArguments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; mxnet::OperatorProperty::ListArguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get input arguments of the <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of arguments. </dd></dl>

</div>
</div>
<a id="aa6d3a955ffa452a368a9dd4d33ce5a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d3a955ffa452a368a9dd4d33ce5a25">&#9670;&nbsp;</a></span>ListAuxiliaryStates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; mxnet::OperatorProperty::ListAuxiliaryStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get name of auxiliary states of <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>name of return values. </dd></dl>

</div>
</div>
<a id="ab9e52badb93fe965ce961803f2101aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e52badb93fe965ce961803f2101aa7">&#9670;&nbsp;</a></span>ListOutputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; mxnet::OperatorProperty::ListOutputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get name of output values of <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>name of output values. </dd></dl>

</div>
</div>
<a id="a9fc6e9f04f52b1c05f62fb7357bb95c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc6e9f04f52b1c05f62fb7357bb95c4">&#9670;&nbsp;</a></span>NumOutputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int mxnet::OperatorProperty::NumOutputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of real return values of the <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a> </dd></dl>

</div>
</div>
<a id="a006f0e2c9b3f934e1f73b242b7e8b062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006f0e2c9b3f934e1f73b242b7e8b062">&#9670;&nbsp;</a></span>NumVisibleOutputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int mxnet::OperatorProperty::NumVisibleOutputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get number of visible return values during Symbol creation. If <a class="el" href="classmxnet_1_1OperatorProperty.html#a006f0e2c9b3f934e1f73b242b7e8b062" title="get number of visible return values during Symbol creation. If NumVisibleOutputs() = k,...">NumVisibleOutputs()</a> = k, and <a class="el" href="classmxnet_1_1OperatorProperty.html#a9fc6e9f04f52b1c05f62fb7357bb95c4">NumOutputs()</a> = n. The first k returns will be presented in the resulting symbol. </p>
<p>The rest of the returns can be used for auxiliary states for Backward. For example, Dropout will return [data, mask], with <a class="el" href="classmxnet_1_1OperatorProperty.html#a006f0e2c9b3f934e1f73b242b7e8b062" title="get number of visible return values during Symbol creation. If NumVisibleOutputs() = k,...">NumVisibleOutputs()</a> == 1. So when user call sym = Dropout(input), only data is presented in sym. But all the returns will be presented in out_data parameter of Backward if requested.</p>
<dl class="section return"><dt>Returns</dt><dd>number of default return values </dd></dl>

</div>
</div>
<a id="ac6b7df90c0285a1823b463c21e926698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b7df90c0285a1823b463c21e926698">&#9670;&nbsp;</a></span>TypeString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string mxnet::OperatorProperty::TypeString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the type string of the <a class="el" href="classmxnet_1_1Operator.html" title="Operator interface. Operator defines basic operation unit of optimized computation graph in mxnet....">Operator</a> subclasses override this function. </p>
<dl class="section return"><dt>Returns</dt><dd>The type string. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/work/mxnet/include/mxnet/<a class="el" href="include_2mxnet_2operator_8h_source.html">operator.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassmxnet_1_1OperatorProperty_html_a2c3c0366154cd257a3b76bbcf924ef80"><div class="ttname"><a href="classmxnet_1_1OperatorProperty.html#a2c3c0366154cd257a3b76bbcf924ef80">mxnet::OperatorProperty::BackwardInplaceOption</a></div><div class="ttdeci">virtual std::vector&lt; std::pair&lt; int, void * &gt; &gt; BackwardInplaceOption(const std::vector&lt; int &gt; &amp;out_grad, const std::vector&lt; int &gt; &amp;in_data, const std::vector&lt; int &gt; &amp;out_data, const std::vector&lt; void * &gt; &amp;in_grad) const</div><div class="ttdoc">Get possible backward inplace options. This function enables optimization to reuse memory of inputs i...</div><div class="ttdef"><b>Definition:</b> operator.h:386</div></div>
<div class="ttc" id="aclassmxnet_1_1OperatorProperty_html_a91afbc64b53766d2d19236e99d966902"><div class="ttname"><a href="classmxnet_1_1OperatorProperty.html#a91afbc64b53766d2d19236e99d966902">mxnet::OperatorProperty::ForwardInplaceOption</a></div><div class="ttdeci">virtual std::vector&lt; std::pair&lt; int, void * &gt; &gt; ForwardInplaceOption(const std::vector&lt; int &gt; &amp;in_data, const std::vector&lt; void * &gt; &amp;out_data) const</div><div class="ttdoc">Get possible forward inplace options. This function enables optimization to reuse memory of inputs in...</div><div class="ttdef"><b>Definition:</b> operator.h:355</div></div>
<div class="ttc" id="aclassmxnet_1_1OperatorProperty_html_a6c5c8df10748a7eee873d4b7eb8d684b"><div class="ttname"><a href="classmxnet_1_1OperatorProperty.html#a6c5c8df10748a7eee873d4b7eb8d684b">mxnet::OperatorProperty::BackwardInputs</a></div><div class="ttdeci">std::vector&lt; T &gt; BackwardInputs(const std::vector&lt; T &gt; &amp;out_grad, const std::vector&lt; T &gt; &amp;in_data, const std::vector&lt; T &gt; &amp;out_data) const</div><div class="ttdoc">Get Backward Input Dependency for generic types of data. Normally T can be pointer of Symbol::DataEnt...</div><div class="ttdef"><b>Definition:</b> operator.h:406</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 1 2021 20:32:50 for mxnet by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
