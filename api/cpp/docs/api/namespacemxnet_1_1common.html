<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mxnet: mxnet::common Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mxnet
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemxnet.html">mxnet</a></li><li class="navelem"><a class="el" href="namespacemxnet_1_1common.html">common</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mxnet::common Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemxnet_1_1common_1_1cuda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common_1_1cuda.html">cuda</a></td></tr>
<tr class="memdesc:namespacemxnet_1_1common_1_1cuda"><td class="mdescLeft">&#160;</td><td class="mdescRight">common utils for cuda <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxnet_1_1common_1_1helper"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common_1_1helper.html">helper</a></td></tr>
<tr class="memdesc:namespacemxnet_1_1common_1_1helper"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemxnet_1_1common_1_1random"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common_1_1random.html">random</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1common_1_1csr__idx__check.html">csr_idx_check</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indices should be non-negative, less than the number of columns and in ascending order per row.  <a href="structmxnet_1_1common_1_1csr__idx__check.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1common_1_1csr__indptr__check.html">csr_indptr_check</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IndPtr should be non-negative, in non-decreasing order, start with 0 and end with value equal with size of indices.  <a href="structmxnet_1_1common_1_1csr__indptr__check.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1common_1_1LazyAllocArray.html">LazyAllocArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1common_1_1MShadowTypeInfo.html">MShadowTypeInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmxnet_1_1common_1_1ObjectPool.html">ObjectPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object pool for fast allocation and deallocation.  <a href="classmxnet_1_1common_1_1ObjectPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1common_1_1ObjectPoolAllocatable.html">ObjectPoolAllocatable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper trait class for easy allocation and deallocation.  <a href="structmxnet_1_1common_1_1ObjectPoolAllocatable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1common_1_1rsp__idx__check.html">rsp_idx_check</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indices of RSPNDArray should be non-negative, less than the size of first dimension and in ascending order.  <a href="structmxnet_1_1common_1_1rsp__idx__check.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmxnet_1_1common_1_1StaticArray.html">StaticArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static array. This code is borrowed from struct Shape&lt;ndim&gt;, except that users can specify the type of the elements of the statically allocated array. The object instance of the struct is copyable between CPU and GPU.  <a href="structmxnet_1_1common_1_1StaticArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aceba8f2d6de65796966d7f1d341dcf33"><td class="memItemLeft" align="right" valign="top">typedef std::mt19937&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#aceba8f2d6de65796966d7f1d341dcf33">RANDOM_ENGINE</a></td></tr>
<tr class="memdesc:aceba8f2d6de65796966d7f1d341dcf33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random <a class="el" href="classmxnet_1_1Engine.html" title="Dependency engine that schedules operations.">Engine</a>.  <a href="namespacemxnet_1_1common.html#aceba8f2d6de65796966d7f1d341dcf33">More...</a><br /></td></tr>
<tr class="separator:aceba8f2d6de65796966d7f1d341dcf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2262a78f3d80b9adeb3b517246fe4335"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a2262a78f3d80b9adeb3b517246fe4335">SetupDefaultBlobsIn</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;src, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *bufs, std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; *blobs, std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *temp_src, std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *temp_dst, std::unordered_map&lt; uint32_t, uint32_t &gt; *idx_map)</td></tr>
<tr class="separator:a2262a78f3d80b9adeb3b517246fe4335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bf4d1e9b7392f106950b00de5a2c62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a28bf4d1e9b7392f106950b00de5a2c62">SetupDefaultBlobsOut</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;src, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *bufs, std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; *req, std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; *blobs, std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *temp_src, std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *temp_dst)</td></tr>
<tr class="separator:a28bf4d1e9b7392f106950b00de5a2c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc5d03c700c90be66f47c4f46d2ef6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a2dc5d03c700c90be66f47c4f46d2ef6a">SetupDefaultBlobsInOut</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;ndinputs, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;ndoutputs, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *in_bufs, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *out_bufs, std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; *req, std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; *input_blobs, std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; *output_blobs, std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *pre_temp_src, std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *pre_temp_dst, std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *post_temp_src, std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *post_temp_dst, std::unordered_map&lt; uint32_t, uint32_t &gt; *in_temp_idx_map, const std::vector&lt; uint32_t &gt; &amp;mutate_idx)</td></tr>
<tr class="separator:a2dc5d03c700c90be66f47c4f46d2ef6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f6653ed0571a1bc16afdfcf525c841"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a12f6653ed0571a1bc16afdfcf525c841">CastNonDefaultStorage</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;src, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;dst, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a> &amp;ctx, const bool is_gpu)</td></tr>
<tr class="separator:a12f6653ed0571a1bc16afdfcf525c841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6369bac95f2e7080088927858937d7b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a6369bac95f2e7080088927858937d7b0">SameType</a> (const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;attrs, std::vector&lt; int &gt; *iattr, std::vector&lt; int &gt; *oattr)</td></tr>
<tr class="memdesc:a6369bac95f2e7080088927858937d7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default type inference function, which assigns all undefined types to the same type of one of the inputs or outputs.  <a href="namespacemxnet_1_1common.html#a6369bac95f2e7080088927858937d7b0">More...</a><br /></td></tr>
<tr class="separator:a6369bac95f2e7080088927858937d7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f2eeb2434d3cdab77227b62ecf3d31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a33f2eeb2434d3cdab77227b62ecf3d31">DefaultStorageType</a> (const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;attrs, const int dev_mask, <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a> *dispatch_mode, std::vector&lt; int &gt; *iattr, std::vector&lt; int &gt; *oattr)</td></tr>
<tr class="memdesc:a33f2eeb2434d3cdab77227b62ecf3d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default storage type inference function, which assigns all undefined storage types to kDefaultStorage. If all of input and output storage types are kDefaultStorage, <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2ba2157864769b54d1d0f8f9be63393e7d6">DispatchMode::kFCompute</a> is assigned to dispatch_mode. Otherwise, <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2ba18bf63b4c196f79c9bca4ad8637e8fef">DispatchMode::kFComputeFallback</a> is assigned to dispatch_mode.  <a href="namespacemxnet_1_1common.html#a33f2eeb2434d3cdab77227b62ecf3d31">More...</a><br /></td></tr>
<tr class="separator:a33f2eeb2434d3cdab77227b62ecf3d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24b30a630e9ebf963f763a99b48ebc5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#ab24b30a630e9ebf963f763a99b48ebc5">storage_str</a> (int storage_id)</td></tr>
<tr class="separator:ab24b30a630e9ebf963f763a99b48ebc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd04f4664c3f1db116cdf6d86236a87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#abcd04f4664c3f1db116cdf6d86236a87">LogMemoryPlan</a> (const <a class="el" href="classnnvm_1_1Graph.html">nnvm::Graph</a> &amp;g)</td></tr>
<tr class="separator:abcd04f4664c3f1db116cdf6d86236a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497a260b6b4c473e4ad03477f500763e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a497a260b6b4c473e4ad03477f500763e">LogInferStorage</a> (const <a class="el" href="classnnvm_1_1Graph.html">nnvm::Graph</a> &amp;g)</td></tr>
<tr class="separator:a497a260b6b4c473e4ad03477f500763e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02752372972ae43c182e4994df2bddc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a02752372972ae43c182e4994df2bddc5">ReshapeOrCreate</a> (const std::string &amp;name, const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;dest_arg_shape, const int dest_arg_dtype, const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> dest_arg_stype, const <a class="el" href="structmxnet_1_1Context.html">Context</a> &amp;ctx, std::unordered_map&lt; std::string, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *shared_buffer, bool enable_row_sparse_sharing)</td></tr>
<tr class="memdesc:a02752372972ae43c182e4994df2bddc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the requested ndarray's shape size is less than the corresponding shared_data_array's shape size and the storage type is shareable, reuse the memory allocation in shared_buffer; otherwise, create a zero ndarray. Shareable storages include both default storage and row_sparse storage if enable_row_sparse_sharing is <code>True</code>, otherwise default storage only.  <a href="namespacemxnet_1_1common.html#a02752372972ae43c182e4994df2bddc5">More...</a><br /></td></tr>
<tr class="separator:a02752372972ae43c182e4994df2bddc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bebfe40260d14068675b893f6b1a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnnvm_1_1Graph.html">nnvm::Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a19bebfe40260d14068675b893f6b1a6b">AssignContext</a> (<a class="el" href="classnnvm_1_1Graph.html">nnvm::Graph</a> g, const <a class="el" href="structmxnet_1_1Context.html">Context</a> &amp;default_ctx, const std::map&lt; std::string, <a class="el" href="structmxnet_1_1Context.html">Context</a> &gt; &amp;ctx_map, const std::vector&lt; <a class="el" href="structmxnet_1_1Context.html">Context</a> &gt; &amp;in_arg_ctxes, const std::vector&lt; <a class="el" href="structmxnet_1_1Context.html">Context</a> &gt; &amp;arg_grad_ctxes, const std::vector&lt; <a class="el" href="structmxnet_1_1Context.html">Context</a> &gt; &amp;aux_state_ctxes, const std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; &amp;grad_req_types, size_t num_forward_inputs, size_t num_forward_outputs)</td></tr>
<tr class="memdesc:a19bebfe40260d14068675b893f6b1a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign context to the graph. This is triggered by both simple_bind and bind flows.  <a href="namespacemxnet_1_1common.html#a19bebfe40260d14068675b893f6b1a6b">More...</a><br /></td></tr>
<tr class="separator:a19bebfe40260d14068675b893f6b1a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d835d88a602aa1b8569b70f1d11e934"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a9d835d88a602aa1b8569b70f1d11e934">CopyGraph</a> (<a class="el" href="classnnvm_1_1Graph.html">nnvm::Graph</a> *dst, const <a class="el" href="classnnvm_1_1Graph.html">nnvm::Graph</a> &amp;src, bool copy_variables)</td></tr>
<tr class="memdesc:a9d835d88a602aa1b8569b70f1d11e934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the graph, optionally leaving original Variable nodes.  <a href="namespacemxnet_1_1common.html#a9d835d88a602aa1b8569b70f1d11e934">More...</a><br /></td></tr>
<tr class="separator:a9d835d88a602aa1b8569b70f1d11e934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4aa6dc54114ba01a1451be63a63e18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a6b4aa6dc54114ba01a1451be63a63e18">CheckForInputNameDuplicates</a> (const <a class="el" href="classnnvm_1_1IndexedGraph.html">nnvm::IndexedGraph</a> &amp;idx)</td></tr>
<tr class="memdesc:a6b4aa6dc54114ba01a1451be63a63e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether graph contains any duplicated names in its inputs.  <a href="namespacemxnet_1_1common.html#a6b4aa6dc54114ba01a1451be63a63e18">More...</a><br /></td></tr>
<tr class="separator:a6b4aa6dc54114ba01a1451be63a63e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17af88f97948c889f2f4ce88190122c1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a17af88f97948c889f2f4ce88190122c1">current_process_id</a> ()</td></tr>
<tr class="separator:a17af88f97948c889f2f4ce88190122c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fda469aba84baa370e81e94c7d5b0b"><td class="memTemplParams" colspan="2">template&lt;typename xpu &gt; </td></tr>
<tr class="memitem:a98fda469aba84baa370e81e94c7d5b0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a98fda469aba84baa370e81e94c7d5b0b">CheckFormatWrapper</a> (const <a class="el" href="structmxnet_1_1RunContext.html">RunContext</a> &amp;rctx, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;input, const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;err_cpu, const bool full_check)</td></tr>
<tr class="separator:a98fda469aba84baa370e81e94c7d5b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6baaba1469561220a2484be92cc77aae"><td class="memTemplParams" colspan="2">template&lt;typename xpu &gt; </td></tr>
<tr class="memitem:a6baaba1469561220a2484be92cc77aae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a6baaba1469561220a2484be92cc77aae">CheckFormatCSRImpl</a> (const <a class="el" href="structmxnet_1_1RunContext.html">RunContext</a> &amp;rctx, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;input, const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;err_cpu, const bool full_check)</td></tr>
<tr class="memdesc:a6baaba1469561220a2484be92cc77aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the validity of CSRNDArray.  <a href="namespacemxnet_1_1common.html#a6baaba1469561220a2484be92cc77aae">More...</a><br /></td></tr>
<tr class="separator:a6baaba1469561220a2484be92cc77aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd045f69bce37692fd1e8ccb0e2ab208"><td class="memTemplParams" colspan="2">template&lt;typename xpu &gt; </td></tr>
<tr class="memitem:afd045f69bce37692fd1e8ccb0e2ab208"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#afd045f69bce37692fd1e8ccb0e2ab208">CheckFormatRSPImpl</a> (const <a class="el" href="structmxnet_1_1RunContext.html">RunContext</a> &amp;rctx, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;input, const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;err_cpu, const bool full_check)</td></tr>
<tr class="memdesc:afd045f69bce37692fd1e8ccb0e2ab208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the validity of RowSparseNDArray.  <a href="namespacemxnet_1_1common.html#afd045f69bce37692fd1e8ccb0e2ab208">More...</a><br /></td></tr>
<tr class="separator:afd045f69bce37692fd1e8ccb0e2ab208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9a34663862df90d3aa8683a2d9052a"><td class="memTemplParams" colspan="2">template&lt;typename xpu &gt; </td></tr>
<tr class="memitem:aad9a34663862df90d3aa8683a2d9052a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#aad9a34663862df90d3aa8683a2d9052a">CheckFormatImpl</a> (const <a class="el" href="structmxnet_1_1RunContext.html">RunContext</a> &amp;rctx, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;input, const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;err_cpu, const bool full_check)</td></tr>
<tr class="separator:aad9a34663862df90d3aa8683a2d9052a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905e77124ee11208c40a8afd3ee42167"><td class="memTemplParams" colspan="2">template&lt;typename xpu &gt; </td></tr>
<tr class="memitem:a905e77124ee11208c40a8afd3ee42167"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a905e77124ee11208c40a8afd3ee42167">SparseRetainOpForwardRspWrapper</a> (<a class="el" href="structmshadow_1_1Stream.html">mshadow::Stream</a>&lt; xpu &gt; *s, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;input_nd, const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;idx_data, const <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> req, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *output_nd)</td></tr>
<tr class="memdesc:a905e77124ee11208c40a8afd3ee42167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pick rows specified by user input index array from a row sparse ndarray and save them in the output sparse ndarray.  <a href="namespacemxnet_1_1common.html#a905e77124ee11208c40a8afd3ee42167">More...</a><br /></td></tr>
<tr class="separator:a905e77124ee11208c40a8afd3ee42167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd53ea405dcc105e6b306148009ff827"><td class="memTemplParams" colspan="2">template&lt;typename xpu &gt; </td></tr>
<tr class="memitem:afd53ea405dcc105e6b306148009ff827"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#afd53ea405dcc105e6b306148009ff827">CastStorageDispatch</a> (const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a> &amp;ctx, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;input, const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;output)</td></tr>
<tr class="separator:afd53ea405dcc105e6b306148009ff827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2258092ce26805c0a8f65a4144c446dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a2258092ce26805c0a8f65a4144c446dd">ContainsOnlyStorage</a> (const <a class="el" href="namespacemxnet.html#a6606bef15f41cccade14c9400e8447cf">StorageTypeVector</a> &amp;vstorage, const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype)</td></tr>
<tr class="memdesc:a2258092ce26805c0a8f65a4144c446dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if all storage types in <code>vstorage</code> are the same as target <code>stype</code>. false is returned for empty inputs.  <a href="namespacemxnet_1_1common.html#a2258092ce26805c0a8f65a4144c446dd">More...</a><br /></td></tr>
<tr class="separator:a2258092ce26805c0a8f65a4144c446dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10765e03ef091a5dd81b1b3efa4b46f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a10765e03ef091a5dd81b1b3efa4b46f4">ContainsOnlyStorage</a> (const <a class="el" href="namespacemxnet.html#a6606bef15f41cccade14c9400e8447cf">StorageTypeVector</a> &amp;vstorage, const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype1, const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype2, bool *has_both)</td></tr>
<tr class="memdesc:a10765e03ef091a5dd81b1b3efa4b46f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if all storage types in <code>vstorage</code> are the same as target <code>stype1</code> or &lsquo;stype2&rsquo;. Sets boolean if both found. false is returned for empty inputs.  <a href="namespacemxnet_1_1common.html#a10765e03ef091a5dd81b1b3efa4b46f4">More...</a><br /></td></tr>
<tr class="separator:a10765e03ef091a5dd81b1b3efa4b46f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7d1b47adce6f8291db8c3106087b90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a9a7d1b47adce6f8291db8c3106087b90">ContainsOnlyStorage</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;ndarrays, const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype)</td></tr>
<tr class="memdesc:a9a7d1b47adce6f8291db8c3106087b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the storage types of arrays in <code>ndarrays</code> are the same as target <code>stype</code>. false is returned for empty inputs.  <a href="namespacemxnet_1_1common.html#a9a7d1b47adce6f8291db8c3106087b90">More...</a><br /></td></tr>
<tr class="separator:a9a7d1b47adce6f8291db8c3106087b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d39ea49a4b4c2aefdd106ffd2ec9a11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a4d39ea49a4b4c2aefdd106ffd2ec9a11">ContainsOnlyStorage</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;ndarrays, const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype1, const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype2, bool *has_both)</td></tr>
<tr class="memdesc:a4d39ea49a4b4c2aefdd106ffd2ec9a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the storage types of arrays in <code>ndarrays</code> are the same as targets <code>stype1</code> or <code>stype2</code>. false is returned for empty inputs.  <a href="namespacemxnet_1_1common.html#a4d39ea49a4b4c2aefdd106ffd2ec9a11">More...</a><br /></td></tr>
<tr class="separator:a4d39ea49a4b4c2aefdd106ffd2ec9a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3290f30e01079cb2e16095b085bf21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a1e3290f30e01079cb2e16095b085bf21">ContainsStorageType</a> (const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;ndarrays, const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype)</td></tr>
<tr class="memdesc:a1e3290f30e01079cb2e16095b085bf21"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if storage type of any array in <code>ndarrays</code> is the same as the target <code>stype</code>. false is returned for empty inputs.  <a href="namespacemxnet_1_1common.html#a1e3290f30e01079cb2e16095b085bf21">More...</a><br /></td></tr>
<tr class="separator:a1e3290f30e01079cb2e16095b085bf21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e4d394a12fd749c333d488c7196643"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a99e4d394a12fd749c333d488c7196643">ContainsStorageType</a> (const std::vector&lt; int &gt; &amp;ndstypes, const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype)</td></tr>
<tr class="memdesc:a99e4d394a12fd749c333d488c7196643"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if any storage type <code>ndstype</code> in <code>ndstypes</code> is the same as the target <code>stype</code>. false is returned for empty inputs.  <a href="namespacemxnet_1_1common.html#a99e4d394a12fd749c333d488c7196643">More...</a><br /></td></tr>
<tr class="separator:a99e4d394a12fd749c333d488c7196643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4716f6044f678090af8ae7ef3ace3a31"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a4716f6044f678090af8ae7ef3ace3a31">dispatch_mode_string</a> (const <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a> x)</td></tr>
<tr class="memdesc:a4716f6044f678090af8ae7ef3ace3a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">get string representation of dispatch_mode  <a href="namespacemxnet_1_1common.html#a4716f6044f678090af8ae7ef3ace3a31">More...</a><br /></td></tr>
<tr class="separator:a4716f6044f678090af8ae7ef3ace3a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab379cd302d59005010ae29aff6e55009"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#ab379cd302d59005010ae29aff6e55009">stype_string</a> (const int x)</td></tr>
<tr class="memdesc:ab379cd302d59005010ae29aff6e55009"><td class="mdescLeft">&#160;</td><td class="mdescRight">get string representation of storage_type  <a href="namespacemxnet_1_1common.html#ab379cd302d59005010ae29aff6e55009">More...</a><br /></td></tr>
<tr class="separator:ab379cd302d59005010ae29aff6e55009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733ce35d109323dbf4ef1f4bc3094870"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a733ce35d109323dbf4ef1f4bc3094870">dev_type_string</a> (const int dev_type)</td></tr>
<tr class="memdesc:a733ce35d109323dbf4ef1f4bc3094870"><td class="mdescLeft">&#160;</td><td class="mdescRight">get string representation of device type  <a href="namespacemxnet_1_1common.html#a733ce35d109323dbf4ef1f4bc3094870">More...</a><br /></td></tr>
<tr class="separator:a733ce35d109323dbf4ef1f4bc3094870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af830f5320dc0995fec0e885d650057dd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#af830f5320dc0995fec0e885d650057dd">attr_value_string</a> (const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;attrs, const std::string &amp;attr_name, std::string default_val=&quot;&quot;)</td></tr>
<tr class="separator:af830f5320dc0995fec0e885d650057dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40770734529b91fe60fa6b3d76043717"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a40770734529b91fe60fa6b3d76043717">operator_stype_string</a> (const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;attrs, const int dev_mask, const std::vector&lt; int &gt; &amp;in_attrs, const std::vector&lt; int &gt; &amp;out_attrs)</td></tr>
<tr class="memdesc:a40770734529b91fe60fa6b3d76043717"><td class="mdescLeft">&#160;</td><td class="mdescRight">get string representation of the operator stypes  <a href="namespacemxnet_1_1common.html#a40770734529b91fe60fa6b3d76043717">More...</a><br /></td></tr>
<tr class="separator:a40770734529b91fe60fa6b3d76043717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8873d9dcccfd8e613c1c156934cee98c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a8873d9dcccfd8e613c1c156934cee98c">operator_string</a> (const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;attrs, const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a> &amp;ctx, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;inputs, const std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; &amp;req, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;outputs)</td></tr>
<tr class="memdesc:a8873d9dcccfd8e613c1c156934cee98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">get string representation of the operator  <a href="namespacemxnet_1_1common.html#a8873d9dcccfd8e613c1c156934cee98c">More...</a><br /></td></tr>
<tr class="separator:a8873d9dcccfd8e613c1c156934cee98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27662fd97dc715a8e7223e2b4a62db3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#af27662fd97dc715a8e7223e2b4a62db3">LogOnce</a> (const std::string &amp;message)</td></tr>
<tr class="memdesc:af27662fd97dc715a8e7223e2b4a62db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">log message once. Intended for storage fallback warning messages.  <a href="namespacemxnet_1_1common.html#af27662fd97dc715a8e7223e2b4a62db3">More...</a><br /></td></tr>
<tr class="separator:af27662fd97dc715a8e7223e2b4a62db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad719abf411ea1ed9185c3849203820f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#aad719abf411ea1ed9185c3849203820f">LogStorageFallback</a> (const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;attrs, const int dev_mask, const std::vector&lt; int &gt; *in_attrs, const std::vector&lt; int &gt; *out_attrs)</td></tr>
<tr class="memdesc:aad719abf411ea1ed9185c3849203820f"><td class="mdescLeft">&#160;</td><td class="mdescRight">log storage fallback event  <a href="namespacemxnet_1_1common.html#aad719abf411ea1ed9185c3849203820f">More...</a><br /></td></tr>
<tr class="separator:aad719abf411ea1ed9185c3849203820f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467e8b51fc0d0a7266e9f3172b2ff7f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a467e8b51fc0d0a7266e9f3172b2ff7f1">GetNumThreadsPerGPU</a> ()</td></tr>
<tr class="separator:a467e8b51fc0d0a7266e9f3172b2ff7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56555edcc52c5b25bed90bd05e00b5fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a56555edcc52c5b25bed90bd05e00b5fa">GetExecNumMatchColor</a> ()</td></tr>
<tr class="separator:a56555edcc52c5b25bed90bd05e00b5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e646ace37016aa994a26d96e739a561"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a1e646ace37016aa994a26d96e739a561"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a1e646ace37016aa994a26d96e739a561">ParallelAccumulate</a> (const T *a, const int n, V start)</td></tr>
<tr class="separator:a1e646ace37016aa994a26d96e739a561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7343dc26405918db27b8224ce41f05f6"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:a7343dc26405918db27b8224ce41f05f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a7343dc26405918db27b8224ce41f05f6">ParallelSortHelper</a> (RandomIt first, size_t len, size_t grainsize, const Compare &amp;comp)</td></tr>
<tr class="memdesc:a7343dc26405918db27b8224ce41f05f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for ParallelSort. DO NOT call this function directly. Use the interface ParallelSort instead. Ref: <a href="https://github.com/dmlc/difacto/blob/master/src/common/parallel_sort.h">https://github.com/dmlc/difacto/blob/master/src/common/parallel_sort.h</a>.  <a href="namespacemxnet_1_1common.html#a7343dc26405918db27b8224ce41f05f6">More...</a><br /></td></tr>
<tr class="separator:a7343dc26405918db27b8224ce41f05f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f273651755067ca9b1e6b8063c283b0"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt , typename Compare &gt; </td></tr>
<tr class="memitem:a1f273651755067ca9b1e6b8063c283b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a1f273651755067ca9b1e6b8063c283b0">ParallelSort</a> (RandomIt first, RandomIt last, size_t num_threads, Compare comp)</td></tr>
<tr class="memdesc:a1f273651755067ca9b1e6b8063c283b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the elements in the range [first, last) into the ascending order defined by the comparator comp. If the length of the range [first, last) is greater than a certain threshold, the range will be recursively divided into two and assign two threads to sort each half range. Ref: <a href="https://github.com/dmlc/difacto/blob/master/src/common/parallel_sort.h">https://github.com/dmlc/difacto/blob/master/src/common/parallel_sort.h</a>.  <a href="namespacemxnet_1_1common.html#a1f273651755067ca9b1e6b8063c283b0">More...</a><br /></td></tr>
<tr class="separator:a1f273651755067ca9b1e6b8063c283b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c7fe2df1babee66696d2b449e2123c"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt &gt; </td></tr>
<tr class="memitem:af2c7fe2df1babee66696d2b449e2123c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#af2c7fe2df1babee66696d2b449e2123c">ParallelSort</a> (RandomIt first, RandomIt last, size_t num_threads)</td></tr>
<tr class="memdesc:af2c7fe2df1babee66696d2b449e2123c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the elements in the range [first, last) into ascending order. The elements are compared using the default &lt; operator. If the length of the range [first, last) is greater than a certain threshold, the range will be recursively divided into two and assign two threads to sort each half range. Ref: <a href="https://github.com/dmlc/difacto/blob/master/src/common/parallel_sort.h">https://github.com/dmlc/difacto/blob/master/src/common/parallel_sort.h</a>.  <a href="namespacemxnet_1_1common.html#af2c7fe2df1babee66696d2b449e2123c">More...</a><br /></td></tr>
<tr class="separator:af2c7fe2df1babee66696d2b449e2123c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56ff4f856437bba25d38027aecfe766"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:ad56ff4f856437bba25d38027aecfe766"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmxnet_1_1common_1_1helper_1_1UniqueIf.html">helper::UniqueIf</a>&lt; T &gt;::SingleObject&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#ad56ff4f856437bba25d38027aecfe766">MakeUnique</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad56ff4f856437bba25d38027aecfe766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type <code>T</code> and wraps it in a <code>std</code><code>::</code><code>unique_ptr</code>.  <a href="namespacemxnet_1_1common.html#ad56ff4f856437bba25d38027aecfe766">More...</a><br /></td></tr>
<tr class="separator:ad56ff4f856437bba25d38027aecfe766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b3453302aa3aa56230fbc88005861d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a39b3453302aa3aa56230fbc88005861d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmxnet_1_1common_1_1helper_1_1UniqueIf.html">helper::UniqueIf</a>&lt; T &gt;::UnknownBound&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a39b3453302aa3aa56230fbc88005861d">MakeUnique</a> (size_t n)</td></tr>
<tr class="memdesc:a39b3453302aa3aa56230fbc88005861d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type <code>T</code> and wraps it in a <code>std</code><code>::</code><code>unique_ptr</code>.  <a href="namespacemxnet_1_1common.html#a39b3453302aa3aa56230fbc88005861d">More...</a><br /></td></tr>
<tr class="separator:a39b3453302aa3aa56230fbc88005861d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb63438b723f69cdf56f7919275f4596"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:adb63438b723f69cdf56f7919275f4596"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmxnet_1_1common_1_1helper_1_1UniqueIf.html">helper::UniqueIf</a>&lt; T &gt;::KnownBound&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#adb63438b723f69cdf56f7919275f4596">MakeUnique</a> (Args &amp;&amp;... args)=delete</td></tr>
<tr class="memdesc:adb63438b723f69cdf56f7919275f4596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type <code>T</code> and wraps it in a <code>std</code><code>::</code><code>unique_ptr</code>.  <a href="namespacemxnet_1_1common.html#adb63438b723f69cdf56f7919275f4596">More...</a><br /></td></tr>
<tr class="separator:adb63438b723f69cdf56f7919275f4596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abcb76ccd9022ebacdacd69c821cdc2"><td class="memTemplParams" colspan="2">template&lt;typename FCompType &gt; </td></tr>
<tr class="memitem:a1abcb76ccd9022ebacdacd69c821cdc2"><td class="memTemplItemLeft" align="right" valign="top">FCompType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a1abcb76ccd9022ebacdacd69c821cdc2">GetFCompute</a> (const <a class="el" href="classnnvm_1_1Op.html">nnvm::Op</a> *op, const std::string &amp;name, const <a class="el" href="structmxnet_1_1Context.html">Context</a> &amp;ctx)</td></tr>
<tr class="separator:a1abcb76ccd9022ebacdacd69c821cdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325e95d176e17c22ea18db6694093ad7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a325e95d176e17c22ea18db6694093ad7"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a325e95d176e17c22ea18db6694093ad7">MaxIntegerValue</a> ()</td></tr>
<tr class="memdesc:a325e95d176e17c22ea18db6694093ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the max integer value representable in the type <code>T</code> without loss of precision.  <a href="namespacemxnet_1_1common.html#a325e95d176e17c22ea18db6694093ad7">More...</a><br /></td></tr>
<tr class="separator:a325e95d176e17c22ea18db6694093ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5002a24372f2c7325c78a747270cf9"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7b5002a24372f2c7325c78a747270cf9"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a7b5002a24372f2c7325c78a747270cf9">MaxIntegerValue&lt; mshadow::half::half_t &gt;</a> ()</td></tr>
<tr class="separator:a7b5002a24372f2c7325c78a747270cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49aed737bf5e84006016a8e863f422cf"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a49aed737bf5e84006016a8e863f422cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a49aed737bf5e84006016a8e863f422cf">MaxIntegerValue&lt; mshadow::bfloat::bf16_t &gt;</a> ()</td></tr>
<tr class="separator:a49aed737bf5e84006016a8e863f422cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45245532df14e35b887c2ec91939d8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="3rdparty_2mshadow_2mshadow_2base_8h.html#af205b8ab4d8733133d590df7d2639d69">MSHADOW_XINLINE</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#ad45245532df14e35b887c2ec91939d8d">ilog2ul</a> (size_t a)</td></tr>
<tr class="separator:ad45245532df14e35b887c2ec91939d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c77619725d8bc68a085bdbcaa5416b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="3rdparty_2mshadow_2mshadow_2base_8h.html#af205b8ab4d8733133d590df7d2639d69">MSHADOW_XINLINE</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a44c77619725d8bc68a085bdbcaa5416b">ilog2ui</a> (unsigned int a)</td></tr>
<tr class="separator:a44c77619725d8bc68a085bdbcaa5416b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3cdf4e5f766e793e20d56b1fc4386e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#aaa3cdf4e5f766e793e20d56b1fc4386e">InitZeros</a> (const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype, const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;shape, const <a class="el" href="structmxnet_1_1Context.html">Context</a> &amp;ctx, const int dtype)</td></tr>
<tr class="memdesc:aaa3cdf4e5f766e793e20d56b1fc4386e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface">NDArray</a> of all zeros.  <a href="namespacemxnet_1_1common.html#aaa3cdf4e5f766e793e20d56b1fc4386e">More...</a><br /></td></tr>
<tr class="separator:aaa3cdf4e5f766e793e20d56b1fc4386e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214e7e05193ff2ddf8c1f88afa5c2d9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a214e7e05193ff2ddf8c1f88afa5c2d9c">EmplaceBackZeros</a> (const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a> stype, const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;shape, const <a class="el" href="structmxnet_1_1Context.html">Context</a> &amp;ctx, const int dtype, std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *vec)</td></tr>
<tr class="memdesc:a214e7e05193ff2ddf8c1f88afa5c2d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to add a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface">NDArray</a> of zeros to a std::vector.  <a href="namespacemxnet_1_1common.html#a214e7e05193ff2ddf8c1f88afa5c2d9c">More...</a><br /></td></tr>
<tr class="separator:a214e7e05193ff2ddf8c1f88afa5c2d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4dccb2b37c896faf7409e002bf4eb2"><td class="memTemplParams" colspan="2">template&lt;typename DType &gt; </td></tr>
<tr class="memitem:abc4dccb2b37c896faf7409e002bf4eb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#abc4dccb2b37c896faf7409e002bf4eb2">ParallelCopy</a> (DType *dst, const DType *src, <a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> size)</td></tr>
<tr class="memdesc:abc4dccb2b37c896faf7409e002bf4eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallelize copy by OpenMP.  <a href="namespacemxnet_1_1common.html#abc4dccb2b37c896faf7409e002bf4eb2">More...</a><br /></td></tr>
<tr class="separator:abc4dccb2b37c896faf7409e002bf4eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4809d73b8689e4898d3608b15c877035"><td class="memTemplParams" colspan="2">template&lt;typename DType &gt; </td></tr>
<tr class="memitem:a4809d73b8689e4898d3608b15c877035"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a4809d73b8689e4898d3608b15c877035">ParallelAdd</a> (DType *dst, const DType *src, <a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> size)</td></tr>
<tr class="separator:a4809d73b8689e4898d3608b15c877035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0a2c4df1828cd070c9afe47402507b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#abe0a2c4df1828cd070c9afe47402507b">ConvertToNumpyShape</a> (<a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> *shape)</td></tr>
<tr class="memdesc:abe0a2c4df1828cd070c9afe47402507b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If numpy compatibility is turned off (default), the shapes passed in by users follow the legacy shape definition:  <a href="namespacemxnet_1_1common.html#abe0a2c4df1828cd070c9afe47402507b">More...</a><br /></td></tr>
<tr class="separator:abe0a2c4df1828cd070c9afe47402507b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7959f5a687e97776596c86a2bedca252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a7959f5a687e97776596c86a2bedca252">ConvertToNumpyShape</a> (<a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> *shapes)</td></tr>
<tr class="separator:a7959f5a687e97776596c86a2bedca252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b1fe2cdc172ad5828cca0c7bb207ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#ae2b1fe2cdc172ad5828cca0c7bb207ed">ConvertToLegacyShape</a> (<a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> *shape)</td></tr>
<tr class="memdesc:ae2b1fe2cdc172ad5828cca0c7bb207ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is function is used to convert shapes returned by the infer shape functions/pass to the legacy shape definition.  <a href="namespacemxnet_1_1common.html#ae2b1fe2cdc172ad5828cca0c7bb207ed">More...</a><br /></td></tr>
<tr class="separator:ae2b1fe2cdc172ad5828cca0c7bb207ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0649dba32ab254c7d06b10881f6f5875"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a0649dba32ab254c7d06b10881f6f5875">ConvertToLegacyShape</a> (<a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> *shapes)</td></tr>
<tr class="separator:a0649dba32ab254c7d06b10881f6f5875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8a81c55bcebde7dcc7cdfd92d1db42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a9d8a81c55bcebde7dcc7cdfd92d1db42">ExecuteMonInputCallback</a> (const <a class="el" href="classnnvm_1_1IndexedGraph.html">nnvm::IndexedGraph</a> &amp;idx, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> * &gt; &amp;state_arrays, size_t nid, const std::function&lt; void(const char *, const char *, void *)&gt; &amp;monitor_callback)</td></tr>
<tr class="separator:a9d8a81c55bcebde7dcc7cdfd92d1db42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5848bc969a0479325f5e25cde40cb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a6a5848bc969a0479325f5e25cde40cb2">ExecuteMonOutputCallback</a> (const <a class="el" href="classnnvm_1_1IndexedGraph.html">nnvm::IndexedGraph</a> &amp;idx, const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> * &gt; &amp;state_arrays, size_t nid, const std::function&lt; void(const char *, const char *, void *)&gt; &amp;monitor_callback)</td></tr>
<tr class="separator:a6a5848bc969a0479325f5e25cde40cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce8b75eb931216c17862500600d7a0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a4ce8b75eb931216c17862500600d7a0b">CanonicalizeAxes</a> (const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;src)</td></tr>
<tr class="separator:a4ce8b75eb931216c17862500600d7a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0a47792e9132c71a77897d1cdf6f0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a5e0a47792e9132c71a77897d1cdf6f0b">is_float</a> (const int dtype)</td></tr>
<tr class="separator:a5e0a47792e9132c71a77897d1cdf6f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936c985e4dfd7d43ace2e57babb06393"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a936c985e4dfd7d43ace2e57babb06393">is_int</a> (const int dtype)</td></tr>
<tr class="separator:a936c985e4dfd7d43ace2e57babb06393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddc5f355bddea98d3b3e0a700c44a71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a2ddc5f355bddea98d3b3e0a700c44a71">get_more_precise_type</a> (const int type1, const int type2)</td></tr>
<tr class="separator:a2ddc5f355bddea98d3b3e0a700c44a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672cbe8a66412b740b29c6313a39d662"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a672cbe8a66412b740b29c6313a39d662">np_binary_out_infer_type</a> (const int type1, const int type2)</td></tr>
<tr class="separator:a672cbe8a66412b740b29c6313a39d662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c7b64afe7420b04b112f0d7c9f958e"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a13c7b64afe7420b04b112f0d7c9f958e">NodeAttrsGetProfilerScope</a> (const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;attrs)</td></tr>
<tr class="separator:a13c7b64afe7420b04b112f0d7c9f958e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b36e2468ddcac38fac199dd4c7e51a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#ae0b36e2468ddcac38fac199dd4c7e51a">GetDefaultDtype</a> ()</td></tr>
<tr class="separator:ae0b36e2468ddcac38fac199dd4c7e51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e6401b252fe60509bf79d5ea67ee5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a88e6401b252fe60509bf79d5ea67ee5b">GetDefaultDtype</a> (int dtype)</td></tr>
<tr class="separator:a88e6401b252fe60509bf79d5ea67ee5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a9546bbfefdbb83d23b9aa1e65778e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmxnet_1_1common_1_1MShadowTypeInfo.html">MShadowTypeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#aa8a9546bbfefdbb83d23b9aa1e65778e">mshadow_type_info</a> (const int type_flag)</td></tr>
<tr class="separator:aa8a9546bbfefdbb83d23b9aa1e65778e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9c5933ce14039397a350231ffd9ae5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#aca9c5933ce14039397a350231ffd9ae5">AlignedMemAlloc</a> (void **ptr, size_t size, size_t alignment)</td></tr>
<tr class="separator:aca9c5933ce14039397a350231ffd9ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b9b816c7daac34dbe8def182d1a482"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a38b9b816c7daac34dbe8def182d1a482">AlignedMemFree</a> (void *ptr)</td></tr>
<tr class="separator:a38b9b816c7daac34dbe8def182d1a482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9f2438cbb8114214f90251115fe0ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#abe9f2438cbb8114214f90251115fe0ae">div_round</a> (const <a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> a, const <a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> b)</td></tr>
<tr class="separator:abe9f2438cbb8114214f90251115fe0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f893aa94eae795ef6730779bd6ed4e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a6f893aa94eae795ef6730779bd6ed4e2">IsPower2</a> (size_t N)</td></tr>
<tr class="separator:a6f893aa94eae795ef6730779bd6ed4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbe19a0704b5476faa0f5645ee9ac1a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemxnet_1_1common.html#a5fbe19a0704b5476faa0f5645ee9ac1a">RoundToPower2</a> (size_t N)</td></tr>
<tr class="separator:a5fbe19a0704b5476faa0f5645ee9ac1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aceba8f2d6de65796966d7f1d341dcf33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceba8f2d6de65796966d7f1d341dcf33">&#9670;&nbsp;</a></span>RANDOM_ENGINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::mt19937 <a class="el" href="namespacemxnet_1_1common.html#aceba8f2d6de65796966d7f1d341dcf33">mxnet::common::RANDOM_ENGINE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random <a class="el" href="classmxnet_1_1Engine.html" title="Dependency engine that schedules operations.">Engine</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aca9c5933ce14039397a350231ffd9ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9c5933ce14039397a350231ffd9ae5">&#9670;&nbsp;</a></span>AlignedMemAlloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::common::AlignedMemAlloc </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a38b9b816c7daac34dbe8def182d1a482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b9b816c7daac34dbe8def182d1a482">&#9670;&nbsp;</a></span>AlignedMemFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::AlignedMemFree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19bebfe40260d14068675b893f6b1a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bebfe40260d14068675b893f6b1a6b">&#9670;&nbsp;</a></span>AssignContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnnvm_1_1Graph.html">nnvm::Graph</a> mxnet::common::AssignContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnnvm_1_1Graph.html">nnvm::Graph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmxnet_1_1Context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>default_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="structmxnet_1_1Context.html">Context</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctx_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structmxnet_1_1Context.html">Context</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_arg_ctxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structmxnet_1_1Context.html">Context</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg_grad_ctxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structmxnet_1_1Context.html">Context</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aux_state_ctxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>grad_req_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_forward_inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_forward_outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign context to the graph. This is triggered by both simple_bind and bind flows. </p>

</div>
</div>
<a id="af830f5320dc0995fec0e885d650057dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af830f5320dc0995fec0e885d650057dd">&#9670;&nbsp;</a></span>attr_value_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mxnet::common::attr_value_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attr_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>default_val</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ce8b75eb931216c17862500600d7a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce8b75eb931216c17862500600d7a0b">&#9670;&nbsp;</a></span>CanonicalizeAxes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> mxnet::common::CanonicalizeAxes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12f6653ed0571a1bc16afdfcf525c841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f6653ed0571a1bc16afdfcf525c841">&#9670;&nbsp;</a></span>CastNonDefaultStorage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::CastNonDefaultStorage </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_gpu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd53ea405dcc105e6b306148009ff827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd53ea405dcc105e6b306148009ff827">&#9670;&nbsp;</a></span>CastStorageDispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename xpu &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::CastStorageDispatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b4aa6dc54114ba01a1451be63a63e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4aa6dc54114ba01a1451be63a63e18">&#9670;&nbsp;</a></span>CheckForInputNameDuplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::common::CheckForInputNameDuplicates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnnvm_1_1IndexedGraph.html">nnvm::IndexedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether graph contains any duplicated names in its inputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Indexed graph being checked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there are no duplicates, false otherwise </dd></dl>

</div>
</div>
<a id="a6baaba1469561220a2484be92cc77aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6baaba1469561220a2484be92cc77aae">&#9670;&nbsp;</a></span>CheckFormatCSRImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename xpu &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::CheckFormatCSRImpl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmxnet_1_1RunContext.html">RunContext</a> &amp;&#160;</td>
          <td class="paramname"><em>rctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;&#160;</td>
          <td class="paramname"><em>err_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>full_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the validity of CSRNDArray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rctx</td><td>Execution context. </td></tr>
    <tr><td class="paramname">input</td><td>Input <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface">NDArray</a> of CSRStorage. </td></tr>
    <tr><td class="paramname">err_cpu</td><td>Error number on cpu. </td></tr>
    <tr><td class="paramname">full_check</td><td>If true, rigorous check, O(N) operations, otherwise basic check, O(1) operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad9a34663862df90d3aa8683a2d9052a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9a34663862df90d3aa8683a2d9052a">&#9670;&nbsp;</a></span>CheckFormatImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename xpu &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::CheckFormatImpl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmxnet_1_1RunContext.html">RunContext</a> &amp;&#160;</td>
          <td class="paramname"><em>rctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;&#160;</td>
          <td class="paramname"><em>err_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>full_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd045f69bce37692fd1e8ccb0e2ab208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd045f69bce37692fd1e8ccb0e2ab208">&#9670;&nbsp;</a></span>CheckFormatRSPImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename xpu &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::CheckFormatRSPImpl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmxnet_1_1RunContext.html">RunContext</a> &amp;&#160;</td>
          <td class="paramname"><em>rctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;&#160;</td>
          <td class="paramname"><em>err_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>full_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the validity of RowSparseNDArray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rctx</td><td>Execution context. </td></tr>
    <tr><td class="paramname">input</td><td>Input <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface">NDArray</a> of RowSparseStorage. </td></tr>
    <tr><td class="paramname">err_cpu</td><td>Error number on cpu. </td></tr>
    <tr><td class="paramname">full_check</td><td>If true, rigorous check, O(N) operations, otherwise basic check, O(1) operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98fda469aba84baa370e81e94c7d5b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98fda469aba84baa370e81e94c7d5b0b">&#9670;&nbsp;</a></span>CheckFormatWrapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename xpu &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::CheckFormatWrapper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmxnet_1_1RunContext.html">RunContext</a> &amp;&#160;</td>
          <td class="paramname"><em>rctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;&#160;</td>
          <td class="paramname"><em>err_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>full_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a7d1b47adce6f8291db8c3106087b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7d1b47adce6f8291db8c3106087b90">&#9670;&nbsp;</a></span>ContainsOnlyStorage() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::common::ContainsOnlyStorage </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ndarrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a>&#160;</td>
          <td class="paramname"><em>stype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if the storage types of arrays in <code>ndarrays</code> are the same as target <code>stype</code>. false is returned for empty inputs. </p>

</div>
</div>
<a id="a4d39ea49a4b4c2aefdd106ffd2ec9a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d39ea49a4b4c2aefdd106ffd2ec9a11">&#9670;&nbsp;</a></span>ContainsOnlyStorage() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::common::ContainsOnlyStorage </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ndarrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a>&#160;</td>
          <td class="paramname"><em>stype1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a>&#160;</td>
          <td class="paramname"><em>stype2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>has_both</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if the storage types of arrays in <code>ndarrays</code> are the same as targets <code>stype1</code> or <code>stype2</code>. false is returned for empty inputs. </p>

</div>
</div>
<a id="a2258092ce26805c0a8f65a4144c446dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2258092ce26805c0a8f65a4144c446dd">&#9670;&nbsp;</a></span>ContainsOnlyStorage() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::common::ContainsOnlyStorage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a6606bef15f41cccade14c9400e8447cf">StorageTypeVector</a> &amp;&#160;</td>
          <td class="paramname"><em>vstorage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a>&#160;</td>
          <td class="paramname"><em>stype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if all storage types in <code>vstorage</code> are the same as target <code>stype</code>. false is returned for empty inputs. </p>

</div>
</div>
<a id="a10765e03ef091a5dd81b1b3efa4b46f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10765e03ef091a5dd81b1b3efa4b46f4">&#9670;&nbsp;</a></span>ContainsOnlyStorage() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::common::ContainsOnlyStorage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a6606bef15f41cccade14c9400e8447cf">StorageTypeVector</a> &amp;&#160;</td>
          <td class="paramname"><em>vstorage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a>&#160;</td>
          <td class="paramname"><em>stype1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a>&#160;</td>
          <td class="paramname"><em>stype2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>has_both</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if all storage types in <code>vstorage</code> are the same as target <code>stype1</code> or &lsquo;stype2&rsquo;. Sets boolean if both found. false is returned for empty inputs. </p>

</div>
</div>
<a id="a99e4d394a12fd749c333d488c7196643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e4d394a12fd749c333d488c7196643">&#9670;&nbsp;</a></span>ContainsStorageType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::common::ContainsStorageType </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ndstypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a>&#160;</td>
          <td class="paramname"><em>stype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if any storage type <code>ndstype</code> in <code>ndstypes</code> is the same as the target <code>stype</code>. false is returned for empty inputs. </p>

</div>
</div>
<a id="a1e3290f30e01079cb2e16095b085bf21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3290f30e01079cb2e16095b085bf21">&#9670;&nbsp;</a></span>ContainsStorageType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::common::ContainsStorageType </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ndarrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a>&#160;</td>
          <td class="paramname"><em>stype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns true if storage type of any array in <code>ndarrays</code> is the same as the target <code>stype</code>. false is returned for empty inputs. </p>

</div>
</div>
<a id="a0649dba32ab254c7d06b10881f6f5875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0649dba32ab254c7d06b10881f6f5875">&#9670;&nbsp;</a></span>ConvertToLegacyShape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::ConvertToLegacyShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> *&#160;</td>
          <td class="paramname"><em>shapes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2b1fe2cdc172ad5828cca0c7bb207ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b1fe2cdc172ad5828cca0c7bb207ed">&#9670;&nbsp;</a></span>ConvertToLegacyShape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::ConvertToLegacyShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> *&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is function is used to convert shapes returned by the infer shape functions/pass to the legacy shape definition. </p>

</div>
</div>
<a id="a7959f5a687e97776596c86a2bedca252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7959f5a687e97776596c86a2bedca252">&#9670;&nbsp;</a></span>ConvertToNumpyShape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::ConvertToNumpyShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#a87e1c30aafac389774c6f4d905c0e5ea">mxnet::ShapeVector</a> *&#160;</td>
          <td class="paramname"><em>shapes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abe0a2c4df1828cd070c9afe47402507b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0a2c4df1828cd070c9afe47402507b">&#9670;&nbsp;</a></span>ConvertToNumpyShape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::ConvertToNumpyShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> *&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If numpy compatibility is turned off (default), the shapes passed in by users follow the legacy shape definition: </p>
<ol type="1">
<li>0 ndim means the shape is completely unknown.</li>
<li>0 dim size means the dim size is unknown. We need to convert those shapes to use the numpy shape definition:</li>
</ol>
<ol type="1">
<li>0 ndim means it's a scalar tensor.</li>
<li>-1 ndim means the shape is unknown.</li>
<li>0 dim size means no elements in that dimension.</li>
<li>-1 dim size means the dimension's size is unknown. so that operator's infer shape function can work in backend. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>to be converted. Note: It is possible that the shape to be converted is already numpy compatible. For example, when a subgraph operator's infer shape function is called from the infer shape pass of the whole graph, its input/output shapes have been converted to numpy compatible shapes. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ol>

</div>
</div>
<a id="a9d835d88a602aa1b8569b70f1d11e934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d835d88a602aa1b8569b70f1d11e934">&#9670;&nbsp;</a></span>CopyGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::CopyGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnnvm_1_1Graph.html">nnvm::Graph</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnnvm_1_1Graph.html">nnvm::Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the graph, optionally leaving original Variable nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination graph </td></tr>
    <tr><td class="paramname">src</td><td>source graph being copied </td></tr>
    <tr><td class="paramname">copy_variable</td><td>whether to copy or reuse Variable nodes from the source graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17af88f97948c889f2f4ce88190122c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17af88f97948c889f2f4ce88190122c1">&#9670;&nbsp;</a></span>current_process_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t mxnet::common::current_process_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a33f2eeb2434d3cdab77227b62ecf3d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f2eeb2434d3cdab77227b62ecf3d31">&#9670;&nbsp;</a></span>DefaultStorageType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::common::DefaultStorageType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dev_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a> *&#160;</td>
          <td class="paramname"><em>dispatch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>iattr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>oattr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default storage type inference function, which assigns all undefined storage types to kDefaultStorage. If all of input and output storage types are kDefaultStorage, <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2ba2157864769b54d1d0f8f9be63393e7d6">DispatchMode::kFCompute</a> is assigned to dispatch_mode. Otherwise, <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2ba18bf63b4c196f79c9bca4ad8637e8fef">DispatchMode::kFComputeFallback</a> is assigned to dispatch_mode. </p>

</div>
</div>
<a id="a733ce35d109323dbf4ef1f4bc3094870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733ce35d109323dbf4ef1f4bc3094870">&#9670;&nbsp;</a></span>dev_type_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mxnet::common::dev_type_string </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dev_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get string representation of device type </p>

</div>
</div>
<a id="a4716f6044f678090af8ae7ef3ace3a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4716f6044f678090af8ae7ef3ace3a31">&#9670;&nbsp;</a></span>dispatch_mode_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mxnet::common::dispatch_mode_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#aad5fec2b4bceabbf4b884460cc2e0a2b">DispatchMode</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get string representation of dispatch_mode </p>

</div>
</div>
<a id="abe9f2438cbb8114214f90251115fe0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9f2438cbb8114214f90251115fe0ae">&#9670;&nbsp;</a></span>div_round()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a> mxnet::common::div_round </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a214e7e05193ff2ddf8c1f88afa5c2d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214e7e05193ff2ddf8c1f88afa5c2d9c">&#9670;&nbsp;</a></span>EmplaceBackZeros()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::EmplaceBackZeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a>&#160;</td>
          <td class="paramname"><em>stype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmxnet_1_1Context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to add a <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface">NDArray</a> of zeros to a std::vector. </p>

</div>
</div>
<a id="a9d8a81c55bcebde7dcc7cdfd92d1db42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8a81c55bcebde7dcc7cdfd92d1db42">&#9670;&nbsp;</a></span>ExecuteMonInputCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::ExecuteMonInputCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnnvm_1_1IndexedGraph.html">nnvm::IndexedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const char *, const char *, void *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>monitor_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a5848bc969a0479325f5e25cde40cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5848bc969a0479325f5e25cde40cb2">&#9670;&nbsp;</a></span>ExecuteMonOutputCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::ExecuteMonOutputCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnnvm_1_1IndexedGraph.html">nnvm::IndexedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const char *, const char *, void *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>monitor_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ddc5f355bddea98d3b3e0a700c44a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddc5f355bddea98d3b3e0a700c44a71">&#9670;&nbsp;</a></span>get_more_precise_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mxnet::common::get_more_precise_type </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0b36e2468ddcac38fac199dd4c7e51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b36e2468ddcac38fac199dd4c7e51a">&#9670;&nbsp;</a></span>GetDefaultDtype() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mxnet::common::GetDefaultDtype </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a88e6401b252fe60509bf79d5ea67ee5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e6401b252fe60509bf79d5ea67ee5b">&#9670;&nbsp;</a></span>GetDefaultDtype() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mxnet::common::GetDefaultDtype </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56555edcc52c5b25bed90bd05e00b5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56555edcc52c5b25bed90bd05e00b5fa">&#9670;&nbsp;</a></span>GetExecNumMatchColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mxnet::common::GetExecNumMatchColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1abcb76ccd9022ebacdacd69c821cdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abcb76ccd9022ebacdacd69c821cdc2">&#9670;&nbsp;</a></span>GetFCompute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FCompType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FCompType mxnet::common::GetFCompute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnnvm_1_1Op.html">nnvm::Op</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmxnet_1_1Context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a467e8b51fc0d0a7266e9f3172b2ff7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467e8b51fc0d0a7266e9f3172b2ff7f1">&#9670;&nbsp;</a></span>GetNumThreadsPerGPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mxnet::common::GetNumThreadsPerGPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44c77619725d8bc68a085bdbcaa5416b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c77619725d8bc68a085bdbcaa5416b">&#9670;&nbsp;</a></span>ilog2ui()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="3rdparty_2mshadow_2mshadow_2base_8h.html#af205b8ab4d8733133d590df7d2639d69">MSHADOW_XINLINE</a> int mxnet::common::ilog2ui </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad45245532df14e35b887c2ec91939d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45245532df14e35b887c2ec91939d8d">&#9670;&nbsp;</a></span>ilog2ul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="3rdparty_2mshadow_2mshadow_2base_8h.html#af205b8ab4d8733133d590df7d2639d69">MSHADOW_XINLINE</a> int mxnet::common::ilog2ul </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa3cdf4e5f766e793e20d56b1fc4386e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3cdf4e5f766e793e20d56b1fc4386e">&#9670;&nbsp;</a></span>InitZeros()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::common::InitZeros </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a>&#160;</td>
          <td class="paramname"><em>stype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmxnet_1_1Context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an <a class="el" href="classmxnet_1_1NDArray.html" title="ndarray interface">NDArray</a> of all zeros. </p>

</div>
</div>
<a id="a5e0a47792e9132c71a77897d1cdf6f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0a47792e9132c71a77897d1cdf6f0b">&#9670;&nbsp;</a></span>is_float()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::common::is_float </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a936c985e4dfd7d43ace2e57babb06393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936c985e4dfd7d43ace2e57babb06393">&#9670;&nbsp;</a></span>is_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::common::is_int </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f893aa94eae795ef6730779bd6ed4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f893aa94eae795ef6730779bd6ed4e2">&#9670;&nbsp;</a></span>IsPower2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::common::IsPower2 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a497a260b6b4c473e4ad03477f500763e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497a260b6b4c473e4ad03477f500763e">&#9670;&nbsp;</a></span>LogInferStorage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::LogInferStorage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnnvm_1_1Graph.html">nnvm::Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abcd04f4664c3f1db116cdf6d86236a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd04f4664c3f1db116cdf6d86236a87">&#9670;&nbsp;</a></span>LogMemoryPlan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::LogMemoryPlan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnnvm_1_1Graph.html">nnvm::Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af27662fd97dc715a8e7223e2b4a62db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27662fd97dc715a8e7223e2b4a62db3">&#9670;&nbsp;</a></span>LogOnce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::LogOnce </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>log message once. Intended for storage fallback warning messages. </p>

</div>
</div>
<a id="aad719abf411ea1ed9185c3849203820f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad719abf411ea1ed9185c3849203820f">&#9670;&nbsp;</a></span>LogStorageFallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::LogStorageFallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dev_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>in_attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>out_attrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>log storage fallback event </p>

</div>
</div>
<a id="ad56ff4f856437bba25d38027aecfe766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56ff4f856437bba25d38027aecfe766">&#9670;&nbsp;</a></span>MakeUnique() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmxnet_1_1common_1_1helper_1_1UniqueIf.html">helper::UniqueIf</a>&lt;T&gt;::SingleObject mxnet::common::MakeUnique </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an object of type <code>T</code> and wraps it in a <code>std</code><code>::</code><code>unique_ptr</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>List of arguments with which an instance of <code>T</code> will be constructed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std</code><code>::</code><code>unique_ptr</code> of an instance of type <code>T</code>.</dd></dl>
<p>Constructs a non-array type <code>T</code>. The arguments <code>args</code> are passed to the constructor of <code>T</code>. The function does not participate in the overload resolution if <code>T</code> is an array type. </p>

</div>
</div>
<a id="adb63438b723f69cdf56f7919275f4596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb63438b723f69cdf56f7919275f4596">&#9670;&nbsp;</a></span>MakeUnique() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmxnet_1_1common_1_1helper_1_1UniqueIf.html">helper::UniqueIf</a>&lt;T&gt;::KnownBound mxnet::common::MakeUnique </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an object of type <code>T</code> and wraps it in a <code>std</code><code>::</code><code>unique_ptr</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>List of arguments with which an instance of <code>T</code> will be constructed.</td></tr>
  </table>
  </dd>
</dl>
<p>Constructs an arrays of known bound is disallowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>List of arguments with which an instance of <code>T</code> will be constructed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std</code><code>::</code><code>unique_ptr</code> of an instance of type <code>T</code>.</dd></dl>
<p>Constructs a non-array type <code>T</code>. The arguments <code>args</code> are passed to the constructor of <code>T</code>. The function does not participate in the overload resolution if <code>T</code> is an array type. </p>

</div>
</div>
<a id="a39b3453302aa3aa56230fbc88005861d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b3453302aa3aa56230fbc88005861d">&#9670;&nbsp;</a></span>MakeUnique() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmxnet_1_1common_1_1helper_1_1UniqueIf.html">helper::UniqueIf</a>&lt;T&gt;::UnknownBound mxnet::common::MakeUnique </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an object of type <code>T</code> and wraps it in a <code>std</code><code>::</code><code>unique_ptr</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The size of the array to construct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std</code><code>::</code><code>unique_ptr</code> of an instance of type <code>T</code>.</dd></dl>
<p>Constructs an array of unknown bound <code>T</code>. The function does not participate in the overload resolution unless <code>T</code> is an array of unknown bound. </p>

</div>
</div>
<a id="a325e95d176e17c22ea18db6694093ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325e95d176e17c22ea18db6694093ad7">&#9670;&nbsp;</a></span>MaxIntegerValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t mxnet::common::MaxIntegerValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the max integer value representable in the type <code>T</code> without loss of precision. </p>

</div>
</div>
<a id="a49aed737bf5e84006016a8e863f422cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49aed737bf5e84006016a8e863f422cf">&#9670;&nbsp;</a></span>MaxIntegerValue&lt; mshadow::bfloat::bf16_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="namespacemxnet_1_1common.html#a325e95d176e17c22ea18db6694093ad7">mxnet::common::MaxIntegerValue</a>&lt; mshadow::bfloat::bf16_t &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b5002a24372f2c7325c78a747270cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5002a24372f2c7325c78a747270cf9">&#9670;&nbsp;</a></span>MaxIntegerValue&lt; mshadow::half::half_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="namespacemxnet_1_1common.html#a325e95d176e17c22ea18db6694093ad7">mxnet::common::MaxIntegerValue</a>&lt; mshadow::half::half_t &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8a9546bbfefdbb83d23b9aa1e65778e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a9546bbfefdbb83d23b9aa1e65778e">&#9670;&nbsp;</a></span>mshadow_type_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmxnet_1_1common_1_1MShadowTypeInfo.html">MShadowTypeInfo</a> mxnet::common::mshadow_type_info </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type_flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13c7b64afe7420b04b112f0d7c9f958e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c7b64afe7420b04b112f0d7c9f958e">&#9670;&nbsp;</a></span>NodeAttrsGetProfilerScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string mxnet::common::NodeAttrsGetProfilerScope </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;&#160;</td>
          <td class="paramname"><em>attrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a672cbe8a66412b740b29c6313a39d662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672cbe8a66412b740b29c6313a39d662">&#9670;&nbsp;</a></span>np_binary_out_infer_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mxnet::common::np_binary_out_infer_type </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8873d9dcccfd8e613c1c156934cee98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8873d9dcccfd8e613c1c156934cee98c">&#9670;&nbsp;</a></span>operator_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mxnet::common::operator_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmxnet_1_1OpContext.html">OpContext</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get string representation of the operator </p>

</div>
</div>
<a id="a40770734529b91fe60fa6b3d76043717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40770734529b91fe60fa6b3d76043717">&#9670;&nbsp;</a></span>operator_stype_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mxnet::common::operator_stype_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dev_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_attrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get string representation of the operator stypes </p>

</div>
</div>
<a id="a1e646ace37016aa994a26d96e739a561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e646ace37016aa994a26d96e739a561">&#9670;&nbsp;</a></span>ParallelAccumulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V mxnet::common::ParallelAccumulate </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4809d73b8689e4898d3608b15c877035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4809d73b8689e4898d3608b15c877035">&#9670;&nbsp;</a></span>ParallelAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::ParallelAdd </td>
          <td>(</td>
          <td class="paramtype">DType *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DType *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\breif parallelize add by OpenMP </p>

</div>
</div>
<a id="abc4dccb2b37c896faf7409e002bf4eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4dccb2b37c896faf7409e002bf4eb2">&#9670;&nbsp;</a></span>ParallelCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::ParallelCopy </td>
          <td>(</td>
          <td class="paramtype">DType *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DType *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemxnet.html#abadedc1b42ee3e5b8852e63783b982ef">index_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallelize copy by OpenMP. </p>

</div>
</div>
<a id="af2c7fe2df1babee66696d2b449e2123c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c7fe2df1babee66696d2b449e2123c">&#9670;&nbsp;</a></span>ParallelSort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::ParallelSort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the elements in the range [first, last) into ascending order. The elements are compared using the default &lt; operator. If the length of the range [first, last) is greater than a certain threshold, the range will be recursively divided into two and assign two threads to sort each half range. Ref: <a href="https://github.com/dmlc/difacto/blob/master/src/common/parallel_sort.h">https://github.com/dmlc/difacto/blob/master/src/common/parallel_sort.h</a>. </p>

</div>
</div>
<a id="a1f273651755067ca9b1e6b8063c283b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f273651755067ca9b1e6b8063c283b0">&#9670;&nbsp;</a></span>ParallelSort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::ParallelSort </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the elements in the range [first, last) into the ascending order defined by the comparator comp. If the length of the range [first, last) is greater than a certain threshold, the range will be recursively divided into two and assign two threads to sort each half range. Ref: <a href="https://github.com/dmlc/difacto/blob/master/src/common/parallel_sort.h">https://github.com/dmlc/difacto/blob/master/src/common/parallel_sort.h</a>. </p>

</div>
</div>
<a id="a7343dc26405918db27b8224ce41f05f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7343dc26405918db27b8224ce41f05f6">&#9670;&nbsp;</a></span>ParallelSortHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt , typename Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::ParallelSortHelper </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for ParallelSort. DO NOT call this function directly. Use the interface ParallelSort instead. Ref: <a href="https://github.com/dmlc/difacto/blob/master/src/common/parallel_sort.h">https://github.com/dmlc/difacto/blob/master/src/common/parallel_sort.h</a>. </p>

</div>
</div>
<a id="a02752372972ae43c182e4994df2bddc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02752372972ae43c182e4994df2bddc5">&#9670;&nbsp;</a></span>ReshapeOrCreate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> mxnet::common::ReshapeOrCreate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TShape.html">mxnet::TShape</a> &amp;&#160;</td>
          <td class="paramname"><em>dest_arg_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dest_arg_dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a536b732faa980e1de446c552460ff76a">NDArrayStorageType</a>&#160;</td>
          <td class="paramname"><em>dest_arg_stype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmxnet_1_1Context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; std::string, <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>shared_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_row_sparse_sharing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the requested ndarray's shape size is less than the corresponding shared_data_array's shape size and the storage type is shareable, reuse the memory allocation in shared_buffer; otherwise, create a zero ndarray. Shareable storages include both default storage and row_sparse storage if enable_row_sparse_sharing is <code>True</code>, otherwise default storage only. </p>

</div>
</div>
<a id="a5fbe19a0704b5476faa0f5645ee9ac1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbe19a0704b5476faa0f5645ee9ac1a">&#9670;&nbsp;</a></span>RoundToPower2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t mxnet::common::RoundToPower2 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6369bac95f2e7080088927858937d7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6369bac95f2e7080088927858937d7b0">&#9670;&nbsp;</a></span>SameType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::common::SameType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnnvm_1_1NodeAttrs.html">nnvm::NodeAttrs</a> &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>iattr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>oattr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default type inference function, which assigns all undefined types to the same type of one of the inputs or outputs. </p>

</div>
</div>
<a id="a2262a78f3d80b9adeb3b517246fe4335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2262a78f3d80b9adeb3b517246fe4335">&#9670;&nbsp;</a></span>SetupDefaultBlobsIn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::common::SetupDefaultBlobsIn </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; *&#160;</td>
          <td class="paramname"><em>blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>temp_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>temp_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; uint32_t, uint32_t &gt; *&#160;</td>
          <td class="paramname"><em>idx_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2dc5d03c700c90be66f47c4f46d2ef6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc5d03c700c90be66f47c4f46d2ef6a">&#9670;&nbsp;</a></span>SetupDefaultBlobsInOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::SetupDefaultBlobsInOut </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ndinputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ndoutputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>in_bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>out_bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; *&#160;</td>
          <td class="paramname"><em>input_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; *&#160;</td>
          <td class="paramname"><em>output_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>pre_temp_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>pre_temp_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>post_temp_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>post_temp_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; uint32_t, uint32_t &gt; *&#160;</td>
          <td class="paramname"><em>in_temp_idx_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>mutate_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28bf4d1e9b7392f106950b00de5a2c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28bf4d1e9b7392f106950b00de5a2c62">&#9670;&nbsp;</a></span>SetupDefaultBlobsOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mxnet::common::SetupDefaultBlobsOut </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>bufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a> &gt; *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &gt; *&#160;</td>
          <td class="paramname"><em>blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>temp_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &gt; *&#160;</td>
          <td class="paramname"><em>temp_dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a905e77124ee11208c40a8afd3ee42167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905e77124ee11208c40a8afd3ee42167">&#9670;&nbsp;</a></span>SparseRetainOpForwardRspWrapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename xpu &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mxnet::common::SparseRetainOpForwardRspWrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmshadow_1_1Stream.html">mshadow::Stream</a>&lt; xpu &gt; *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> &amp;&#160;</td>
          <td class="paramname"><em>input_nd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmxnet_1_1TBlob.html">TBlob</a> &amp;&#160;</td>
          <td class="paramname"><em>idx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemxnet.html#a7cd7094ef222e9ae1f520c3b6a214398">OpReqType</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">NDArray</a> *&#160;</td>
          <td class="paramname"><em>output_nd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pick rows specified by user input index array from a row sparse ndarray and save them in the output sparse ndarray. </p>

</div>
</div>
<a id="ab24b30a630e9ebf963f763a99b48ebc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24b30a630e9ebf963f763a99b48ebc5">&#9670;&nbsp;</a></span>storage_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mxnet::common::storage_str </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>storage_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab379cd302d59005010ae29aff6e55009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab379cd302d59005010ae29aff6e55009">&#9670;&nbsp;</a></span>stype_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mxnet::common::stype_string </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get string representation of storage_type </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 1 2021 20:32:50 for mxnet by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
