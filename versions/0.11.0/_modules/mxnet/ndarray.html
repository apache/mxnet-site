<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="mxnet.ndarray" property="og:title">
<meta content="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/og-logo.png" property="og:image">
<meta content="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/og-logo.png" property="og:image:secure_url">
<meta content="mxnet.ndarray" property="og:description"/>
<title>mxnet.ndarray — mxnet  documentation</title>
<link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" rel="stylesheet"/>
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet"/>
<link href="../../_static/basic.css" rel="stylesheet" type="text/css">
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css">
<link href="../../_static/mxnet.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
<script src="https://code.jquery.com/jquery-1.11.1.min.js" type="text/javascript"></script>
<script src="../../_static/underscore.js" type="text/javascript"></script>
<script src="../../_static/searchtools_custom.js" type="text/javascript"></script>
<script src="../../_static/doctools.js" type="text/javascript"></script>
<script src="../../_static/selectlang.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script type="text/javascript"> jQuery(function() { Search.loadIndex("/versions/0.11.0/searchindex.js"); Search.init();}); </script>
<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
      Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-96378503-1', 'auto');
      ga('send', 'pageview');

    </script>
<!-- -->
<!-- <script type="text/javascript" src="../../_static/jquery.js"></script> -->
<!-- -->
<!-- <script type="text/javascript" src="../../_static/underscore.js"></script> -->
<!-- -->
<!-- <script type="text/javascript" src="../../_static/doctools.js"></script> -->
<!-- -->
<!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<!-- -->
<link href="../../genindex.html" rel="index" title="Index">
<link href="../../search.html" rel="search" title="Search"/>
<link href="../index.html" rel="up" title="Module code"/>
<link href="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/mxnet-icon.png" rel="icon" type="image/png"/>
</link></link></link></meta></meta></meta></head>
<body background="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/mxnet-background-compressed.jpeg" role="document">
<div class="content-block"><div class="navbar navbar-fixed-top">
<div class="container" id="navContainer">
<div class="innder" id="header-inner">
<h1 id="logo-wrap">
<a href="../../" id="logo"><img src="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/mxnet_logo.png"/></a>
</h1>
<nav class="nav-bar" id="main-nav">
<a class="main-nav-link" href="/versions/0.11.0/get_started/install.html">Install</a>
<span id="dropdown-menu-position-anchor">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">Gluon <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu">
<li><a class="main-nav-link" href="/versions/0.11.0/tutorials/gluon/gluon.html">About</a></li>
<li><a class="main-nav-link" href="https://www.d2l.ai/">Dive into Deep Learning</a></li>
<li><a class="main-nav-link" href="https://gluon-cv.mxnet.io">GluonCV Toolkit</a></li>
<li><a class="main-nav-link" href="https://gluon-nlp.mxnet.io/">GluonNLP Toolkit</a></li>
</ul>
</span>
<span id="dropdown-menu-position-anchor">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">API <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu">
<li><a class="main-nav-link" href="/versions/0.11.0/api/python/index.html">Python</a></li>
<li><a class="main-nav-link" href="/versions/0.11.0/api/c++/index.html">C++</a></li>
<li><a class="main-nav-link" href="/versions/0.11.0/api/julia/index.html">Julia</a></li>
<li><a class="main-nav-link" href="/versions/0.11.0/api/perl/index.html">Perl</a></li>
<li><a class="main-nav-link" href="/versions/0.11.0/api/r/index.html">R</a></li>
<li><a class="main-nav-link" href="/versions/0.11.0/api/scala/index.html">Scala</a></li>
</ul>
</span>
<span id="dropdown-menu-position-anchor-docs">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">Docs <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu-docs">
<li><a class="main-nav-link" href="/versions/0.11.0/how_to/faq.html">FAQ</a></li>
<li><a class="main-nav-link" href="/versions/0.11.0/tutorials/index.html">Tutorials</a>
<li><a class="main-nav-link" href="https://github.com/apache/incubator-mxnet/tree/v0.11.0/example">Examples</a></li>
<li><a class="main-nav-link" href="/versions/0.11.0/architecture/index.html">Architecture</a></li>
<li><a class="main-nav-link" href="https://cwiki.apache.org/confluence/display/MXNET/Apache+MXNet+Home">Developer Wiki</a></li>
<li><a class="main-nav-link" href="/versions/0.11.0/model_zoo/index.html">Model Zoo</a></li>
<li><a class="main-nav-link" href="https://github.com/onnx/onnx-mxnet">ONNX</a></li>
</li></ul>
</span>
<span id="dropdown-menu-position-anchor-community">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">Community <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu-community">
<li><a class="main-nav-link" href="http://discuss.mxnet.io">Forum</a></li>
<li><a class="main-nav-link" href="https://github.com/apache/incubator-mxnet/tree/v0.11.0">Github</a></li>
<li><a class="main-nav-link" href="/versions/0.11.0/community/contribute.html">Contribute</a></li>
</ul>
</span>
<span id="dropdown-menu-position-anchor-version" style="position: relative"><a href="#" class="main-nav-link dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="true">0.11.0<span class="caret"></span></a><ul id="package-dropdown-menu" class="dropdown-menu"><li><a href="/">master</a></li><li><a href="/versions/1.7.0/">1.7.0</a></li><li><a href=/versions/1.6.0/>1.6.0</a></li><li><a href=/versions/1.5.0/>1.5.0</a></li><li><a href=/versions/1.4.1/>1.4.1</a></li><li><a href=/versions/1.3.1/>1.3.1</a></li><li><a href=/versions/1.2.1/>1.2.1</a></li><li><a href=/versions/1.1.0/>1.1.0</a></li><li><a href=/versions/1.0.0/>1.0.0</a></li><li><a href=/versions/0.12.1/>0.12.1</a></li><li><a href=/versions/0.11.0/>0.11.0</a></li></ul></span></nav>
<script> function getRootPath(){ return "../../" } </script>
<div class="burgerIcon dropdown">
<a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button">☰</a>
<ul class="dropdown-menu" id="burgerMenu">
<li><a href="/versions/0.11.0/get_started/install.html">Install</a></li>
<li><a class="main-nav-link" href="/versions/0.11.0/tutorials/index.html">Tutorials</a></li>
<li class="dropdown-submenu dropdown">
<a aria-expanded="true" aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" tabindex="-1">Gluon</a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu">
<li><a class="main-nav-link" href="/versions/0.11.0/tutorials/gluon/gluon.html">About</a></li>
<li><a class="main-nav-link" href="http://gluon.mxnet.io">The Straight Dope (Tutorials)</a></li>
<li><a class="main-nav-link" href="https://gluon-cv.mxnet.io">GluonCV Toolkit</a></li>
<li><a class="main-nav-link" href="https://gluon-nlp.mxnet.io/">GluonNLP Toolkit</a></li>
</ul>
</li>
<li class="dropdown-submenu">
<a aria-expanded="true" aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" tabindex="-1">API</a>
<ul class="dropdown-menu">
<li><a class="main-nav-link" href="/versions/0.11.0/api/python/index.html">Python</a></li>
<li><a class="main-nav-link" href="/versions/0.11.0/api/c++/index.html">C++</a></li>
<li><a class="main-nav-link" href="/versions/0.11.0/api/julia/index.html">Julia</a></li>
<li><a class="main-nav-link" href="/versions/0.11.0/api/perl/index.html">Perl</a></li>
<li><a class="main-nav-link" href="/versions/0.11.0/api/r/index.html">R</a></li>
<li><a class="main-nav-link" href="/versions/0.11.0/api/scala/index.html">Scala</a></li>
</ul>
</li>
<li class="dropdown-submenu">
<a aria-expanded="true" aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" tabindex="-1">Docs</a>
<ul class="dropdown-menu">
<li><a href="/versions/0.11.0/how_to/faq.html" tabindex="-1">FAQ</a></li>
<li><a href="/versions/0.11.0/tutorials/index.html" tabindex="-1">Tutorials</a></li>
<li><a href="https://github.com/apache/incubator-mxnet/tree/v0.11.0/example" tabindex="-1">Examples</a></li>
<li><a href="/versions/0.11.0/architecture/index.html" tabindex="-1">Architecture</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/MXNET/Apache+MXNet+Home" tabindex="-1">Developer Wiki</a></li>
<li><a href="/versions/0.11.0/model_zoo/index.html" tabindex="-1">Gluon Model Zoo</a></li>
<li><a href="https://github.com/onnx/onnx-mxnet" tabindex="-1">ONNX</a></li>
</ul>
</li>
<li class="dropdown-submenu dropdown">
<a aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" role="button" tabindex="-1">Community</a>
<ul class="dropdown-menu">
<li><a href="http://discuss.mxnet.io" tabindex="-1">Forum</a></li>
<li><a href="https://github.com/apache/incubator-mxnet/tree/v0.11.0" tabindex="-1">Github</a></li>
<li><a href="/versions/0.11.0/community/contribute.html" tabindex="-1">Contribute</a></li>
</ul>
</li>
<li id="dropdown-menu-position-anchor-version-mobile" class="dropdown-submenu" style="position: relative"><a href="#" tabindex="-1">0.11.0</a><ul class="dropdown-menu"><li><a tabindex="-1" href=/>master</a></li><li><a tabindex="-1" href=/versions/1.6.0/>1.6.0</a></li><li><a tabindex="-1" href=/versions/1.5.0/>1.5.0</a></li><li><a tabindex="-1" href=/versions/1.4.1/>1.4.1</a></li><li><a tabindex="-1" href=/versions/1.3.1/>1.3.1</a></li><li><a tabindex="-1" href=/versions/1.2.1/>1.2.1</a></li><li><a tabindex="-1" href=/versions/1.1.0/>1.1.0</a></li><li><a tabindex="-1" href=/versions/1.0.0/>1.0.0</a></li><li><a tabindex="-1" href=/versions/0.12.1/>0.12.1</a></li><li><a tabindex="-1" href=/versions/0.11.0/>0.11.0</a></li></ul></li></ul>
</div>
<div class="plusIcon dropdown">
<a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button"><span aria-hidden="true" class="glyphicon glyphicon-plus"></span></a>
<ul class="dropdown-menu dropdown-menu-right" id="plusMenu"></ul>
</div>
<div id="search-input-wrap">
<form action="../../search.html" autocomplete="off" class="" method="get" role="search">
<div class="form-group inner-addon left-addon">
<i class="glyphicon glyphicon-search"></i>
<input class="form-control" name="q" placeholder="Search" type="text"/>
</div>
<input name="check_keywords" type="hidden" value="yes">
<input name="area" type="hidden" value="default"/>
</input></form>
<div id="search-preview"></div>
</div>
<div id="searchIcon">
<span aria-hidden="true" class="glyphicon glyphicon-search"></span>
</div>
<!-- <div id="lang-select-wrap"> -->
<!--   <label id="lang-select-label"> -->
<!--     <\!-- <i class="fa fa-globe"></i> -\-> -->
<!--     <span></span> -->
<!--   </label> -->
<!--   <select id="lang-select"> -->
<!--     <option value="en">Eng</option> -->
<!--     <option value="zh">中文</option> -->
<!--   </select> -->
<!-- </div> -->
<!--     <a id="mobile-nav-toggle">
        <span class="mobile-nav-toggle-bar"></span>
        <span class="mobile-nav-toggle-bar"></span>
        <span class="mobile-nav-toggle-bar"></span>
      </a> -->
</div>
</div>
</div>
<script type="text/javascript">
        $('body').css('background', 'white');
    </script>
<div class="container">
<div class="row">
<div aria-label="main navigation" class="sphinxsidebar leftsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/python/index.html">Python Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/r/index.html">R Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/julia/index.html">Julia Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/c++/index.html">C++ Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/scala/index.html">Scala Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/perl/index.html">Perl Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../how_to/index.html">HowTo Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../architecture/index.html">System Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a></li>
</ul>
</div>
</div>
<div class="content">
<div class="page-tracker"></div>
<h1>Source code for mxnet.ndarray</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed to the Apache Software Foundation (ASF) under one</span>
<span class="c1"># or more contributor license agreements.  See the NOTICE file</span>
<span class="c1"># distributed with this work for additional information</span>
<span class="c1"># regarding copyright ownership.  The ASF licenses this file</span>
<span class="c1"># to you under the Apache License, Version 2.0 (the</span>
<span class="c1"># "License"); you may not use this file except in compliance</span>
<span class="c1"># with the License.  You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing,</span>
<span class="c1"># software distributed under the License is distributed on an</span>
<span class="c1"># "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span>
<span class="c1"># KIND, either express or implied.  See the License for the</span>
<span class="c1"># specific language governing permissions and limitations</span>
<span class="c1"># under the License.</span>

<span class="c1"># coding: utf-8</span>
<span class="c1"># pylint: disable= too-many-lines, redefined-builtin, protected-access</span>
<span class="c1"># pylint: disable=import-error, no-name-in-module, undefined-variable</span>
<span class="sd">"""NDArray API of MXNet."""</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">__builtin__</span> <span class="k">import</span> <span class="nb">slice</span> <span class="k">as</span> <span class="n">py_slice</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">slice</span> <span class="k">as</span> <span class="n">py_slice</span>

<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">os</span> <span class="k">as</span> <span class="nn">_os</span>
<span class="kn">import</span> <span class="nn">sys</span> <span class="k">as</span> <span class="nn">_sys</span>

<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">_LIB</span><span class="p">,</span> <span class="n">string_types</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">,</span> <span class="n">integer_types</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">c_array</span><span class="p">,</span> <span class="n">py_str</span><span class="p">,</span> <span class="n">c_str</span><span class="p">,</span> <span class="n">mx_real_t</span><span class="p">,</span> <span class="n">_Null</span>  <span class="c1"># pylint: disable=unused-import</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">mx_uint</span><span class="p">,</span> <span class="n">NDArrayHandle</span><span class="p">,</span> <span class="n">check_call</span><span class="p">,</span> <span class="n">OpHandle</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="n">ctypes2buffer</span>
<span class="kn">from</span> <span class="nn">.context</span> <span class="k">import</span> <span class="n">Context</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_ndarray_internal</span> <span class="k">as</span> <span class="n">_internal</span>
<span class="kn">from</span> <span class="nn">.ndarray_doc</span> <span class="k">import</span> <span class="n">_build_doc</span>


<span class="c1"># Use different version of SymbolBase</span>
<span class="c1"># When possible, use cython to speedup part of computation.</span>
<span class="c1"># pylint: disable=unused-import</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">_os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"MXNET_ENABLE_CYTHON"</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">._ctypes.ndarray</span> <span class="k">import</span> <span class="n">NDArrayBase</span><span class="p">,</span> <span class="n">_set_ndarray_class</span>
        <span class="kn">from</span> <span class="nn">._ctypes.ndarray</span> <span class="k">import</span> <span class="n">CachedOp</span><span class="p">,</span> <span class="n">_imperative_invoke</span>
    <span class="k">elif</span> <span class="n">_sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">>=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">._cy3.ndarray</span> <span class="k">import</span> <span class="n">NDArrayBase</span><span class="p">,</span> <span class="n">_set_ndarray_class</span><span class="p">,</span> <span class="n">_imperative_invoke</span>
        <span class="kn">from</span> <span class="nn">._cy3.ndarray</span> <span class="k">import</span> <span class="n">CachedOp</span><span class="p">,</span> <span class="n">_imperative_invoke</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">._cy2.ndarray</span> <span class="k">import</span> <span class="n">NDArrayBase</span><span class="p">,</span> <span class="n">_set_ndarray_class</span><span class="p">,</span> <span class="n">_imperative_invoke</span>
        <span class="kn">from</span> <span class="nn">._cy2.ndarray</span> <span class="k">import</span> <span class="n">CachedOp</span><span class="p">,</span> <span class="n">_imperative_invoke</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">_os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"MXNET_ENFORCE_CYTHON"</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">"Cython Module cannot be loaded but MXNET_ENFORCE_CYTHON=1"</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">._ctypes.ndarray</span> <span class="k">import</span> <span class="n">NDArrayBase</span><span class="p">,</span> <span class="n">_set_ndarray_class</span><span class="p">,</span> <span class="n">_imperative_invoke</span>
    <span class="kn">from</span> <span class="nn">._ctypes.ndarray</span> <span class="k">import</span> <span class="n">CachedOp</span><span class="p">,</span> <span class="n">_imperative_invoke</span>
<span class="c1"># pylint: enable=unused-import</span>

<span class="c1"># pylint: disable= no-member</span>
<span class="n">_DTYPE_NP_TO_MX</span> <span class="o">=</span> <span class="p">{</span>
    <span class="kc">None</span>       <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">float32</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">float16</span> <span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">uint8</span>   <span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">int32</span>   <span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">int8</span>    <span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">np</span><span class="o">.</span><span class="n">int64</span>   <span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">_DTYPE_MX_TO_NP</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="mi">0</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
    <span class="mi">1</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="mi">2</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span>
    <span class="mi">3</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
    <span class="mi">4</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
    <span class="mi">5</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span>
    <span class="mi">6</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">_GRAD_REQ_MAP</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">'null'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="s1">'write'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s1">'add'</span><span class="p">:</span> <span class="mi">3</span>
<span class="p">}</span>
<span class="c1"># pylint: enable= no-member</span>

<span class="k">def</span> <span class="nf">_new_empty_handle</span><span class="p">():</span>
    <span class="sd">"""Returns a new empty handle.</span>

<span class="sd">    Empty handle can be used to hold a result.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    handle</span>
<span class="sd">        A new empty `NDArray` handle.</span>
<span class="sd">    """</span>
    <span class="n">hdl</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>
    <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayCreateNone</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hdl</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">hdl</span>

<span class="k">def</span> <span class="nf">_new_alloc_handle</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">delay_alloc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mx_real_t</span><span class="p">):</span>
    <span class="sd">"""Return a new handle with specified shape and context.</span>

<span class="sd">    Empty handle is only used to hold results.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    handle</span>
<span class="sd">        A new empty `NDArray` handle.</span>
<span class="sd">    """</span>
    <span class="n">hdl</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>
    <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayCreateEx</span><span class="p">(</span>
        <span class="n">c_array</span><span class="p">(</span><span class="n">mx_uint</span><span class="p">,</span> <span class="n">shape</span><span class="p">),</span>
        <span class="n">mx_uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">device_typeid</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">device_id</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">delay_alloc</span><span class="p">)),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">_DTYPE_NP_TO_MX</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">])),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hdl</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">hdl</span>

<div class="viewcode-block" id="waitall"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.waitall">[docs]</a><span class="k">def</span> <span class="nf">waitall</span><span class="p">():</span>
    <span class="sd">"""Wait for all async operations to finish in MXNet.</span>

<span class="sd">    This function is used for benchmarking only.</span>
<span class="sd">    """</span>
    <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayWaitAll</span><span class="p">())</span></div>

<div class="viewcode-block" id="NDArray"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.NDArray">[docs]</a><span class="k">class</span> <span class="nc">NDArray</span><span class="p">(</span><span class="n">NDArrayBase</span><span class="p">):</span>
    <span class="sd">"""An array object representing a multidimensional, homogeneous array of</span>
<span class="sd">fixed-size items.</span>

<span class="sd">    """</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># make numpy functions return NDArray instead of numpy object array</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mf">1000.0</span>
    <span class="c1"># pylint: disable= no-member, undefined-variable</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns a string representation of the array."""</span>
        <span class="n">shape_info</span> <span class="o">=</span> <span class="s1">'x'</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">'</span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">])</span>
        <span class="k">return</span> <span class="s1">'</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s1"><</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> @</span><span class="si">%s</span><span class="s1">>'</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()),</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                      <span class="n">shape_info</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__add__(y) <=> x+y <=> mx.nd.add(x, y) """</span>
        <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__iadd__(y) <=> x+=y """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'trying to add to a readonly NDArray'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">broadcast_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_plus_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'type </span><span class="si">%s</span><span class="s1"> not supported'</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__sub__(y) <=> x-y <=> mx.nd.subtract(x, y) """</span>
        <span class="k">return</span> <span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__isub__(y) <=> x-=y """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'trying to subtract from a readonly NDArray'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">broadcast_sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_minus_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'type </span><span class="si">%s</span><span class="s1"> not supported'</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__rsub__(y) <=> y-x <=> mx.nd.subtract(y, x) """</span>
        <span class="k">return</span> <span class="n">subtract</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__mul__(y) <=> x*y <=> mx.nd.multiply(x, y) """</span>
        <span class="k">return</span> <span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""x.__neg__(y) <=> -x """</span>
        <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_mul_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__imul__(y) <=> x*=y """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'trying to multiply to a readonly NDArray'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">broadcast_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_mul_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'type </span><span class="si">%s</span><span class="s1"> not supported'</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__div__(y) <=> x/y <=> mx.nd.divide(x, y) """</span>
        <span class="k">return</span> <span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__rdiv__(y) <=> y/x <=> mx.nd.divide(y, x) """</span>
        <span class="k">return</span> <span class="n">divide</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__idiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__rdiv__(y) <=> x/=y """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'trying to divide from a readonly NDArray'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">broadcast_div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_div_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'type </span><span class="si">%s</span><span class="s1"> not supported'</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">divide</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__idiv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__mod__(y) <=> x%y <=> mx.nd.modulo(x, y) """</span>
        <span class="k">return</span> <span class="n">modulo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__rmod__(y) <=> y%x <=> mx.nd.modulo(y, x) """</span>
        <span class="k">return</span> <span class="n">modulo</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__imod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__rmod__(y) <=> x%=y """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'trying to take modulo from a readonly NDArray'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">broadcast_mod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_mod_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'type </span><span class="si">%s</span><span class="s1"> not supported'</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__pow__(y) <=> x**y <=> mx.nd.power(x,y) """</span>
        <span class="k">return</span> <span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__pow__(y) <=> y**x <=> mx.nd.power(y,x) """</span>
        <span class="k">return</span> <span class="n">power</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__eq__(y) <=> x==y <=> mx.nd.equal(x, y) """</span>
        <span class="k">return</span> <span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__ne__(y) <=> x!=y <=> mx.nd.not_equal(x, y) """</span>
        <span class="k">return</span> <span class="n">not_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__gt__(y) <=> x>y <=> mx.nd.greater(x, y) """</span>
        <span class="k">return</span> <span class="n">greater</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__ge__(y) <=> x>=y <=> mx.nd.greater_equal(x, y) """</span>
        <span class="k">return</span> <span class="n">greater_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__lt__(y) <=> x<y <=> mx.nd.lesser(x, y) """</span>
        <span class="k">return</span> <span class="n">lesser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""x.__le__(y) <=> x<=y <=> mx.nd.less_equal(x, y) """</span>
        <span class="k">return</span> <span class="n">lesser_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"The truth value of an NDArray is ambiguous. "</span> \
                         <span class="s2">"Please convert to number with asscalar() first."</span><span class="p">)</span>

    <span class="n">__nonzero__</span> <span class="o">=</span> <span class="fm">__bool__</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Number of element along the first axis."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle</span>
        <span class="n">this</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'handle'</span> <span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">handle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">()</span>
            <span class="n">cptr</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char</span><span class="p">)()</span>
            <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArraySaveRawBytes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">length</span><span class="p">),</span>
                                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">cptr</span><span class="p">)))</span>
            <span class="n">this</span><span class="p">[</span><span class="s1">'handle'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctypes2buffer</span><span class="p">(</span><span class="n">cptr</span><span class="p">,</span> <span class="n">length</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">this</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># pylint: disable=assigning-non-slot</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">'handle'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">handle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">handle</span>
            <span class="n">handle</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span><span class="o">.</span><span class="n">from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span>
            <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayLoadFromRawBytes</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">handle</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span> <span class="o">=</span> <span class="n">handle</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">"""x.__setitem__(i, y) <=> x[i]=y</span>

<span class="sd">        Set self[key] to value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : int, slice or tuple</span>
<span class="sd">            The indexing key.</span>
<span class="sd">        value : scalar, NDArray or numpy.ndarray</span>
<span class="sd">            The value to set.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.zeros((2,3))</span>
<span class="sd">        >>> x[:] = 1</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 1.,  1.,  1.],</span>
<span class="sd">               [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 1.,  1.,  1.],</span>
<span class="sd">               [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">        >>> x[:,1:2] = 2</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 1.,  2.,  1.],</span>
<span class="sd">               [ 1.,  2.,  1.]], dtype=float32)</span>
<span class="sd">        >>> x[1:2,1:] = 3</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 1.,  2.,  1.],</span>
<span class="sd">               [ 1.,  3.,  3.]], dtype=float32)</span>
<span class="sd">        >>> x[1:,0:2] = mx.nd.zeros((1,2))</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 1.,  2.,  1.],</span>
<span class="sd">               [ 0.,  0.,  3.]], dtype=float32)</span>
<span class="sd">        >>> x[1,2] = 4</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 1.,  2.,  1.],</span>
<span class="sd">               [ 0.,  0.,  4.]], dtype=float32)</span>
<span class="sd">        """</span>
        <span class="c1"># pylint: disable=too-many-branches</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot assign to readonly NDArray'</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
            <span class="n">sliced_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">sliced_arr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">py_slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'NDArray only supports slicing with step size 1'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sliced_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
                <span class="n">sliced_arr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">handle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">:</span>
                    <span class="n">value</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
                <span class="n">_internal</span><span class="o">.</span><span class="n">_set_value</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">generic</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sync_copyfrom</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">'NDArray does not support assignment with </span><span class="si">%s</span><span class="s1"> of type </span><span class="si">%s</span><span class="s1">'</span><span class="o">%</span><span class="p">(</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># multi-dimension indexing</span>
            <span class="n">my_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o"><=</span> <span class="nb">len</span><span class="p">(</span><span class="n">my_shape</span><span class="p">),</span> \
                <span class="s2">"Indexing dimensions exceed array dimensions, </span><span class="si">%d</span><span class="s2"> vs </span><span class="si">%d</span><span class="s2">"</span><span class="o">%</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">my_shape</span><span class="p">))</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">my_shape</span><span class="p">]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">my_shape</span><span class="p">]</span>
            <span class="n">expand</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slice_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slice_i</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="n">slice_i</span> <span class="o"><</span> <span class="n">my_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">begin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">slice_i</span>
                    <span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">slice_i</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">expand</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slice_i</span><span class="p">,</span> <span class="n">py_slice</span><span class="p">):</span>
                    <span class="c1"># only support continuous slicing</span>
                    <span class="k">assert</span> <span class="n">slice_i</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> \
                        <span class="s2">"NDArray only supports slicing with step size 1."</span>
                    <span class="n">begin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">slice_i</span><span class="o">.</span><span class="n">start</span> <span class="ow">or</span> <span class="mi">0</span>
                    <span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">slice_i</span><span class="o">.</span><span class="n">stop</span> <span class="ow">or</span> <span class="n">my_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="n">begin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o"><</span> <span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o"><=</span> <span class="n">my_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">"NDArray does not support slicing with key </span><span class="si">%s</span><span class="s2"> of type </span><span class="si">%s</span><span class="s2">."</span><span class="o">%</span><span class="p">(</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">slice_i</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">slice_i</span><span class="p">))))</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">as_in_context</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_slice_assign</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">expand</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
                <span class="n">_internal</span><span class="o">.</span><span class="n">_crop_assign_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                              <span class="n">begin</span><span class="o">=</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
                                              <span class="n">scalar</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">generic</span><span class="p">)):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_slice_assign</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">expand</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">'NDArray does not support assignment with </span><span class="si">%s</span><span class="s1"> of type </span><span class="si">%s</span><span class="s1">'</span><span class="o">%</span><span class="p">(</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"NDArray does not support slicing with key </span><span class="si">%s</span><span class="s2"> of type </span><span class="si">%s</span><span class="s2">."</span><span class="o">%</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">))))</span>
        <span class="c1"># pylint: enable=too-many-branches</span>

    <span class="k">def</span> <span class="nf">_slice_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">expand</span><span class="p">):</span>
        <span class="n">vshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expand</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">vshape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">begin</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expand</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">vshape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">begin</span><span class="p">):</span>
                <span class="n">sshape</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="o">-</span> <span class="n">b</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">begin</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">expand</span><span class="p">):</span>
                    <span class="n">sshape</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">"Cannot assign NDArray with shape </span><span class="si">%s</span><span class="s2"> to NDArray slice with "</span> \
                    <span class="s2">"shape </span><span class="si">%s</span><span class="s2">"</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">vshape</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">sshape</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expand</span><span class="p">:</span>
                <span class="n">vshape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vshape</span><span class="p">)</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_crop_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">begin</span><span class="o">=</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">"""x.__getitem__(i) <=> x[i]</span>

<span class="sd">        Returns a sliced view of this array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : int or slice</span>
<span class="sd">            Indexing key.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.arange(0,6).reshape((2,3))</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 0.,  1.,  2.],</span>
<span class="sd">               [ 3.,  4.,  5.]], dtype=float32)</span>
<span class="sd">        >>> x[1].asnumpy()</span>
<span class="sd">        array([ 3.,  4.,  5.], dtype=float32)</span>
<span class="sd">        >>> y = x[0:1]</span>
<span class="sd">        >>> y[:] = 2</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 2.,  2.,  2.],</span>
<span class="sd">               [ 3.,  4.,  5.]], dtype=float32)</span>
<span class="sd">        """</span>
        <span class="c1"># multi-dimensional slicing is not supported yet</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">></span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="s1">'index </span><span class="si">{}</span><span class="s1"> is out of bounds for axis 0 with size </span><span class="si">{}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_at</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">py_slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"NDArray only supports slicing with step size 1."</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">oshape</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">end</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">>=</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> \
                <span class="s2">"Slicing dimensions exceeds array dimensions, </span><span class="si">%d</span><span class="s2"> vs </span><span class="si">%d</span><span class="s2">"</span><span class="o">%</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
            <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slice_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slice_i</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
                    <span class="n">begin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_i</span><span class="p">)</span>
                    <span class="n">end</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slice_i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slice_i</span><span class="p">,</span> <span class="n">py_slice</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">slice_i</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"NDArray only supports slicing with step size 1."</span><span class="p">)</span>
                    <span class="n">begin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">slice_i</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">slice_i</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
                    <span class="n">end</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">slice_i</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">slice_i</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
                    <span class="n">oshape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">begin</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">"NDArray does not support slicing with key </span><span class="si">%s</span><span class="s2"> of type </span><span class="si">%s</span><span class="s2">."</span><span class="o">%</span><span class="p">(</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">slice_i</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">slice_i</span><span class="p">))))</span>
            <span class="n">oshape</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">oshape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">oshape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">oshape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">"NDArray does not support slicing with key </span><span class="si">%s</span><span class="s2"> of type </span><span class="si">%s</span><span class="s2">."</span><span class="o">%</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">))))</span>

    <span class="k">def</span> <span class="nf">_sync_copyfrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_array</span><span class="p">):</span>
        <span class="sd">"""Performs a synchronized copy from the `source_array` to the current array.</span>
<span class="sd">        This is called through ``x[:] = source_array``, where the `source_array`</span>
<span class="sd">        is a `numpy.ndarray` or array-like object.</span>
<span class="sd">        This function blocks until all the pending read/write operations with respect</span>
<span class="sd">        to the current `NDArray` are finished and carry out the copy operation to the</span>
<span class="sd">        current NDArray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_array : array_like</span>
<span class="sd">            The data source we would like to copy from.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        >>> a = mx.nd.array([1, 2])</span>
<span class="sd">        >>> a.asnumpy()</span>
<span class="sd">        array([ 1.,  2.], dtype=float32)</span>
<span class="sd">        >>> a[:] = np.array([3, 4])</span>
<span class="sd">        >> a.asnumpy()</span>
<span class="sd">        array([ 3.,  4.], dtype=float32)</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">source_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'array must consist of array-like data,'</span> <span class="o">+</span>
                                <span class="s1">'type </span><span class="si">%s</span><span class="s1"> is not supported'</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">array</span><span class="p">)))</span>
        <span class="n">source_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">source_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Shape inconsistent: expected </span><span class="si">%s</span><span class="s1"> vs got </span><span class="si">%s</span><span class="s1">'</span><span class="o">%</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">source_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArraySyncCopyFromCPU</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span>
            <span class="n">source_array</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">(</span><span class="n">source_array</span><span class="o">.</span><span class="n">size</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
        <span class="sd">"""Returns a sliced NDArray that shares memory with the current one.</span>
<span class="sd">        This is called through ``x[start:stop]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int</span>
<span class="sd">            Starting inclusive index of slice in the first dim.</span>
<span class="sd">        stop : int</span>
<span class="sd">            Finishing exclusive index of slice in the first dim.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            `NDArray` sharing the memory with the current one sliced from</span>
<span class="sd">            start to stop in the first dim.</span>

<span class="sd">        Examples:</span>
<span class="sd">        >>> a = mx.nd.array([[1,2], [3, 4], [5, 6], [7, 8]])</span>
<span class="sd">        >>> a[1:2].asnumpy()</span>
<span class="sd">        array([[ 3.,  4.]], dtype=float32)</span>
<span class="sd">        >>> a[1:1].asnumpy()</span>
<span class="sd">        array([], shape=(0, 2), dtype=float32)</span>
<span class="sd">        """</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">mx_uint</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="k">if</span> <span class="n">start</span> <span class="k">else</span> <span class="n">mx_uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">mx_uint</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span> <span class="k">if</span> <span class="n">stop</span> <span class="k">else</span> <span class="n">mx_uint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArraySlice</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">handle</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">handle</span><span class="o">=</span><span class="n">handle</span><span class="p">,</span> <span class="n">writable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">"""Returns a view of the array sliced at `idx` in the first dim.</span>
<span class="sd">        This is called through ``x[idx]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        idx : int</span>
<span class="sd">            index for slicing the `NDArray` in the first dim.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray</span>
<span class="sd">            `NDArray` sharing the memory with the current one sliced at `idx` in the first dim.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> a = mx.nd.array([[1,2], [3, 4]])</span>
<span class="sd">        >>> a[1].asnumpy()</span>
<span class="sd">        array([ 3.,  4.], dtype=float32)</span>
<span class="sd">        >>> b = mx.nd.array([1, 2, 3, 4])</span>
<span class="sd">        >>> b[0].asnumpy()</span>
<span class="sd">        array([ 1.], dtype=float32)</span>
<span class="sd">        """</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">mx_uint</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayAt</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">handle</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">handle</span><span class="o">=</span><span class="n">handle</span><span class="p">,</span> <span class="n">writable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">)</span>

<div class="viewcode-block" id="NDArray.reshape"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.NDArray.reshape">[docs]</a>    <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="sd">"""Returns a **view** of this array with a new shape without altering any data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : tuple of int</span>
<span class="sd">            The new shape should not change the array size, namely</span>
<span class="sd">            ``np.prod(new_shape)`` should be equal to ``np.prod(self.shape)``.</span>

<span class="sd">            One dimension can be -1. In this case, the value is inferred</span>
<span class="sd">            from the length of the array and remaining dimensions.</span>

<span class="sd">            0 Dimensions in shape will be copied from original shape, i.e.</span>
<span class="sd">            if x.shape == (3, 4, 5), x.reshape((0, 20)).shape will be (3, 20).</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray</span>
<span class="sd">            An array with desired shape that shares data with this array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.arange(0,6).reshape((2,3))</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 0.,  1.,  2.],</span>
<span class="sd">               [ 3.,  4.,  5.]], dtype=float32)</span>
<span class="sd">        >>> y = x.reshape((3,2))</span>
<span class="sd">        >>> y.asnumpy()</span>
<span class="sd">        array([[ 0.,  1.],</span>
<span class="sd">               [ 2.,  3.],</span>
<span class="sd">               [ 4.,  5.]], dtype=float32)</span>
<span class="sd">        >>> y = x.reshape((3,-1))</span>
<span class="sd">        >>> y.asnumpy()</span>
<span class="sd">        array([[ 0.,  1.],</span>
<span class="sd">               [ 2.,  3.],</span>
<span class="sd">               [ 4.,  5.]], dtype=float32)</span>
<span class="sd">        >>> y[:] = -1</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[-1., -1., -1.],</span>
<span class="sd">               [-1., -1., -1.]], dtype=float32)</span>
<span class="sd">        """</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>

        <span class="c1"># Actual reshape</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayReshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span>
                                         <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span>
                                         <span class="n">c_array</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">,</span> <span class="n">shape</span><span class="p">),</span>
                                         <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">handle</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">handle</span><span class="o">=</span><span class="n">handle</span><span class="p">,</span> <span class="n">writable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">)</span></div>

    <span class="c1"># pylint: disable= undefined-variable</span>
<div class="viewcode-block" id="NDArray.broadcast_to"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.NDArray.broadcast_to">[docs]</a>    <span class="k">def</span> <span class="nf">broadcast_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="sd">"""Broadcasts the input array to a new shape.</span>

<span class="sd">        Broadcasting is only allowed on axes with size 1. The new shape cannot change</span>
<span class="sd">        the number of dimensions.</span>
<span class="sd">        For example, you could broadcast from shape (2, 1) to (2, 3), but not from</span>
<span class="sd">        shape (2, 3) to (2, 3, 3).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : tuple of int</span>
<span class="sd">            The shape of the desired array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray</span>
<span class="sd">            A NDArray with the desired shape that is not sharing data with this</span>
<span class="sd">            array, even if the new shape is the same as ``self.shape``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.arange(0,3).reshape((1,3,1))</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[[ 0.],</span>
<span class="sd">                [ 1.],</span>
<span class="sd">                [ 2.]]], dtype=float32)</span>
<span class="sd">        >>> y = x.broadcast_to((2,3,3))</span>
<span class="sd">        >>> y.asnumpy()</span>
<span class="sd">        array([[[ 0.,  0.,  0.],</span>
<span class="sd">                [ 1.,  1.,  1.],</span>
<span class="sd">                [ 2.,  2.,  2.]],</span>
<span class="sd">        <BLANKLINE></span>
<span class="sd">               [[ 0.,  0.,  0.],</span>
<span class="sd">                [ 1.,  1.,  1.],</span>
<span class="sd">                [ 2.,  2.,  2.]]], dtype=float32)</span>
<span class="sd">        """</span>
        <span class="n">cur_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">err_str</span> <span class="o">=</span> <span class="s1">'operands could not be broadcast together with remapped shapes'</span> \
                  <span class="s1">'[original->remapped]: </span><span class="si">{}</span><span class="s1"> and requested shape </span><span class="si">{}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cur_shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o"><</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
        <span class="n">cur_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_shape</span><span class="p">))</span> <span class="o">+</span> <span class="n">cur_shape</span>
        <span class="n">cur_shape_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cur_shape</span><span class="p">)</span>
        <span class="n">broadcasting_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">cur_shape_arr</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cur_shape_arr</span><span class="p">[</span><span class="n">broadcasting_axes</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cur_shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">cur_shape</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span></div>
    <span class="c1"># pylint: enable= undefined-variable</span>

<div class="viewcode-block" id="NDArray.wait_to_read"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.NDArray.wait_to_read">[docs]</a>    <span class="k">def</span> <span class="nf">wait_to_read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Waits until all previous write operations on the current array are finished.</span>

<span class="sd">        This method guarantees that all previous write operations that pushed</span>
<span class="sd">        into the backend engine for execution are actually finished.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> import time</span>
<span class="sd">        >>> tic = time.time()</span>
<span class="sd">        >>> a = mx.nd.ones((1000,1000))</span>
<span class="sd">        >>> b = mx.nd.dot(a, a)</span>
<span class="sd">        >>> print(time.time() - tic) # doctest: +SKIP</span>
<span class="sd">        0.003854036331176758</span>
<span class="sd">        >>> b.wait_to_read()</span>
<span class="sd">        >>> print(time.time() - tic) # doctest: +SKIP</span>
<span class="sd">        0.0893700122833252</span>
<span class="sd">        """</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayWaitToRead</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns the number of dimensions of this array</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.array([1, 2, 3, 4])</span>
<span class="sd">        >>> x.ndim</span>
<span class="sd">        1</span>
<span class="sd">        >>> x = mx.nd.array([[1, 2], [3, 4]])</span>
<span class="sd">        >>> x.ndim</span>
<span class="sd">        2</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Tuple of array dimensions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.array([1, 2, 3, 4])</span>
<span class="sd">        >>> x.shape</span>
<span class="sd">        (4L,)</span>
<span class="sd">        >>> y = mx.nd.zeros((2, 3, 4))</span>
<span class="sd">        >>> y.shape</span>
<span class="sd">        (2L, 3L, 4L)</span>
<span class="sd">        """</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">mx_uint</span><span class="p">()</span>
        <span class="n">pdata</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">mx_uint</span><span class="p">)()</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayGetShape</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">ndim</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">pdata</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pdata</span><span class="p">[:</span><span class="n">ndim</span><span class="o">.</span><span class="n">value</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Number of elements in the array.</span>

<span class="sd">        Equivalent to the product of the array's dimensions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> import numpy as np</span>
<span class="sd">        >>> x = mx.nd.zeros((3, 5, 2))</span>
<span class="sd">        >>> x.size</span>
<span class="sd">        30</span>
<span class="sd">        >>> np.prod(x.shape)</span>
<span class="sd">        30</span>
<span class="sd">        """</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">context</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Device context of the array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.array([1, 2, 3, 4])</span>
<span class="sd">        >>> x.context</span>
<span class="sd">        cpu(0)</span>
<span class="sd">        >>> type(x.context)</span>
<span class="sd">        <class 'mxnet.context.Context'></span>
<span class="sd">        >>> y = mx.nd.zeros((2,3), mx.gpu(0))</span>
<span class="sd">        >>> y.context</span>
<span class="sd">        gpu(0)</span>
<span class="sd">        """</span>
        <span class="n">dev_typeid</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">()</span>
        <span class="n">dev_id</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">()</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayGetContext</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">dev_typeid</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">dev_id</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">Context</span><span class="p">(</span><span class="n">Context</span><span class="o">.</span><span class="n">devtype2str</span><span class="p">[</span><span class="n">dev_typeid</span><span class="o">.</span><span class="n">value</span><span class="p">],</span> <span class="n">dev_id</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Data-type of the array's elements.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.dtype</span>
<span class="sd">            This NDArray's data type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.zeros((2,3))</span>
<span class="sd">        >>> x.dtype</span>
<span class="sd">        <type 'numpy.float32'></span>
<span class="sd">        >>> y = mx.nd.zeros((2,3), dtype='int32')</span>
<span class="sd">        >>> y.dtype</span>
<span class="sd">        <type 'numpy.int32'></span>
<span class="sd">        """</span>
        <span class="n">mx_dtype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">()</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayGetDType</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">mx_dtype</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">_DTYPE_MX_TO_NP</span><span class="p">[</span><span class="n">mx_dtype</span><span class="o">.</span><span class="n">value</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="c1"># pylint: disable= invalid-name, undefined-variable</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns a copy of the array with axes transposed.</span>

<span class="sd">        Equivalent to ``mx.nd.transpose(self)`` except that</span>
<span class="sd">        self is returned if ``self.ndim < 2``.</span>

<span class="sd">        Unlike ``numpy.ndarray.T``, this function returns a copy</span>
<span class="sd">        rather than a view of the array unless ``self.ndim < 2``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.arange(0,6).reshape((2,3))</span>
<span class="sd">        >>> x.asnumpy()</span>
<span class="sd">        array([[ 0.,  1.,  2.],</span>
<span class="sd">               [ 3.,  4.,  5.]], dtype=float32)</span>
<span class="sd">        >>> x.T.asnumpy()</span>
<span class="sd">        array([[ 0.,  3.],</span>
<span class="sd">               [ 1.,  4.],</span>
<span class="sd">               [ 2.,  5.]], dtype=float32)</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o"><</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="c1"># pylint: enable= invalid-name, undefined-variable</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_fresh_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Whether this array's corresponding gradient array</span>
<span class="sd">        (registered via `autograd.mark_variables`) has been</span>
<span class="sd">        updated by `autograd.backward` since last reset.</span>

<span class="sd">        `_fresh_grad` need to be manually set to False</span>
<span class="sd">        after consuming gradient (usually after updating this</span>
<span class="sd">        array).</span>
<span class="sd">        """</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">()</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayGetGradState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">out</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">value</span>

    <span class="nd">@_fresh_grad</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">_fresh_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArraySetGradState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">state</span><span class="p">)))</span>

<div class="viewcode-block" id="NDArray.asnumpy"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.NDArray.asnumpy">[docs]</a>    <span class="k">def</span> <span class="nf">asnumpy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns a ``numpy.ndarray`` object with value copied from this array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.ones((2,3))</span>
<span class="sd">        >>> y = x.asnumpy()</span>
<span class="sd">        >>> type(y)</span>
<span class="sd">        <type 'numpy.ndarray'></span>
<span class="sd">        >>> y</span>
<span class="sd">        array([[ 1.,  1.,  1.],</span>
<span class="sd">               [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">        >>> z = mx.nd.ones((2,3), dtype='int32')</span>
<span class="sd">        >>> z.asnumpy()</span>
<span class="sd">        array([[1, 1, 1],</span>
<span class="sd">               [1, 1, 1]], dtype=int32)</span>
<span class="sd">        """</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArraySyncCopyToCPU</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span>
            <span class="n">data</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="NDArray.asscalar"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.NDArray.asscalar">[docs]</a>    <span class="k">def</span> <span class="nf">asscalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns a scalar whose value is copied from this array.</span>

<span class="sd">        This function is equivalent to ``self.asnumpy()[0]``. This NDArray must have shape (1,).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.ones((1,), dtype='int32')</span>
<span class="sd">        >>> x.asscalar()</span>
<span class="sd">        1</span>
<span class="sd">        >>> type(x.asscalar())</span>
<span class="sd">        <type 'numpy.int32'></span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"The current array is not a scalar"</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="NDArray.astype"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.NDArray.astype">[docs]</a>    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">"""Returns a copy of the array after casting to a specified type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy.dtype or str</span>
<span class="sd">            The type of the returned array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.zeros((2,3), dtype='float32')</span>
<span class="sd">        >>> y = x.astype('int32')</span>
<span class="sd">        >>> y.dtype</span>
<span class="sd">        <type 'numpy.int32'></span>
<span class="sd">        """</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="NDArray.copyto"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.NDArray.copyto">[docs]</a>    <span class="k">def</span> <span class="nf">copyto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""Copies the value of this array to another array.</span>

<span class="sd">        If ``other`` is a ``NDArray`` object, then ``other.shape`` and</span>
<span class="sd">        ``self.shape`` should be the same. This function copies the value from</span>
<span class="sd">        ``self`` to ``other``.</span>

<span class="sd">        If ``other`` is a context, a new ``NDArray`` will be first created on</span>
<span class="sd">        the target context, and the value of ``self`` is copied.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : NDArray or Context</span>
<span class="sd">            The destination array or context.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray</span>
<span class="sd">            The copied array. If ``other`` is an ``NDArray``, then the return value</span>
<span class="sd">            and ``other`` will point to the same ``NDArray``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.ones((2,3))</span>
<span class="sd">        >>> y = mx.nd.zeros((2,3), mx.gpu(0))</span>
<span class="sd">        >>> z = x.copyto(y)</span>
<span class="sd">        >>> z is y</span>
<span class="sd">        True</span>
<span class="sd">        >>> y.asnumpy()</span>
<span class="sd">        array([[ 1.,  1.,  1.],</span>
<span class="sd">               [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">        >>> y.copyto(mx.gpu(0))</span>
<span class="sd">        <NDArray 2x3 @gpu(0)></span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">handle</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'You are attempting to copy an array to itself'</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_copyto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Context</span><span class="p">):</span>
            <span class="n">hret</span> <span class="o">=</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">_new_alloc_handle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_copyto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">hret</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'copyto does not support type '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span></div>

<div class="viewcode-block" id="NDArray.copy"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.NDArray.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Makes a copy of this ``NDArray``, keeping the same context.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray</span>
<span class="sd">            The copied array</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.ones((2,3))</span>
<span class="sd">        >>> y = x.copy()</span>
<span class="sd">        >>> y.asnumpy()</span>
<span class="sd">        array([[ 1.,  1.,  1.],</span>
<span class="sd">               [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.as_in_context"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.NDArray.as_in_context">[docs]</a>    <span class="k">def</span> <span class="nf">as_in_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">"""Returns an array on the target device with the same value as this array.</span>

<span class="sd">        If the target context is the same as ``self.context``, then ``self`` is</span>
<span class="sd">        returned.  Otherwise, a copy is made.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        context : Context</span>
<span class="sd">            The target context.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDArray</span>
<span class="sd">            The target array.</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        >>> x = mx.nd.ones((2,3))</span>
<span class="sd">        >>> y = x.as_in_context(mx.cpu())</span>
<span class="sd">        >>> y is x</span>
<span class="sd">        True</span>
<span class="sd">        >>> z = x.as_in_context(mx.gpu(0))</span>
<span class="sd">        >>> z is x</span>
<span class="sd">        False</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">==</span> <span class="n">context</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">context</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.attach_grad"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.NDArray.attach_grad">[docs]</a>    <span class="k">def</span> <span class="nf">attach_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grad_req</span><span class="o">=</span><span class="s1">'write'</span><span class="p">):</span>
        <span class="sd">"""Attach a gradient buffer to this NDArray, so that `backward`</span>
<span class="sd">        can compute gradient with respect to it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grad_req : {'write', 'add', 'null'}</span>
<span class="sd">            How gradient will be accumulated.</span>
<span class="sd">            - 'write': gradient will be overwritten on every backward.</span>
<span class="sd">            - 'add': gradient will be added to existing value on every backward.</span>
<span class="sd">            - 'null': do not compute gradient for this NDArray.</span>
<span class="sd">        """</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># pylint: disable=undefined-variable</span>
        <span class="n">grad_req</span> <span class="o">=</span> <span class="n">_GRAD_REQ_MAP</span><span class="p">[</span><span class="n">grad_req</span><span class="p">]</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXAutogradMarkVariables</span><span class="p">(</span>
            <span class="mi">1</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">mx_uint</span><span class="p">(</span><span class="n">grad_req</span><span class="p">)),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">grad</span><span class="o">.</span><span class="n">handle</span><span class="p">)))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns gradient buffer attached to this NDArray."""</span>
        <span class="n">hdl</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayGetGrad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hdl</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">hdl</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">hdl</span><span class="p">)</span>

<div class="viewcode-block" id="NDArray.detach"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.NDArray.detach">[docs]</a>    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Returns a new NDArray, detached from the current graph."""</span>
        <span class="n">hdl</span> <span class="o">=</span> <span class="n">NDArrayHandle</span><span class="p">()</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayDetach</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hdl</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">hdl</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDArray.backward"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.NDArray.backward">[docs]</a>    <span class="k">def</span> <span class="nf">backward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_grad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">retain_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">train_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""Compute the gradients of this NDArray w.r.t variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out_grad : NDArray, optional</span>
<span class="sd">            Gradient with respect to head.</span>
<span class="sd">        retain_graph : bool, optional</span>
<span class="sd">            Whether to retain the computaion graph for another backward</span>
<span class="sd">            pass on the same graph. By default the computaion history</span>
<span class="sd">            is cleared.</span>
<span class="sd">        train_mode : bool, optional</span>
<span class="sd">            Whether to compute gradient for training or inference.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">out_grad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ograd_handles</span> <span class="o">=</span> <span class="p">[</span><span class="n">NDArrayHandle</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ograd_handles</span> <span class="o">=</span> <span class="p">[</span><span class="n">out_grad</span><span class="o">.</span><span class="n">handle</span><span class="p">]</span>

        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXAutogradBackwardEx</span><span class="p">(</span>
            <span class="mi">1</span><span class="p">,</span> <span class="n">c_array</span><span class="p">(</span><span class="n">NDArrayHandle</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">]),</span>
            <span class="n">c_array</span><span class="p">(</span><span class="n">NDArrayHandle</span><span class="p">,</span> <span class="n">ograd_handles</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">retain_graph</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">train_mode</span><span class="p">)))</span></div></div>


<div class="viewcode-block" id="onehot_encode"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.onehot_encode">[docs]</a><span class="k">def</span> <span class="nf">onehot_encode</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
    <span class="sd">"""One-hot encoding indices into matrix out.</span>

<span class="sd">    .. note:: `onehot_encode` is deprecated. Use `one_hot` instead.</span>

<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_onehot_encode</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="empty"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.empty">[docs]</a><span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mx_real_t</span><span class="p">):</span>
    <span class="sd">"""Returns a new array of given shape and type, without initializing entries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : int or tuple of int</span>
<span class="sd">        The shape of the empty array.</span>
<span class="sd">    ctx : Context, optional</span>
<span class="sd">        An optional device context (default is the current default context).</span>
<span class="sd">    dtype : str or numpy.dtype, optional</span>
<span class="sd">        An optional value type (default is `float32`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        A created array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> mx.nd.empty(1)</span>
<span class="sd">    <NDArray 1 @cpu(0)></span>
<span class="sd">    >>> mx.nd.empty((1,2), mx.gpu(0))</span>
<span class="sd">    <NDArray 1x2 @gpu(0)></span>
<span class="sd">    >>> mx.nd.empty((1,2), mx.gpu(0), 'float16')</span>
<span class="sd">    <NDArray 1x2 @gpu(0)></span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">Context</span><span class="o">.</span><span class="n">default_ctx</span>
    <span class="k">return</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">handle</span><span class="o">=</span><span class="n">_new_alloc_handle</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span></div>

<div class="viewcode-block" id="zeros"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.zeros">[docs]</a><span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mx_real_t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">"""Returns a new array filled with all zeros, with the given shape and type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : int or tuple of int</span>
<span class="sd">        The shape of the empty array.</span>
<span class="sd">    ctx : Context, optional</span>
<span class="sd">        An optional device context (default is the current default context).</span>
<span class="sd">    dtype : str or numpy.dtype, optional</span>
<span class="sd">        An optional value type (default is `float32`).</span>
<span class="sd">    out : NDArray, optional</span>
<span class="sd">        The output NDArray (default is `None`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        A created array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> mx.nd.zeros(1).asnumpy()</span>
<span class="sd">    array([ 0.], dtype=float32)</span>
<span class="sd">    >>> mx.nd.zeros((1,2), mx.gpu(0))</span>
<span class="sd">    <NDArray 1x2 @gpu(0)></span>
<span class="sd">    >>> mx.nd.zeros((1,2), mx.gpu(0), 'float16').asnumpy()</span>
<span class="sd">    array([[ 0.,  0.]], dtype=float16)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= unused-argument</span>
    <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">Context</span><span class="o">.</span><span class="n">default_ctx</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>

<div class="viewcode-block" id="ones"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.ones">[docs]</a><span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mx_real_t</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">"""Returns a new array filled with all ones, with the given shape and type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : int or tuple of int or list of int</span>
<span class="sd">        The shape of the empty array.</span>
<span class="sd">    ctx : Context, optional</span>
<span class="sd">        An optional device context.</span>
<span class="sd">        Defaults to the current default context (``mxnet.Context.default_ctx``).</span>
<span class="sd">    dtype : str or numpy.dtype, optional</span>
<span class="sd">        An optional value type (default is `float32`).</span>
<span class="sd">    out : NDArray, optional</span>
<span class="sd">        The output NDArray (default is `None`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        A new array of the specified shape filled with all ones.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> mx.nd.ones(1).asnumpy()</span>
<span class="sd">    array([ 1.], dtype=float32)</span>
<span class="sd">    >>> mx.nd.ones((1,2), mx.gpu(0))</span>
<span class="sd">    <NDArray 1x2 @gpu(0)></span>
<span class="sd">    >>> mx.nd.ones((1,2), dtype='float16').asnumpy()</span>
<span class="sd">    array([[ 1.,  1.]], dtype=float16)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= unused-argument</span>
    <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">Context</span><span class="o">.</span><span class="n">default_ctx</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>

<div class="viewcode-block" id="full"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.full">[docs]</a><span class="k">def</span> <span class="nf">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mx_real_t</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Returns a new array of given shape and type, filled with the given value `val`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    --------</span>
<span class="sd">    shape : int or tuple of int</span>
<span class="sd">        The shape of the new array.</span>
<span class="sd">    val : scalar</span>
<span class="sd">        Fill value.</span>
<span class="sd">    ctx : Context, optional</span>
<span class="sd">        Device context (default is the current default context).</span>
<span class="sd">    dtype : `str` or `numpy.dtype`, optional</span>
<span class="sd">        The data type of the returned `NDArray`. The default datatype is `float32`.</span>
<span class="sd">    out : NDArray, optional</span>
<span class="sd">        The output NDArray (default is `None`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        `NDArray` filled with `val`, with the given shape, ctx, and dtype.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> mx.nd.full(1, 2.0).asnumpy()</span>
<span class="sd">    array([ 2.], dtype=float32)</span>
<span class="sd">    >>> mx.nd.full((1, 2), 2.0, mx.gpu(0))</span>
<span class="sd">    <NDArray 1x2 @gpu(0)></span>
<span class="sd">    >>> mx.nd.full((1, 2), 2.0, dtype='float16').asnumpy()</span>
<span class="sd">    array([[ 2.,  2.]], dtype=float16)</span>
<span class="sd">    """</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">out</span>
    <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="array"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.array">[docs]</a><span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Creates an array from any object exposing the array interface.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source_array : array_like</span>
<span class="sd">        An object exposing the array interface, an object whose `__array__`</span>
<span class="sd">        method returns an array, or any (nested) sequence.</span>
<span class="sd">    ctx : Context, optional</span>
<span class="sd">        Device context (default is the current default context).</span>
<span class="sd">    dtype : str or numpy.dtype, optional</span>
<span class="sd">        The data type of the output array. The default dtype is ``source_array.dtype``</span>
<span class="sd">        if `source_array` is an `NDArray`, `float32` otherwise.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        An `NDArray` with the same contents as the `source_array`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> import numpy as np</span>
<span class="sd">    >>> mx.nd.array([1, 2, 3])</span>
<span class="sd">    <NDArray 3 @cpu(0)></span>
<span class="sd">    >>> mx.nd.array([[1, 2], [3, 4]])</span>
<span class="sd">    <NDArray 2x2 @cpu(0)></span>
<span class="sd">    >>> mx.nd.array(np.zeros((3, 2)))</span>
<span class="sd">    <NDArray 3x2 @cpu(0)></span>
<span class="sd">    >>> mx.nd.array(np.zeros((3, 2)), mx.gpu(0))</span>
<span class="sd">    <NDArray 3x2 @gpu(0)></span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">source_array</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">mx_real_t</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">source_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">source_array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'source_array must be array like object'</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">source_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="n">arr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">source_array</span>
    <span class="k">return</span> <span class="n">arr</span></div>


<div class="viewcode-block" id="moveaxis"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.moveaxis">[docs]</a><span class="k">def</span> <span class="nf">moveaxis</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
    <span class="sd">"""Moves the `source` axis into the `destination` position</span>
<span class="sd">    while leaving the other axes in their original order</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor : mx.nd.array</span>
<span class="sd">        The array which axes should be reordered</span>
<span class="sd">    source : int</span>
<span class="sd">        Original position of the axes to move.</span>
<span class="sd">    destination : int</span>
<span class="sd">        Destination position for each of the original axes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : mx.nd.array</span>
<span class="sd">        Array with moved axes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> X = mx.nd.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    >>> mx.nd.moveaxis(X, 0, 1).shape</span>
<span class="sd">    (3L, 2L)</span>
<span class="sd">    """</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Source should verify 0 <= source < tensor.ndim'</span>
                         <span class="s1">'Got </span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="n">source</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Destination should verify 0 <= destination < tensor.ndim'</span>
                         <span class="s1">'Got </span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="n">destination</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span></div>


<span class="c1"># pylint: disable= no-member, protected-access, too-many-arguments</span>
<div class="viewcode-block" id="arange"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.arange">[docs]</a><span class="k">def</span> <span class="nf">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mx_real_t</span><span class="p">):</span>
    <span class="sd">"""Returns evenly spaced values within a given interval.</span>

<span class="sd">    Values are generated within the half-open interval [`start`, `stop`). In other</span>
<span class="sd">    words, the interval includes `start` but excludes `stop`. The function is</span>
<span class="sd">    similar to the built-in Python function `range` and to `numpy.arange`,</span>
<span class="sd">    but returns an `NDArray`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start : float, optional</span>
<span class="sd">        Start of interval. The default start value is 0.</span>
<span class="sd">    stop : float</span>
<span class="sd">        End of interval.</span>
<span class="sd">    step : float, optional</span>
<span class="sd">        Spacing between values. The default step size is 1.</span>
<span class="sd">    repeat : int, optional</span>
<span class="sd">        Number of times to repeat each element. The default repeat count is 1.</span>
<span class="sd">    ctx : Context, optional</span>
<span class="sd">        Device context. Default context is the current default context.</span>
<span class="sd">    dtype : str or numpy.dtype, optional</span>
<span class="sd">        The data type of the `NDArray`. The default datatype is `np.float32`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        `NDArray` of evenly spaced values in the specified range.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> mx.nd.arange(3).asnumpy()</span>
<span class="sd">    array([ 0.,  1.,  2.], dtype=float32)</span>
<span class="sd">    >>> mx.nd.arange(2, 6).asnumpy()</span>
<span class="sd">    array([ 2.,  3.,  4.,  5.], dtype=float32)</span>
<span class="sd">    >>> mx.nd.arange(2, 6, step=2).asnumpy()</span>
<span class="sd">    array([ 2.,  4.], dtype=float32)</span>
<span class="sd">    >>> mx.nd.arange(2, 6, step=1.5, repeat=2).asnumpy()</span>
<span class="sd">    array([ 2. ,  2. ,  3.5,  3.5,  5. ,  5. ], dtype=float32)</span>
<span class="sd">    >>> mx.nd.arange(2, 6, step=2, repeat=3, dtype='int32').asnumpy()</span>
<span class="sd">    array([2, 2, 2, 4, 4, 4], dtype=int32)</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">Context</span><span class="o">.</span><span class="n">default_ctx</span>
    <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_arange</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">repeat</span><span class="p">,</span>
                             <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span></div>
<span class="c1"># pylint: enable= no-member, protected-access, too-many-arguments</span>

<span class="c1">#pylint: disable= too-many-arguments, no-member, protected-access</span>
<span class="k">def</span> <span class="nf">_ufunc_helper</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">fn_array</span><span class="p">,</span> <span class="n">fn_scalar</span><span class="p">,</span> <span class="n">lfn_scalar</span><span class="p">,</span> <span class="n">rfn_scalar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">""" Helper function for element-wise operation.</span>
<span class="sd">    The function will perform numpy-like broadcasting if needed and call different functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    --------</span>
<span class="sd">    lhs : NDArray or numeric value</span>
<span class="sd">        Left-hand side operand.</span>

<span class="sd">    rhs : NDArray or numeric value</span>
<span class="sd">        Right-hand operand,</span>

<span class="sd">    fn_array : function</span>
<span class="sd">        Function to be called if both lhs and rhs are of ``NDArray`` type.</span>

<span class="sd">    fn_scalar : function</span>
<span class="sd">        Function to be called if both lhs and rhs are numeric values.</span>

<span class="sd">    lfn_scalar : function</span>
<span class="sd">        Function to be called if lhs is ``NDArray`` while rhs is numeric value</span>

<span class="sd">    rfn_scalar : function</span>
<span class="sd">        Function to be called if lhs is numeric value while rhs is ``NDArray``;</span>
<span class="sd">        if none is provided, then the function is commutative, so rfn_scalar is equal to lfn_scalar</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    NDArray</span>
<span class="sd">        result array</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fn_scalar</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rfn_scalar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># commutative function</span>
                <span class="k">return</span> <span class="n">lfn_scalar</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">lhs</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rfn_scalar</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">lhs</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">numeric_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">lfn_scalar</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">rhs</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fn_array</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'type </span><span class="si">%s</span><span class="s1"> not supported'</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">rhs</span><span class="p">)))</span>
<span class="c1">#pylint: enable= too-many-arguments, no-member, protected-access</span>

<div class="viewcode-block" id="add"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.add">[docs]</a><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns element-wise sum of the input arrays with broadcasting.</span>

<span class="sd">    Equivalent to ``lhs + rhs``, ``mx.nd.broadcast_add(lhs, rhs)`` and</span>
<span class="sd">    ``mx.nd.broadcast_plus(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be added.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be added.</span>
<span class="sd">        If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The element-wise sum of the input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x+2).asnumpy()</span>
<span class="sd">    array([[ 3.,  3.,  3.],</span>
<span class="sd">           [ 3.,  3.,  3.]], dtype=float32)</span>
<span class="sd">    >>> (x+y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.add(x,y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    >>> (z + y).asnumpy()</span>
<span class="sd">    array([[ 0.,  1.],</span>
<span class="sd">           [ 1.,  2.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">broadcast_add</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_plus_scalar</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>

<div class="viewcode-block" id="subtract"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.subtract">[docs]</a><span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns element-wise difference of the input arrays with broadcasting.</span>

<span class="sd">    Equivalent to ``lhs - rhs``, ``mx.nd.broadcast_sub(lhs, rhs)`` and</span>
<span class="sd">    ``mx.nd.broadcast_minus(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be subtracted.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be subtracted.</span>
<span class="sd">        If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The element-wise difference of the input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x-2).asnumpy()</span>
<span class="sd">    array([[-1., -1., -1.],</span>
<span class="sd">           [-1., -1., -1.]], dtype=float32)</span>
<span class="sd">    >>> (x-y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.subtract(x,y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> (z-y).asnumpy()</span>
<span class="sd">    array([[ 0.,  1.],</span>
<span class="sd">           [-1.,  0.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">broadcast_sub</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_minus_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_rminus_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>

<div class="viewcode-block" id="multiply"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.multiply">[docs]</a><span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns element-wise product of the input arrays with broadcasting.</span>

<span class="sd">    Equivalent to ``lhs * rhs`` and ``mx.nd.broadcast_mul(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be multiplied.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be multiplied.</span>
<span class="sd">        If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The element-wise multiplication of the input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x*2).asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    >>> (x*y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.multiply(x, y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (z*y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.],</span>
<span class="sd">           [ 0.,  1.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">broadcast_mul</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_mul_scalar</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>

<div class="viewcode-block" id="divide"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.divide">[docs]</a><span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns element-wise division of the input arrays with broadcasting.</span>

<span class="sd">    Equivalent to ``lhs / rhs`` and ``mx.nd.broadcast_div(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array in division.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array in division.</span>
<span class="sd">        The arrays to be divided. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The element-wise division of the input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))*6</span>
<span class="sd">    >>> y = mx.nd.ones((2,1))*2</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 6.,  6.,  6.],</span>
<span class="sd">           [ 6.,  6.,  6.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 2.],</span>
<span class="sd">           [ 2.]], dtype=float32)</span>
<span class="sd">    >>> x/2</span>
<span class="sd">    <NDArray 2x3 @cpu(0)></span>
<span class="sd">    >>> (x/3).asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    >>> (x/y).asnumpy()</span>
<span class="sd">    array([[ 3.,  3.,  3.],</span>
<span class="sd">           [ 3.,  3.,  3.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.divide(x,y).asnumpy()</span>
<span class="sd">    array([[ 3.,  3.,  3.],</span>
<span class="sd">           [ 3.,  3.,  3.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">broadcast_div</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_div_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_rdiv_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>

<div class="viewcode-block" id="modulo"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.modulo">[docs]</a><span class="k">def</span> <span class="nf">modulo</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns element-wise modulo of the input arrays with broadcasting.</span>

<span class="sd">    Equivalent to ``lhs % rhs`` and ``mx.nd.broadcast_mod(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array in modulo.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array in modulo.</span>
<span class="sd">        The arrays to be taken modulo. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The element-wise modulo of the input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))*6</span>
<span class="sd">    >>> y = mx.nd.ones((2,1))*4</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 6.,  6.,  6.],</span>
<span class="sd">           [ 6.,  6.,  6.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 4.],</span>
<span class="sd">           [ 4.]], dtype=float32)</span>
<span class="sd">    >>> x%5</span>
<span class="sd">    <NDArray 2x3 @cpu(0)></span>
<span class="sd">    >>> (x%5).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x%y).asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.modulo(x,y).asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">broadcast_mod</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_mod_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_rmod_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>

<div class="viewcode-block" id="power"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.power">[docs]</a><span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exp</span><span class="p">):</span>
    <span class="sd">"""Returns result of first array elements raised to powers from second array, element-wise</span>
<span class="sd">    with broadcasting.</span>

<span class="sd">    Equivalent to ``base ** exp`` and ``mx.nd.broadcast_power(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base : scalar or NDArray</span>
<span class="sd">         The base array</span>
<span class="sd">    exp : scalar or NDArray</span>
<span class="sd">         The exponent array. If ``base.shape != exp.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The bases in x raised to the exponents in y.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))*2</span>
<span class="sd">    >>> y = mx.nd.arange(1,3).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(1,3).reshape((2,1))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 1.],</span>
<span class="sd">           [ 2.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 1.],</span>
<span class="sd">           [ 2.]], dtype=float32)</span>
<span class="sd">    >>> (x**2).asnumpy()</span>
<span class="sd">    array([[ 4.,  4.,  4.],</span>
<span class="sd">           [ 4.,  4.,  4.]], dtype=float32)</span>
<span class="sd">    >>> (x**y).asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 4.,  4.,  4.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.power(x,y).asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 4.,  4.,  4.]], dtype=float32)</span>
<span class="sd">    >>> (z**y).asnumpy()</span>
<span class="sd">    array([[ 1.],</span>
<span class="sd">           [ 4.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">base</span><span class="p">,</span>
        <span class="n">exp</span><span class="p">,</span>
        <span class="n">broadcast_power</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_power_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_rpower_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>

<div class="viewcode-block" id="maximum"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.maximum">[docs]</a><span class="k">def</span> <span class="nf">maximum</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns element-wise maximum of the input arrays with broadcasting.</span>

<span class="sd">    Equivalent to ``mx.nd.broadcast_maximum(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The element-wise maximum of the input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.maximum(x, 2).asnumpy()</span>
<span class="sd">    array([[ 2.,  2.,  2.],</span>
<span class="sd">           [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.maximum(x, y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.maximum(y, z).asnumpy()</span>
<span class="sd">    array([[ 0.,  1.],</span>
<span class="sd">           [ 1.,  1.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">broadcast_maximum</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">></span> <span class="n">y</span> <span class="k">else</span> <span class="n">y</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_maximum_scalar</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>

<div class="viewcode-block" id="minimum"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.minimum">[docs]</a><span class="k">def</span> <span class="nf">minimum</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns element-wise minimum of the input arrays with broadcasting.</span>

<span class="sd">    Equivalent to ``mx.nd.broadcast_minimum(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        The element-wise minimum of the input arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.minimum(x, 2).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.minimum(x, y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.minimum(z, y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.],</span>
<span class="sd">           [ 0.,  1.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">broadcast_minimum</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o"><</span> <span class="n">y</span> <span class="k">else</span> <span class="n">y</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_minimum_scalar</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>

<div class="viewcode-block" id="equal"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.equal">[docs]</a><span class="k">def</span> <span class="nf">equal</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns the result of element-wise **equal to** (==) comparison operation with</span>
<span class="sd">    broadcasting.</span>

<span class="sd">    For each element in input arrays, return 1(true) if corresponding elements are same,</span>
<span class="sd">    otherwise return 0(false).</span>

<span class="sd">    Equivalent to ``lhs == rhs`` and ``mx.nd.broadcast_equal(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Output array of boolean values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x == 1).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x == y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.equal(x,y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (z == y).asnumpy()</span>
<span class="sd">    array([[ 1.,  0.],</span>
<span class="sd">           [ 0.,  1.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">broadcast_equal</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_equal_scalar</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>

<div class="viewcode-block" id="not_equal"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.not_equal">[docs]</a><span class="k">def</span> <span class="nf">not_equal</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns the result of element-wise **not equal to** (!=) comparison operation</span>
<span class="sd">    with broadcasting.</span>

<span class="sd">    For each element in input arrays, return 1(true) if corresponding elements are different,</span>
<span class="sd">    otherwise return 0(false).</span>

<span class="sd">    Equivalent to ``lhs != rhs`` and ``mx.nd.broadcast_not_equal(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Output array of boolean values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (z == y).asnumpy()</span>
<span class="sd">    array([[ 1.,  0.],</span>
<span class="sd">           [ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x != 1).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> (x != y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.not_equal(x, y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> (z != y).asnumpy()</span>
<span class="sd">    array([[ 0.,  1.],</span>
<span class="sd">           [ 1.,  0.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">broadcast_not_equal</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_not_equal_scalar</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>

<div class="viewcode-block" id="greater"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.greater">[docs]</a><span class="k">def</span> <span class="nf">greater</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns the result of element-wise **greater than** (>) comparison operation</span>
<span class="sd">    with broadcasting.</span>

<span class="sd">    For each element in input arrays, return 1(true) if lhs elements are greater than rhs,</span>
<span class="sd">    otherwise return 0(false).</span>

<span class="sd">    Equivalent to ``lhs > rhs`` and ``mx.nd.broadcast_greater(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Output array of boolean values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x > 1).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> (x > y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.greater(x, y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> (z > y).asnumpy()</span>
<span class="sd">    array([[ 0.,  1.],</span>
<span class="sd">           [ 0.,  0.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">broadcast_greater</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">></span> <span class="n">y</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_greater_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_lesser_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>

<div class="viewcode-block" id="greater_equal"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.greater_equal">[docs]</a><span class="k">def</span> <span class="nf">greater_equal</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns the result of element-wise **greater than or equal to** (>=) comparison</span>
<span class="sd">    operation with broadcasting.</span>

<span class="sd">    For each element in input arrays, return 1(true) if lhs elements are greater than equal to rhs,</span>
<span class="sd">    otherwise return 0(false).</span>

<span class="sd">    Equivalent to ``lhs >= rhs`` and ``mx.nd.broadcast_greater_equal(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Output array of boolean values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x >= 1).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x >= y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.greater_equal(x, y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (z >= y).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.],</span>
<span class="sd">           [ 0.,  1.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">broadcast_greater_equal</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">>=</span> <span class="n">y</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_greater_equal_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_lesser_equal_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>

<div class="viewcode-block" id="lesser"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.lesser">[docs]</a><span class="k">def</span> <span class="nf">lesser</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns the result of element-wise **lesser than** (<) comparison operation</span>
<span class="sd">    with broadcasting.</span>

<span class="sd">    For each element in input arrays, return 1(true) if lhs elements are less than rhs,</span>
<span class="sd">    otherwise return 0(false).</span>

<span class="sd">    Equivalent to ``lhs < rhs`` and ``mx.nd.broadcast_lesser(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Output array of boolean values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x < 1).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> (x < y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.lesser(x, y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    >>> (z < y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.],</span>
<span class="sd">           [ 1.,  0.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">broadcast_lesser</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o"><</span> <span class="n">y</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_lesser_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_greater_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>


<div class="viewcode-block" id="lesser_equal"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.lesser_equal">[docs]</a><span class="k">def</span> <span class="nf">lesser_equal</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="sd">"""Returns the result of element-wise **lesser than or equal to** (<=) comparison</span>
<span class="sd">    operation with broadcasting.</span>

<span class="sd">    For each element in input arrays, return 1(true) if lhs elements are</span>
<span class="sd">    lesser than equal to rhs, otherwise return 0(false).</span>

<span class="sd">    Equivalent to ``lhs <= rhs`` and ``mx.nd.broadcast_lesser_equal(lhs, rhs)``.</span>

<span class="sd">    .. note::</span>

<span class="sd">       If the corresponding dimensions of two arrays have the same size or one of them has size 1,</span>
<span class="sd">       then the arrays are broadcastable to a common shape.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lhs : scalar or array</span>
<span class="sd">        First array to be compared.</span>
<span class="sd">    rhs : scalar or array</span>
<span class="sd">         Second array to be compared. If ``lhs.shape != rhs.shape``, they must be</span>
<span class="sd">        broadcastable to a common shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        Output array of boolean values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> y = mx.nd.arange(2).reshape((2,1))</span>
<span class="sd">    >>> z = mx.nd.arange(2).reshape((1,2))</span>
<span class="sd">    >>> x.asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> y.asnumpy()</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]], dtype=float32)</span>
<span class="sd">    >>> z.asnumpy()</span>
<span class="sd">    array([[ 0.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x <= 1).asnumpy()</span>
<span class="sd">    array([[ 1.,  1.,  1.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (x <= y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> mx.nd.lesser_equal(x, y).asnumpy()</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="sd">    >>> (z <= y).asnumpy()</span>
<span class="sd">    array([[ 1.,  0.],</span>
<span class="sd">           [ 1.,  1.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access</span>
    <span class="k">return</span> <span class="n">_ufunc_helper</span><span class="p">(</span>
        <span class="n">lhs</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">,</span>
        <span class="n">broadcast_lesser_equal</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o"><=</span> <span class="n">y</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_lesser_equal_scalar</span><span class="p">,</span>
        <span class="n">_internal</span><span class="o">.</span><span class="n">_greater_equal_scalar</span><span class="p">)</span></div>
    <span class="c1"># pylint: enable= no-member, protected-access</span>

<div class="viewcode-block" id="true_divide"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.true_divide">[docs]</a><span class="k">def</span> <span class="nf">true_divide</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>

    <span class="sd">"""This function is similar to :meth:`divide`.</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">divide</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span></div>

<div class="viewcode-block" id="negative"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.negative">[docs]</a><span class="k">def</span> <span class="nf">negative</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sd">"""Numerical negative, element-wise.</span>

<span class="sd">    Equals ``-arr``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : NDArray</span>
<span class="sd">        The input array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        ``-arr``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.ones((2,3))</span>
<span class="sd">    >>> (-x).asnumpy()</span>
<span class="sd">    array([[-1., -1., -1.],</span>
<span class="sd">           [-1., -1., -1.]], dtype=float32)</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">multiply</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span></div>


<div class="viewcode-block" id="load"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.load">[docs]</a><span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    <span class="sd">"""Loads an array from file.</span>

<span class="sd">    See more details in ``save``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        The filename.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of NDArray or dict of str to NDArray</span>
<span class="sd">        Loaded data.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'fname required to be a string'</span><span class="p">)</span>
    <span class="n">out_size</span> <span class="o">=</span> <span class="n">mx_uint</span><span class="p">()</span>
    <span class="n">out_name_size</span> <span class="o">=</span> <span class="n">mx_uint</span><span class="p">()</span>
    <span class="n">handles</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">NDArrayHandle</span><span class="p">)()</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">)()</span>
    <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArrayLoad</span><span class="p">(</span><span class="n">c_str</span><span class="p">(</span><span class="n">fname</span><span class="p">),</span>
                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">out_size</span><span class="p">),</span>
                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">handles</span><span class="p">),</span>
                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">out_name_size</span><span class="p">),</span>
                                  <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">names</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">out_name_size</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">NDArray</span><span class="p">(</span><span class="n">NDArrayHandle</span><span class="p">(</span><span class="n">handles</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">out_size</span><span class="o">.</span><span class="n">value</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">out_name_size</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">out_size</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">(</span><span class="n">py_str</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">NDArrayHandle</span><span class="p">(</span><span class="n">handles</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">out_size</span><span class="o">.</span><span class="n">value</span><span class="p">))</span></div>


<div class="viewcode-block" id="save"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.save">[docs]</a><span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">"""Saves a list of arrays or a dict of str->array to file.</span>

<span class="sd">    Examples of filenames:</span>

<span class="sd">    - ``/path/to/file``</span>
<span class="sd">    - ``s3://my-bucket/path/to/file`` (if compiled with AWS S3 supports)</span>
<span class="sd">    - ``hdfs://path/to/file`` (if compiled with HDFS supports)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        The filename.</span>
<span class="sd">    data : ``NDArray``, list of ``NDArray` or dict of str to ``NDArray``</span>
<span class="sd">        The data to save.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    >>> x = mx.nd.zeros((2,3))</span>
<span class="sd">    >>> y = mx.nd.ones((1,4))</span>
<span class="sd">    >>> mx.nd.save('my_list', [x,y])</span>
<span class="sd">    >>> mx.nd.save('my_dict', {'x':x, 'y':y})</span>
<span class="sd">    >>> mx.nd.load('my_list')</span>
<span class="sd">    [<NDArray 2x3 @cpu(0)>, <NDArray 1x4 @cpu(0)>]</span>
<span class="sd">    >>> mx.nd.load('my_dict')</span>
<span class="sd">    {'y': <NDArray 1x4 @cpu(0)>, 'x': <NDArray 2x3 @cpu(0)>}</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
    <span class="n">handles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'save only accept dict str->NDArray or list of NDArray'</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'save only accept dict str->NDArray or list of NDArray'</span><span class="p">)</span>
            <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
            <span class="n">handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">handle</span><span class="p">)</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">c_array</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'save only accept dict str->NDArray or list of NDArray'</span><span class="p">)</span>
            <span class="n">handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">handle</span><span class="p">)</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"data needs to either be a NDArray, dict of str, NDArray pairs "</span>
                         <span class="s2">"or a list of NDarrays."</span><span class="p">)</span>
    <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXNDArraySave</span><span class="p">(</span><span class="n">c_str</span><span class="p">(</span><span class="n">fname</span><span class="p">),</span>
                                  <span class="n">mx_uint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">handles</span><span class="p">)),</span>
                                  <span class="n">c_array</span><span class="p">(</span><span class="n">NDArrayHandle</span><span class="p">,</span> <span class="n">handles</span><span class="p">),</span>
                                  <span class="n">keys</span><span class="p">))</span></div>


<div class="viewcode-block" id="concatenate"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.concatenate">[docs]</a><span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">always_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">"""DEPRECATED, use ``concat`` instead</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrays : list of `NDArray`</span>
<span class="sd">        Arrays to be concatenate. They must have identical shape except</span>
<span class="sd">        the first dimension. They also must have the same data type.</span>
<span class="sd">    axis : int</span>
<span class="sd">        The axis along which to concatenate.</span>
<span class="sd">    always_copy : bool</span>
<span class="sd">        Default `True`. When not `True`, if the arrays only contain one</span>
<span class="sd">        `NDArray`, that element will be returned directly, avoid copying.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NDArray</span>
<span class="sd">        An `NDArray` that lives on the same context as `arrays[0].context`.</span>
<span class="sd">    """</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">></span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">always_copy</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">shape_axis</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">shape_rest1</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">shape_rest2</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">shape_axis</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">shape_rest1</span> <span class="o">==</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">shape_rest2</span> <span class="o">==</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">assert</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">ret_shape</span> <span class="o">=</span> <span class="n">shape_rest1</span> <span class="o">+</span> <span class="p">(</span><span class="n">shape_axis</span><span class="p">,)</span> <span class="o">+</span> <span class="n">shape_rest2</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">begin</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">ret_shape</span><span class="p">]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">arr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">begin</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="n">end</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="o">+</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="c1"># pylint: disable=no-member,protected-access</span>
            <span class="n">_internal</span><span class="o">.</span><span class="n">_crop_assign</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ret</span><span class="p">,</span>
                                   <span class="n">begin</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span>
                                   <span class="n">end</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">end</span><span class="p">))</span>
            <span class="c1"># pylint: enable=no-member,protected-access</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="imdecode"><a class="viewcode-back" href="../../api/python/ndarray.html#mxnet.ndarray.imdecode">[docs]</a><span class="k">def</span> <span class="nf">imdecode</span><span class="p">(</span><span class="n">str_img</span><span class="p">,</span> <span class="n">clip_rect</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""DEPRECATED, use mx.img instead</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    str_img : str</span>
<span class="sd">        Binary image data</span>
<span class="sd">    clip_rect : iterable of 4 int</span>
<span class="sd">        Clip decoded image to rectangle (x0, y0, x1, y1).</span>
<span class="sd">    out : NDArray</span>
<span class="sd">        Output buffer. Can be 3 dimensional (c, h, w) or 4 dimensional (n, c, h, w).</span>
<span class="sd">    index : int</span>
<span class="sd">        Output decoded image to i-th slice of 4 dimensional buffer.</span>
<span class="sd">    channels : int</span>
<span class="sd">        Number of channels to output. Decode to grey scale when channels = 1.</span>
<span class="sd">    mean : NDArray</span>
<span class="sd">        Subtract mean from decode image before outputing.</span>
<span class="sd">    """</span>
    <span class="c1"># pylint: disable= no-member, protected-access, too-many-arguments</span>
    <span class="k">if</span> <span class="n">mean</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">NDArray</span><span class="p">(</span><span class="n">_new_empty_handle</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_imdecode</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                   <span class="n">channels</span><span class="p">,</span>
                                   <span class="nb">len</span><span class="p">(</span><span class="n">str_img</span><span class="p">),</span>
                                   <span class="n">str_img</span><span class="o">=</span><span class="n">str_img</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_internal</span><span class="o">.</span><span class="n">_imdecode</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                   <span class="n">clip_rect</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                   <span class="n">channels</span><span class="p">,</span>
                                   <span class="nb">len</span><span class="p">(</span><span class="n">str_img</span><span class="p">),</span>
                                   <span class="n">str_img</span><span class="o">=</span><span class="n">str_img</span><span class="p">,</span>
                                   <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<span class="c1"># pylint: disable=too-many-locals, invalid-name</span>
<span class="k">def</span> <span class="nf">_make_ndarray_function</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="sd">"""Create a NDArray function from the FunctionHandle."""</span>
    <span class="n">real_name</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">()</span>
    <span class="n">desc</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">()</span>
    <span class="n">num_args</span> <span class="o">=</span> <span class="n">mx_uint</span><span class="p">()</span>
    <span class="n">arg_names</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">)()</span>
    <span class="n">arg_types</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">)()</span>
    <span class="n">arg_descs</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">)()</span>
    <span class="n">key_var_num_args</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">()</span>
    <span class="n">ret_type</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">()</span>

    <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXSymbolGetAtomicSymbolInfo</span><span class="p">(</span>
        <span class="n">handle</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">real_name</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">num_args</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">arg_names</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">arg_types</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">arg_descs</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">key_var_num_args</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">ret_type</span><span class="p">)))</span>
    <span class="n">narg</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_args</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="n">arg_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">py_str</span><span class="p">(</span><span class="n">arg_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">narg</span><span class="p">)]</span>
    <span class="n">arg_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">py_str</span><span class="p">(</span><span class="n">arg_types</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">narg</span><span class="p">)]</span>
    <span class="n">func_name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="n">key_var_num_args</span> <span class="o">=</span> <span class="n">py_str</span><span class="p">(</span><span class="n">key_var_num_args</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="n">ret_type</span> <span class="o">=</span> <span class="n">py_str</span><span class="p">(</span><span class="n">ret_type</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="n">ret_type</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">''</span>
    <span class="n">doc_str</span> <span class="o">=</span> <span class="n">_build_doc</span><span class="p">(</span><span class="n">func_name</span><span class="p">,</span>
                         <span class="n">py_str</span><span class="p">(</span><span class="n">desc</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
                         <span class="n">arg_names</span><span class="p">,</span>
                         <span class="n">arg_types</span><span class="p">,</span>
                         <span class="p">[</span><span class="n">py_str</span><span class="p">(</span><span class="n">arg_descs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">narg</span><span class="p">)],</span>
                         <span class="n">key_var_num_args</span><span class="p">,</span>
                         <span class="n">ret_type</span><span class="p">)</span>

    <span class="n">dtype_name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">arr_name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ndsignature</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ndarg_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kwarg_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">narg</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">atype</span> <span class="o">=</span> <span class="n">arg_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arg_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">'dtype'</span><span class="p">:</span>
            <span class="n">dtype_name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">signature</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'</span><span class="si">%s</span><span class="s1">=_Null'</span><span class="o">%</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">atype</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'NDArray'</span><span class="p">)</span> <span class="ow">or</span> <span class="n">atype</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'Symbol'</span><span class="p">):</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">arr_name</span><span class="p">,</span> \
                <span class="s2">"Op can only have one argument with variable "</span> \
                <span class="s2">"size and it must be the last argument."</span>
            <span class="k">if</span> <span class="n">atype</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">'[]'</span><span class="p">):</span>
                <span class="n">ndsignature</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'*</span><span class="si">%s</span><span class="s1">'</span><span class="o">%</span><span class="n">name</span><span class="p">)</span>
                <span class="n">arr_name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ndsignature</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'</span><span class="si">%s</span><span class="s1">=None'</span><span class="o">%</span><span class="n">name</span><span class="p">)</span>
                <span class="n">ndarg_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">signature</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'</span><span class="si">%s</span><span class="s1">=_Null'</span><span class="o">%</span><span class="n">name</span><span class="p">)</span>
            <span class="n">kwarg_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">signature</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'out=None'</span><span class="p">)</span>
    <span class="n">signature</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'name=None'</span><span class="p">)</span>
    <span class="n">signature</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'**kwargs'</span><span class="p">)</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="n">ndsignature</span> <span class="o">+</span> <span class="n">signature</span>

    <span class="n">code</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">arr_name</span><span class="p">:</span>
        <span class="n">code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"""</span>
<span class="s2">def </span><span class="si">%s</span><span class="s2">(*</span><span class="si">%s</span><span class="s2">, **kwargs):"""</span><span class="o">%</span><span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="n">arr_name</span><span class="p">))</span>
        <span class="n">code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"""</span>
<span class="s2">    ndargs = []</span>
<span class="s2">    for i in </span><span class="si">{}</span><span class="s2">:</span>
<span class="s2">        assert isinstance(i, NDArrayBase), </span><span class="se">\\</span><span class="s2"></span>
<span class="s2">            "Positional arguments must have NDArray type, " </span><span class="se">\\</span><span class="s2"></span>
<span class="s2">            "but got </span><span class="si">%s</span><span class="s2">"</span><span class="si">%s</span><span class="s2">tr(i)</span>
<span class="s2">        ndargs.append(i)"""</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arr_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dtype_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"""</span>
<span class="s2">    if '</span><span class="si">%s</span><span class="s2">' in kwargs:</span>
<span class="s2">        kwargs['</span><span class="si">%s</span><span class="s2">'] = np.dtype(kwargs['</span><span class="si">%s</span><span class="s2">']).name"""</span><span class="o">%</span><span class="p">(</span>
            <span class="n">dtype_name</span><span class="p">,</span> <span class="n">dtype_name</span><span class="p">,</span> <span class="n">dtype_name</span><span class="p">))</span>
        <span class="n">code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"""</span>
<span class="s2">    _ = kwargs.pop('name', None)</span>
<span class="s2">    out = kwargs.pop('out', None)</span>
<span class="s2">    keys = list(kwargs.keys())</span>
<span class="s2">    vals = list(kwargs.values())"""</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"""</span>
<span class="s2">def </span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">):</span>
<span class="s2">    ndargs = []</span>
<span class="s2">    keys = list(kwargs.keys())</span>
<span class="s2">    vals = list(kwargs.values())"""</span><span class="o">%</span><span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">signature</span><span class="p">)))</span>
        <span class="c1"># NDArray args</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ndarg_names</span><span class="p">:</span> <span class="c1"># pylint: disable=redefined-argument-from-local</span>
            <span class="n">code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"""</span>
<span class="s2">    if </span><span class="si">{name}</span><span class="s2"> is not None:</span>
<span class="s2">        assert isinstance(</span><span class="si">{name}</span><span class="s2">, NDArrayBase), </span><span class="se">\\</span><span class="s2"></span>
<span class="s2">            "Argument </span><span class="si">{name}</span><span class="s2"> must have NDArray type, but got </span><span class="si">%s</span><span class="s2">"</span><span class="si">%s</span><span class="s2">tr(</span><span class="si">{name}</span><span class="s2">)</span>
<span class="s2">        ndargs.append(</span><span class="si">{name}</span><span class="s2">)"""</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">))</span>
        <span class="c1"># kwargs</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwarg_names</span><span class="p">:</span> <span class="c1"># pylint: disable=redefined-argument-from-local</span>
            <span class="n">code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"""</span>
<span class="s2">    if </span><span class="si">%s</span><span class="s2"> is not _Null:</span>
<span class="s2">        keys.append('</span><span class="si">%s</span><span class="s2">')</span>
<span class="s2">        vals.append(</span><span class="si">%s</span><span class="s2">)"""</span><span class="o">%</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="c1"># dtype</span>
        <span class="k">if</span> <span class="n">dtype_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"""</span>
<span class="s2">    if </span><span class="si">%s</span><span class="s2"> is not _Null:</span>
<span class="s2">        keys.append('</span><span class="si">%s</span><span class="s2">')</span>
<span class="s2">        vals.append(np.dtype(</span><span class="si">%s</span><span class="s2">).name)"""</span><span class="o">%</span><span class="p">(</span><span class="n">dtype_name</span><span class="p">,</span> <span class="n">dtype_name</span><span class="p">,</span> <span class="n">dtype_name</span><span class="p">))</span>

    <span class="n">code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"""</span>
<span class="s2">    return _imperative_invoke(</span><span class="si">%d</span><span class="s2">, ndargs, keys, vals, out)"""</span><span class="o">%</span><span class="p">(</span>
        <span class="n">handle</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>

    <span class="n">local</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">exec</span><span class="p">(</span><span class="s1">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">code</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">local</span><span class="p">)</span>  <span class="c1"># pylint: disable=exec-used</span>
    <span class="n">ndarray_function</span> <span class="o">=</span> <span class="n">local</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span>
    <span class="n">ndarray_function</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">func_name</span>
    <span class="n">ndarray_function</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doc_str</span>
    <span class="n">ndarray_function</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="s1">'mxnet.ndarray'</span>
    <span class="k">return</span> <span class="n">ndarray_function</span>


<span class="c1"># pylint: enable=too-many-locals, invalid-name</span>
<span class="k">def</span> <span class="nf">_init_ndarray_module</span><span class="p">(</span><span class="n">ndarray_class</span><span class="p">,</span> <span class="n">root_namespace</span><span class="p">):</span>
    <span class="sd">"""List and add all the ndarray functions to current module."""</span>
    <span class="n">_set_ndarray_class</span><span class="p">(</span><span class="n">ndarray_class</span><span class="p">)</span>
    <span class="n">plist</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">)()</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">()</span>

    <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">MXListAllOpNames</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">size</span><span class="p">),</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">plist</span><span class="p">)))</span>
    <span class="n">op_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
        <span class="n">op_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">py_str</span><span class="p">(</span><span class="n">plist</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="n">module_obj</span> <span class="o">=</span> <span class="n">_sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s2">"</span><span class="si">%s</span><span class="s2">.ndarray"</span> <span class="o">%</span> <span class="n">root_namespace</span><span class="p">]</span>
    <span class="n">module_internal</span> <span class="o">=</span> <span class="n">_sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s2">"</span><span class="si">%s</span><span class="s2">._ndarray_internal"</span> <span class="o">%</span> <span class="n">root_namespace</span><span class="p">]</span>
    <span class="n">module_contrib</span> <span class="o">=</span> <span class="n">_sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s2">"</span><span class="si">%s</span><span class="s2">.contrib.ndarray"</span> <span class="o">%</span> <span class="n">root_namespace</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">op_names</span><span class="p">:</span>
        <span class="n">hdl</span> <span class="o">=</span> <span class="n">OpHandle</span><span class="p">()</span>
        <span class="n">check_call</span><span class="p">(</span><span class="n">_LIB</span><span class="o">.</span><span class="n">NNGetOpHandle</span><span class="p">(</span><span class="n">c_str</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">hdl</span><span class="p">)))</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">_make_ndarray_function</span><span class="p">(</span><span class="n">hdl</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'_contrib_'</span><span class="p">):</span>
            <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">[</span><span class="mi">9</span><span class="p">:]</span>
            <span class="n">function</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="s1">'mxnet.contrib.ndarray'</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">module_contrib</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'_'</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">module_internal</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">module_obj</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>

<span class="n">_init_ndarray_module</span><span class="p">(</span><span class="n">NDArray</span><span class="p">,</span> <span class="s2">"mxnet"</span><span class="p">)</span>

<span class="c1"># from .base import add_fileline_to_docstring</span>
<span class="c1"># add_fileline_to_docstring(__name__)</span>
</pre></div>
</div>
</div>
<div aria-label="main navigation" class="sphinxsidebar rightsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
</div>
</div>
</div><div class="footer">
<div class="section-disclaimer">
<div class="container">
<div>
<img height="60" src="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/apache_incubator_logo.png"/>
<p>
            Apache MXNet is an effort undergoing incubation at The Apache Software Foundation (ASF), <strong>sponsored by the <i>Apache Incubator</i></strong>. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.
        </p>
<p>
            "Copyright © 2017-2018, The Apache Software Foundation
            Apache MXNet, MXNet, Apache, the Apache feather, and the Apache MXNet project logo are either registered trademarks or trademarks of the Apache Software Foundation."
        </p>
</div>
</div>
</div>
</div> <!-- pagename != index -->
</div>
<script crossorigin="anonymous" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
<script src="../../_static/js/sidebar.js" type="text/javascript"></script>
<script src="../../_static/js/search.js" type="text/javascript"></script>
<script src="../../_static/js/navbar.js" type="text/javascript"></script>
<script src="../../_static/js/clipboard.min.js" type="text/javascript"></script>
<script src="../../_static/js/copycode.js" type="text/javascript"></script>
<script src="../../_static/js/page.js" type="text/javascript"></script>
<script src="../../_static/js/docversion.js" type="text/javascript"></script>
<script type="text/javascript">
        $('body').ready(function () {
            $('body').css('visibility', 'visible');
        });
    </script>
</body>
</html>