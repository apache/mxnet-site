<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="NDArray API" property="og:title">
<meta content="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/og-logo.png" property="og:image">
<meta content="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/og-logo.png" property="og:image:secure_url">
<meta content="NDArray API" property="og:description"/>
<title>NDArray API — mxnet  documentation</title>
<link crossorigin="anonymous" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" rel="stylesheet"/>
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet"/>
<link href="../../../_static/basic.css" rel="stylesheet" type="text/css">
<link href="../../../_static/pygments.css" rel="stylesheet" type="text/css">
<link href="../../../_static/mxnet.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
<script src="https://code.jquery.com/jquery-1.11.1.min.js" type="text/javascript"></script>
<script src="../../../_static/underscore.js" type="text/javascript"></script>
<script src="../../../_static/searchtools_custom.js" type="text/javascript"></script>
<script src="../../../_static/doctools.js" type="text/javascript"></script>
<script src="../../../_static/selectlang.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script type="text/javascript"> jQuery(function() { Search.loadIndex("/versions/1.5.0/searchindex.js"); Search.init();}); </script>
<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
      Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-96378503-1', 'auto');
      ga('send', 'pageview');

    </script>
<!-- -->
<!-- <script type="text/javascript" src="../../../_static/jquery.js"></script> -->
<!-- -->
<!-- <script type="text/javascript" src="../../../_static/underscore.js"></script> -->
<!-- -->
<!-- <script type="text/javascript" src="../../../_static/doctools.js"></script> -->
<!-- -->
<!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<!-- -->
<link href="../../../genindex.html" rel="index" title="Index">
<link href="../../../search.html" rel="search" title="Search"/>
<link href="../index.html" rel="up" title="MXNet - Python API"/>
<link href="random.html" rel="next" title="Random Distribution Generator NDArray API"/>
<link href="../executor/executor.html" rel="prev" title="Executor and Executor Manager"/>
<link href="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/mxnet-icon.png" rel="icon" type="image/png"/>
</link></link></link></meta></meta></meta></head>
<body background="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/mxnet-background-compressed.jpeg" role="document">
<div class="content-block"><div class="navbar navbar-fixed-top">
<div class="container" id="navContainer">
<div class="innder" id="header-inner">
<h1 id="logo-wrap">
<a href="../../../" id="logo"><img src="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/mxnet_logo.png"/></a>
</h1>
<nav class="nav-bar" id="main-nav">
<a class="main-nav-link" href="/versions/1.5.0/install/index.html">Install</a>
<span id="dropdown-menu-position-anchor">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">Gluon <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu">
<li><a class="main-nav-link" href="/versions/1.5.0/tutorials/gluon/gluon.html">About</a></li>
<li><a class="main-nav-link" href="https://www.d2l.ai/">Dive into Deep Learning</a></li>
<li><a class="main-nav-link" href="https://gluon-cv.mxnet.io">GluonCV Toolkit</a></li>
<li><a class="main-nav-link" href="https://gluon-nlp.mxnet.io/">GluonNLP Toolkit</a></li>
</ul>
</span>
<span id="dropdown-menu-position-anchor">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">API <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu">
<li><a class="main-nav-link" href="/versions/1.5.0/api/python/index.html">Python</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/api/c++/index.html">C++</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/api/clojure/index.html">Clojure</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/api/java/index.html">Java</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/api/julia/index.html">Julia</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/api/perl/index.html">Perl</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/api/r/index.html">R</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/api/scala/index.html">Scala</a></li>
</ul>
</span>
<span id="dropdown-menu-position-anchor-docs">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">Docs <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu-docs">
<li><a class="main-nav-link" href="/versions/1.5.0/faq/index.html">FAQ</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/tutorials/index.html">Tutorials</a>
<li><a class="main-nav-link" href="https://github.com/apache/incubator-mxnet/tree/1.5.0/example">Examples</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/architecture/index.html">Architecture</a></li>
<li><a class="main-nav-link" href="https://cwiki.apache.org/confluence/display/MXNET/Apache+MXNet+Home">Developer Wiki</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/model_zoo/index.html">Model Zoo</a></li>
<li><a class="main-nav-link" href="https://github.com/onnx/onnx-mxnet">ONNX</a></li>
</li></ul>
</span>
<span id="dropdown-menu-position-anchor-community">
<a aria-expanded="true" aria-haspopup="true" class="main-nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button">Community <span class="caret"></span></a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu-community">
<li><a class="main-nav-link" href="http://discuss.mxnet.io">Forum</a></li>
<li><a class="main-nav-link" href="https://github.com/apache/incubator-mxnet/tree/1.5.0">Github</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/community/contribute.html">Contribute</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/community/ecosystem.html">Ecosystem</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/community/powered_by.html">Powered By</a></li>
</ul>
</span>
<span id="dropdown-menu-position-anchor-version" style="position: relative"><a href="#" class="main-nav-link dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="true">1.5.0<span class="caret"></span></a><ul id="package-dropdown-menu" class="dropdown-menu"><li><a href="/">master</a></li><li><a href="/versions/1.7.0/">1.7.0</a></li><li><a href=/versions/1.6.0/>1.6.0</a></li><li><a href=/versions/1.5.0/>1.5.0</a></li><li><a href=/versions/1.4.1/>1.4.1</a></li><li><a href=/versions/1.3.1/>1.3.1</a></li><li><a href=/versions/1.2.1/>1.2.1</a></li><li><a href=/versions/1.1.0/>1.1.0</a></li><li><a href=/versions/1.0.0/>1.0.0</a></li><li><a href=/versions/0.12.1/>0.12.1</a></li><li><a href=/versions/0.11.0/>0.11.0</a></li></ul></span></nav>
<script> function getRootPath(){ return "../../../" } </script>
<div class="burgerIcon dropdown">
<a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button">☰</a>
<ul class="dropdown-menu" id="burgerMenu">
<li><a href="/versions/1.5.0/install/index.html">Install</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/tutorials/index.html">Tutorials</a></li>
<li class="dropdown-submenu dropdown">
<a aria-expanded="true" aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" tabindex="-1">Gluon</a>
<ul class="dropdown-menu navbar-menu" id="package-dropdown-menu">
<li><a class="main-nav-link" href="/versions/1.5.0/tutorials/gluon/gluon.html">About</a></li>
<li><a class="main-nav-link" href="http://gluon.mxnet.io">The Straight Dope (Tutorials)</a></li>
<li><a class="main-nav-link" href="https://gluon-cv.mxnet.io">GluonCV Toolkit</a></li>
<li><a class="main-nav-link" href="https://gluon-nlp.mxnet.io/">GluonNLP Toolkit</a></li>
</ul>
</li>
<li class="dropdown-submenu">
<a aria-expanded="true" aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" tabindex="-1">API</a>
<ul class="dropdown-menu">
<li><a class="main-nav-link" href="/versions/1.5.0/api/python/index.html">Python</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/api/c++/index.html">C++</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/api/clojure/index.html">Clojure</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/api/java/index.html">Java</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/api/julia/index.html">Julia</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/api/perl/index.html">Perl</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/api/r/index.html">R</a></li>
<li><a class="main-nav-link" href="/versions/1.5.0/api/scala/index.html">Scala</a></li>
</ul>
</li>
<li class="dropdown-submenu">
<a aria-expanded="true" aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" tabindex="-1">Docs</a>
<ul class="dropdown-menu">
<li><a href="/versions/1.5.0/faq/index.html" tabindex="-1">FAQ</a></li>
<li><a href="/versions/1.5.0/tutorials/index.html" tabindex="-1">Tutorials</a></li>
<li><a href="https://github.com/apache/incubator-mxnet/tree/1.5.0/example" tabindex="-1">Examples</a></li>
<li><a href="/versions/1.5.0/architecture/index.html" tabindex="-1">Architecture</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/MXNET/Apache+MXNet+Home" tabindex="-1">Developer Wiki</a></li>
<li><a href="/versions/1.5.0/model_zoo/index.html" tabindex="-1">Gluon Model Zoo</a></li>
<li><a href="https://github.com/onnx/onnx-mxnet" tabindex="-1">ONNX</a></li>
</ul>
</li>
<li class="dropdown-submenu dropdown">
<a aria-haspopup="true" class="dropdown-toggle burger-link" data-toggle="dropdown" href="#" role="button" tabindex="-1">Community</a>
<ul class="dropdown-menu">
<li><a href="http://discuss.mxnet.io" tabindex="-1">Forum</a></li>
<li><a href="https://github.com/apache/incubator-mxnet/tree/1.5.0" tabindex="-1">Github</a></li>
<li><a href="/versions/1.5.0/community/contribute.html" tabindex="-1">Contribute</a></li>
<li><a href="/versions/1.5.0/community/ecosystem.html" tabindex="-1">Ecosystem</a></li>
<li><a href="/versions/1.5.0/community/powered_by.html" tabindex="-1">Powered By</a></li>
</ul>
</li>
<li id="dropdown-menu-position-anchor-version-mobile" class="dropdown-submenu" style="position: relative"><a href="#" tabindex="-1">1.5.0</a><ul class="dropdown-menu"><li><a tabindex="-1" href=/>master</a></li><li><a tabindex="-1" href=/versions/1.6.0/>1.6.0</a></li><li><a tabindex="-1" href=/versions/1.5.0/>1.5.0</a></li><li><a tabindex="-1" href=/versions/1.4.1/>1.4.1</a></li><li><a tabindex="-1" href=/versions/1.3.1/>1.3.1</a></li><li><a tabindex="-1" href=/versions/1.2.1/>1.2.1</a></li><li><a tabindex="-1" href=/versions/1.1.0/>1.1.0</a></li><li><a tabindex="-1" href=/versions/1.0.0/>1.0.0</a></li><li><a tabindex="-1" href=/versions/0.12.1/>0.12.1</a></li><li><a tabindex="-1" href=/versions/0.11.0/>0.11.0</a></li></ul></li></ul>
</div>
<div class="plusIcon dropdown">
<a class="dropdown-toggle" data-toggle="dropdown" href="#" role="button"><span aria-hidden="true" class="glyphicon glyphicon-plus"></span></a>
<ul class="dropdown-menu dropdown-menu-right" id="plusMenu"></ul>
</div>
<div id="search-input-wrap">
<form action="../../../search.html" autocomplete="off" class="" method="get" role="search">
<div class="form-group inner-addon left-addon">
<i class="glyphicon glyphicon-search"></i>
<input class="form-control" name="q" placeholder="Search" type="text"/>
</div>
<input name="check_keywords" type="hidden" value="yes">
<input name="area" type="hidden" value="default"/>
</input></form>
<div id="search-preview"></div>
</div>
<div id="searchIcon">
<span aria-hidden="true" class="glyphicon glyphicon-search"></span>
</div>
<!-- <div id="lang-select-wrap"> -->
<!--   <label id="lang-select-label"> -->
<!--     <\!-- <i class="fa fa-globe"></i> -\-> -->
<!--     <span></span> -->
<!--   </label> -->
<!--   <select id="lang-select"> -->
<!--     <option value="en">Eng</option> -->
<!--     <option value="zh">中文</option> -->
<!--   </select> -->
<!-- </div> -->
<!--     <a id="mobile-nav-toggle">
        <span class="mobile-nav-toggle-bar"></span>
        <span class="mobile-nav-toggle-bar"></span>
        <span class="mobile-nav-toggle-bar"></span>
      </a> -->
</div>
</div>
</div>
<script type="text/javascript">
        $('body').css('background', 'white');
    </script>
<div class="container">
<div class="row">
<div aria-label="main navigation" class="sphinxsidebar leftsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">MXNet APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../architecture/index.html">MXNet Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../community/index.html">MXNet Community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/index.html">MXNet FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gluon/index.html">About Gluon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html">Installing MXNet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html#nvidia-jetson-tx-family">Nvidia Jetson TX family</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html#source-download">Source Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../model_zoo/index.html">MXNet Model Zoo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
</ul>
</div>
</div>
<div class="content">
<div class="page-tracker"></div>
<!--- Licensed to the Apache Software Foundation (ASF) under one -->
<!--- or more contributor license agreements.  See the NOTICE file -->
<!--- distributed with this work for additional information -->
<!--- regarding copyright ownership.  The ASF licenses this file -->
<!--- to you under the Apache License, Version 2.0 (the -->
<!--- "License"); you may not use this file except in compliance -->
<!--- with the License.  You may obtain a copy of the License at --><!---   http://www.apache.org/licenses/LICENSE-2.0 --><!--- Unless required by applicable law or agreed to in writing, -->
<!--- software distributed under the License is distributed on an -->
<!--- "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY -->
<!--- KIND, either express or implied.  See the License for the -->
<!--- specific language governing permissions and limitations -->
<!--- under the License. --><div class="section" id="ndarray-api">
<span id="ndarray-api"></span><h1>NDArray API<a class="headerlink" href="#ndarray-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<span id="overview"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>This document lists the routines of the <em>n</em>-dimensional array package:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="sparse.html#module-mxnet.ndarray" title="mxnet.ndarray"><code class="xref py py-obj docutils literal"><span class="pre">mxnet.ndarray</span></code></a></td>
<td>NDArray API of MXNet.</td>
</tr>
</tbody>
</table>
<p>The <code class="docutils literal"><span class="pre">NDArray</span></code> API, defined in the <code class="docutils literal"><span class="pre">ndarray</span></code> (or simply <code class="docutils literal"><span class="pre">nd</span></code>) package, provides
imperative tensor operations on CPU/GPU.
An <code class="docutils literal"><span class="pre">NDArray</span></code> represents a multi-dimensional, fixed-size homogenous array.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">>>> </span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go"><class 'mxnet.ndarray.NDArray'></span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span>
<span class="gp">>>> </span><span class="k">print</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
<span class="go">[[ 4.  5.  6.]</span>
<span class="go"> [ 7.  8.  9.]]</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">as_in_context</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">>>> </span><span class="k">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go"><NDArray 2x3 @gpu(0)></span>
</pre></div>
</div>
<p>A detailed tutorial is available at
<a class="reference external" href="/versions/1.5.0/tutorials/basic/ndarray.html">NDArray - Imperative tensor operations on CPU/GPU</a>.
<br/><br/></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><code class="docutils literal"><span class="pre">mxnet.ndarray</span></code> is similar to <code class="docutils literal"><span class="pre">numpy.ndarray</span></code> in some aspects. But the differences are not negligible. For instance:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">mxnet.ndarray.NDArray.T</span></code> does real data transpose to return new a copied
array, instead of returning a view of the input array.</li>
<li><code class="docutils literal"><span class="pre">mxnet.ndarray.dot</span></code> performs dot product between the last axis of the
first input array and the first axis of the second input, while <cite>numpy.dot</cite>
uses the second last axis of the input array.</li>
</ul>
<p class="last">In addition, <code class="docutils literal"><span class="pre">mxnet.ndarray.NDArray</span></code> supports GPU computation and various neural
network layers.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><code class="docutils literal"><span class="pre">ndarray</span></code> provides almost the same routines as <code class="docutils literal"><span class="pre">symbol</span></code>. Most
routines between these two packages share the source code. But <code class="docutils literal"><span class="pre">ndarray</span></code>
differs from <code class="docutils literal"><span class="pre">symbol</span></code> in few aspects:</p>
<ul class="last simple">
<li><code class="docutils literal"><span class="pre">ndarray</span></code> adopts imperative programming, namely sentences are executed
step-by-step so that the results can be obtained immediately whereas
<code class="docutils literal"><span class="pre">symbol</span></code> adopts declarative programming.</li>
<li>Most binary operators in <code class="docutils literal"><span class="pre">ndarray</span></code> such as <code class="docutils literal"><span class="pre">+</span></code> and <code class="docutils literal"><span class="pre">></span></code> have
broadcasting enabled by default.</li>
</ul>
</div>
<p>In the rest of this document, we first overview the methods provided by the
<code class="docutils literal"><span class="pre">ndarray.NDArray</span></code> class, and then list other routines provided by the <code class="docutils literal"><span class="pre">ndarray</span></code> package.</p>
<p>The <code class="docutils literal"><span class="pre">ndarray</span></code> package provides several classes:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><code class="xref py py-obj docutils literal"><span class="pre">NDArray</span></code></a></td>
<td>An array object representing a multidimensional, homogeneous array of fixed-size items.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray"><code class="xref py py-obj docutils literal"><span class="pre">sparse.CSRNDArray</span></code></a></td>
<td>A sparse representation of 2D NDArray in the Compressed Sparse Row format.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray"><code class="xref py py-obj docutils literal"><span class="pre">sparse.RowSparseNDArray</span></code></a></td>
<td>A sparse representation of a set of NDArray row slices at given indices.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="the-ndarray-class">
<span id="the-ndarray-class"></span><h2>The <code class="docutils literal"><span class="pre">NDArray</span></code> class<a class="headerlink" href="#the-ndarray-class" title="Permalink to this headline">¶</a></h2>
<div class="section" id="array-attributes">
<span id="array-attributes"></span><h3>Array attributes<a class="headerlink" href="#array-attributes" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.shape" title="mxnet.ndarray.NDArray.shape"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.shape</span></code></a></td>
<td>Tuple of array dimensions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.size" title="mxnet.ndarray.NDArray.size"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.size</span></code></a></td>
<td>Number of elements in the array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.context" title="mxnet.ndarray.NDArray.context"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.context</span></code></a></td>
<td>Device context of the array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.dtype" title="mxnet.ndarray.NDArray.dtype"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.dtype</span></code></a></td>
<td>Data-type of the array’s elements.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.stype" title="mxnet.ndarray.NDArray.stype"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.stype</span></code></a></td>
<td>Storage-type of the array.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="array-conversion">
<span id="array-conversion"></span><h3>Array conversion<a class="headerlink" href="#array-conversion" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.copy" title="mxnet.ndarray.NDArray.copy"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.copy</span></code></a></td>
<td>Makes a copy of this <code class="docutils literal"><span class="pre">NDArray</span></code>, keeping the same context.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.copyto" title="mxnet.ndarray.NDArray.copyto"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.copyto</span></code></a></td>
<td>Copies the value of this array to another array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.as_in_context" title="mxnet.ndarray.NDArray.as_in_context"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.as_in_context</span></code></a></td>
<td>Returns an array on the target device with the same value as this array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.asnumpy" title="mxnet.ndarray.NDArray.asnumpy"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.asnumpy</span></code></a></td>
<td>Returns a <code class="docutils literal"><span class="pre">numpy.ndarray</span></code> object with value copied from this array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.asscalar" title="mxnet.ndarray.NDArray.asscalar"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.asscalar</span></code></a></td>
<td>Returns a scalar whose value is copied from this array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.astype" title="mxnet.ndarray.NDArray.astype"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.astype</span></code></a></td>
<td>Returns a copy of the array after casting to a specified type.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.tostype" title="mxnet.ndarray.NDArray.tostype"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.tostype</span></code></a></td>
<td>Return a copy of the array with chosen storage type.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="array-creation">
<span id="array-creation"></span><h3>Array creation<a class="headerlink" href="#array-creation" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.zeros_like" title="mxnet.ndarray.NDArray.zeros_like"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.zeros_like</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.zeros_like" title="mxnet.ndarray.zeros_like"><code class="xref py py-func docutils literal"><span class="pre">zeros_like()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.ones_like" title="mxnet.ndarray.NDArray.ones_like"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.ones_like</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.ones_like" title="mxnet.ndarray.ones_like"><code class="xref py py-func docutils literal"><span class="pre">ones_like()</span></code></a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="array-change-shape">
<span id="array-change-shape"></span><h3>Array change shape<a class="headerlink" href="#array-change-shape" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.T" title="mxnet.ndarray.NDArray.T"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.T</span></code></a></td>
<td>Returns a copy of the array with axes transposed.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.shape_array" title="mxnet.ndarray.NDArray.shape_array"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.shape_array</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.shape_array" title="mxnet.ndarray.shape_array"><code class="xref py py-func docutils literal"><span class="pre">shape_array()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.size_array" title="mxnet.ndarray.NDArray.size_array"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.size_array</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.size_array" title="mxnet.ndarray.size_array"><code class="xref py py-func docutils literal"><span class="pre">size_array()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.reshape" title="mxnet.ndarray.NDArray.reshape"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.reshape</span></code></a></td>
<td>Returns a <strong>view</strong> of this array with a new shape without altering any data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.reshape_like" title="mxnet.ndarray.NDArray.reshape_like"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.reshape_like</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.reshape_like" title="mxnet.ndarray.reshape_like"><code class="xref py py-func docutils literal"><span class="pre">reshape_like()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.flatten" title="mxnet.ndarray.NDArray.flatten"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.flatten</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.flatten" title="mxnet.ndarray.flatten"><code class="xref py py-func docutils literal"><span class="pre">flatten()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.expand_dims" title="mxnet.ndarray.NDArray.expand_dims"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.expand_dims</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.expand_dims" title="mxnet.ndarray.expand_dims"><code class="xref py py-func docutils literal"><span class="pre">expand_dims()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.split" title="mxnet.ndarray.NDArray.split"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.split</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.split" title="mxnet.ndarray.split"><code class="xref py py-func docutils literal"><span class="pre">split()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.diag" title="mxnet.ndarray.NDArray.diag"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.diag</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.diag" title="mxnet.ndarray.diag"><code class="xref py py-func docutils literal"><span class="pre">diag()</span></code></a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="array-expand-elements">
<span id="array-expand-elements"></span><h3>Array expand elements<a class="headerlink" href="#array-expand-elements" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.broadcast_to" title="mxnet.ndarray.NDArray.broadcast_to"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.broadcast_to</span></code></a></td>
<td>Broadcasts the input array to a new shape.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.broadcast_axes" title="mxnet.ndarray.NDArray.broadcast_axes"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.broadcast_axes</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.broadcast_axes" title="mxnet.ndarray.broadcast_axes"><code class="xref py py-func docutils literal"><span class="pre">broadcast_axes()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.broadcast_like" title="mxnet.ndarray.NDArray.broadcast_like"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.broadcast_like</span></code></a></td>
<td>Broadcasts the input array to the shape of other.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.tile" title="mxnet.ndarray.NDArray.tile"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.tile</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.tile" title="mxnet.ndarray.tile"><code class="xref py py-func docutils literal"><span class="pre">tile()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.pad" title="mxnet.ndarray.NDArray.pad"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.pad</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.pad" title="mxnet.ndarray.pad"><code class="xref py py-func docutils literal"><span class="pre">pad()</span></code></a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="array-rearrange-elements">
<span id="array-rearrange-elements"></span><h3>Array rearrange elements<a class="headerlink" href="#array-rearrange-elements" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.transpose" title="mxnet.ndarray.NDArray.transpose"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.transpose</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.transpose" title="mxnet.ndarray.transpose"><code class="xref py py-func docutils literal"><span class="pre">transpose()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.swapaxes" title="mxnet.ndarray.NDArray.swapaxes"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.swapaxes</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.swapaxes" title="mxnet.ndarray.swapaxes"><code class="xref py py-func docutils literal"><span class="pre">swapaxes()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.flip" title="mxnet.ndarray.NDArray.flip"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.flip</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.flip" title="mxnet.ndarray.flip"><code class="xref py py-func docutils literal"><span class="pre">flip()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.depth_to_space" title="mxnet.ndarray.NDArray.depth_to_space"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.depth_to_space</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.depth_to_space" title="mxnet.ndarray.depth_to_space"><code class="xref py py-func docutils literal"><span class="pre">depth_to_space()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.space_to_depth" title="mxnet.ndarray.NDArray.space_to_depth"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.space_to_depth</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.space_to_depth" title="mxnet.ndarray.space_to_depth"><code class="xref py py-func docutils literal"><span class="pre">space_to_depth()</span></code></a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="array-reduction">
<span id="array-reduction"></span><h3>Array reduction<a class="headerlink" href="#array-reduction" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.sum" title="mxnet.ndarray.NDArray.sum"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.sum</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.sum" title="mxnet.ndarray.sum"><code class="xref py py-func docutils literal"><span class="pre">sum()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.nansum" title="mxnet.ndarray.NDArray.nansum"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.nansum</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.nansum" title="mxnet.ndarray.nansum"><code class="xref py py-func docutils literal"><span class="pre">nansum()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.prod" title="mxnet.ndarray.NDArray.prod"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.prod</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.prod" title="mxnet.ndarray.prod"><code class="xref py py-func docutils literal"><span class="pre">prod()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.nanprod" title="mxnet.ndarray.NDArray.nanprod"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.nanprod</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.nanprod" title="mxnet.ndarray.nanprod"><code class="xref py py-func docutils literal"><span class="pre">nanprod()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.mean" title="mxnet.ndarray.NDArray.mean"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.mean</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.mean" title="mxnet.ndarray.mean"><code class="xref py py-func docutils literal"><span class="pre">mean()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.max" title="mxnet.ndarray.NDArray.max"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.max</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.max" title="mxnet.ndarray.max"><code class="xref py py-func docutils literal"><span class="pre">max()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.min" title="mxnet.ndarray.NDArray.min"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.min</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.min" title="mxnet.ndarray.min"><code class="xref py py-func docutils literal"><span class="pre">min()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.norm" title="mxnet.ndarray.NDArray.norm"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.norm</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.norm" title="mxnet.ndarray.norm"><code class="xref py py-func docutils literal"><span class="pre">norm()</span></code></a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="array-rounding">
<span id="array-rounding"></span><h3>Array rounding<a class="headerlink" href="#array-rounding" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.round" title="mxnet.ndarray.NDArray.round"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.round</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.round" title="mxnet.ndarray.round"><code class="xref py py-func docutils literal"><span class="pre">round()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.rint" title="mxnet.ndarray.NDArray.rint"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.rint</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.rint" title="mxnet.ndarray.rint"><code class="xref py py-func docutils literal"><span class="pre">rint()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.fix" title="mxnet.ndarray.NDArray.fix"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.fix</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.fix" title="mxnet.ndarray.fix"><code class="xref py py-func docutils literal"><span class="pre">fix()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.floor" title="mxnet.ndarray.NDArray.floor"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.floor</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.floor" title="mxnet.ndarray.floor"><code class="xref py py-func docutils literal"><span class="pre">floor()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.ceil" title="mxnet.ndarray.NDArray.ceil"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.ceil</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.ceil" title="mxnet.ndarray.ceil"><code class="xref py py-func docutils literal"><span class="pre">ceil()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.trunc" title="mxnet.ndarray.NDArray.trunc"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.trunc</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.trunc" title="mxnet.ndarray.trunc"><code class="xref py py-func docutils literal"><span class="pre">trunc()</span></code></a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="array-sorting-and-searching">
<span id="array-sorting-and-searching"></span><h3>Array sorting and searching<a class="headerlink" href="#array-sorting-and-searching" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.sort" title="mxnet.ndarray.NDArray.sort"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.sort</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.sort" title="mxnet.ndarray.sort"><code class="xref py py-func docutils literal"><span class="pre">sort()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.argsort" title="mxnet.ndarray.NDArray.argsort"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.argsort</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.argsort" title="mxnet.ndarray.argsort"><code class="xref py py-func docutils literal"><span class="pre">argsort()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.topk" title="mxnet.ndarray.NDArray.topk"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.topk</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.topk" title="mxnet.ndarray.topk"><code class="xref py py-func docutils literal"><span class="pre">topk()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.argmax" title="mxnet.ndarray.NDArray.argmax"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.argmax</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.argmax" title="mxnet.ndarray.argmax"><code class="xref py py-func docutils literal"><span class="pre">argmax()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.argmin" title="mxnet.ndarray.NDArray.argmin"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.argmin</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.argmin" title="mxnet.ndarray.argmin"><code class="xref py py-func docutils literal"><span class="pre">argmin()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.argmax_channel" title="mxnet.ndarray.NDArray.argmax_channel"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.argmax_channel</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.argmax_channel" title="mxnet.ndarray.argmax_channel"><code class="xref py py-func docutils literal"><span class="pre">argmax_channel()</span></code></a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="arithmetic-operations">
<span id="arithmetic-operations"></span><h3>Arithmetic operations<a class="headerlink" href="#arithmetic-operations" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__add__" title="mxnet.ndarray.NDArray.__add__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__add__</span></code></a></td>
<td>x.__add__(y) <=> x+y <=> mx.nd.add(x, y)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__sub__" title="mxnet.ndarray.NDArray.__sub__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__sub__</span></code></a></td>
<td>x.__sub__(y) <=> x-y <=> mx.nd.subtract(x, y)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__rsub__" title="mxnet.ndarray.NDArray.__rsub__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__rsub__</span></code></a></td>
<td>x.__rsub__(y) <=> y-x <=> mx.nd.subtract(y, x)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__neg__" title="mxnet.ndarray.NDArray.__neg__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__neg__</span></code></a></td>
<td>x.__neg__(y) <=> -x</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__mul__" title="mxnet.ndarray.NDArray.__mul__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__mul__</span></code></a></td>
<td>x.__mul__(y) <=> x*y <=> mx.nd.multiply(x, y)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__div__" title="mxnet.ndarray.NDArray.__div__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__div__</span></code></a></td>
<td>x.__div__(y) <=> x/y <=> mx.nd.divide(x, y)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__rdiv__" title="mxnet.ndarray.NDArray.__rdiv__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__rdiv__</span></code></a></td>
<td>x.__rdiv__(y) <=> y/x <=> mx.nd.divide(y, x)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__mod__" title="mxnet.ndarray.NDArray.__mod__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__mod__</span></code></a></td>
<td>x.__mod__(y) <=> x%y <=> mx.nd.modulo(x, y)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__rmod__" title="mxnet.ndarray.NDArray.__rmod__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__rmod__</span></code></a></td>
<td>x.__rmod__(y) <=> y%x <=> mx.nd.modulo(y, x)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__pow__" title="mxnet.ndarray.NDArray.__pow__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__pow__</span></code></a></td>
<td>x.__pow__(y) <=> x**y <=> mx.nd.power(x,y)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="trigonometric-functions">
<span id="trigonometric-functions"></span><h3>Trigonometric functions<a class="headerlink" href="#trigonometric-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.sin" title="mxnet.ndarray.NDArray.sin"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.sin</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.sin" title="mxnet.ndarray.sin"><code class="xref py py-func docutils literal"><span class="pre">sin()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.cos" title="mxnet.ndarray.NDArray.cos"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.cos</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.cos" title="mxnet.ndarray.cos"><code class="xref py py-func docutils literal"><span class="pre">cos()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.tan" title="mxnet.ndarray.NDArray.tan"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.tan</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.tan" title="mxnet.ndarray.tan"><code class="xref py py-func docutils literal"><span class="pre">tan()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.arcsin" title="mxnet.ndarray.NDArray.arcsin"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.arcsin</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.arcsin" title="mxnet.ndarray.arcsin"><code class="xref py py-func docutils literal"><span class="pre">arcsin()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.arccos" title="mxnet.ndarray.NDArray.arccos"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.arccos</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.arccos" title="mxnet.ndarray.arccos"><code class="xref py py-func docutils literal"><span class="pre">arccos()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.arctan" title="mxnet.ndarray.NDArray.arctan"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.arctan</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.arctan" title="mxnet.ndarray.arctan"><code class="xref py py-func docutils literal"><span class="pre">arctan()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.degrees" title="mxnet.ndarray.NDArray.degrees"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.degrees</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.degrees" title="mxnet.ndarray.degrees"><code class="xref py py-func docutils literal"><span class="pre">degrees()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.radians" title="mxnet.ndarray.NDArray.radians"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.radians</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.radians" title="mxnet.ndarray.radians"><code class="xref py py-func docutils literal"><span class="pre">radians()</span></code></a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="hyperbolic-functions">
<span id="hyperbolic-functions"></span><h3>Hyperbolic functions<a class="headerlink" href="#hyperbolic-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.sinh" title="mxnet.ndarray.NDArray.sinh"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.sinh</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.sinh" title="mxnet.ndarray.sinh"><code class="xref py py-func docutils literal"><span class="pre">sinh()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.cosh" title="mxnet.ndarray.NDArray.cosh"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.cosh</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.cosh" title="mxnet.ndarray.cosh"><code class="xref py py-func docutils literal"><span class="pre">cosh()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.tanh" title="mxnet.ndarray.NDArray.tanh"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.tanh</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.tanh" title="mxnet.ndarray.tanh"><code class="xref py py-func docutils literal"><span class="pre">tanh()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.arcsinh" title="mxnet.ndarray.NDArray.arcsinh"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.arcsinh</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.arcsinh" title="mxnet.ndarray.arcsinh"><code class="xref py py-func docutils literal"><span class="pre">arcsinh()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.arccosh" title="mxnet.ndarray.NDArray.arccosh"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.arccosh</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.arccosh" title="mxnet.ndarray.arccosh"><code class="xref py py-func docutils literal"><span class="pre">arccosh()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.arctanh" title="mxnet.ndarray.NDArray.arctanh"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.arctanh</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.arctanh" title="mxnet.ndarray.arctanh"><code class="xref py py-func docutils literal"><span class="pre">arctanh()</span></code></a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="exponents-and-logarithms">
<span id="exponents-and-logarithms"></span><h3>Exponents and logarithms<a class="headerlink" href="#exponents-and-logarithms" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.exp" title="mxnet.ndarray.NDArray.exp"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.exp</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.exp" title="mxnet.ndarray.exp"><code class="xref py py-func docutils literal"><span class="pre">exp()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.expm1" title="mxnet.ndarray.NDArray.expm1"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.expm1</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.expm1" title="mxnet.ndarray.expm1"><code class="xref py py-func docutils literal"><span class="pre">expm1()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.log" title="mxnet.ndarray.NDArray.log"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.log</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.log" title="mxnet.ndarray.log"><code class="xref py py-func docutils literal"><span class="pre">log()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.log10" title="mxnet.ndarray.NDArray.log10"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.log10</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.log10" title="mxnet.ndarray.log10"><code class="xref py py-func docutils literal"><span class="pre">log10()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.log2" title="mxnet.ndarray.NDArray.log2"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.log2</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.log2" title="mxnet.ndarray.log2"><code class="xref py py-func docutils literal"><span class="pre">log2()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.log1p" title="mxnet.ndarray.NDArray.log1p"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.log1p</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.log1p" title="mxnet.ndarray.log1p"><code class="xref py py-func docutils literal"><span class="pre">log1p()</span></code></a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="powers">
<span id="powers"></span><h3>Powers<a class="headerlink" href="#powers" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.sqrt" title="mxnet.ndarray.NDArray.sqrt"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.sqrt</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.sqrt" title="mxnet.ndarray.sqrt"><code class="xref py py-func docutils literal"><span class="pre">sqrt()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.rsqrt" title="mxnet.ndarray.NDArray.rsqrt"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.rsqrt</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.rsqrt" title="mxnet.ndarray.rsqrt"><code class="xref py py-func docutils literal"><span class="pre">rsqrt()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.cbrt" title="mxnet.ndarray.NDArray.cbrt"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.cbrt</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.cbrt" title="mxnet.ndarray.cbrt"><code class="xref py py-func docutils literal"><span class="pre">cbrt()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.rcbrt" title="mxnet.ndarray.NDArray.rcbrt"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.rcbrt</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.rcbrt" title="mxnet.ndarray.rcbrt"><code class="xref py py-func docutils literal"><span class="pre">rcbrt()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.square" title="mxnet.ndarray.NDArray.square"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.square</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.square" title="mxnet.ndarray.square"><code class="xref py py-func docutils literal"><span class="pre">square()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.reciprocal" title="mxnet.ndarray.NDArray.reciprocal"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.reciprocal</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.reciprocal" title="mxnet.ndarray.reciprocal"><code class="xref py py-func docutils literal"><span class="pre">reciprocal()</span></code></a>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="basic-neural-network-functions">
<span id="basic-neural-network-functions"></span><h2>Basic neural network functions<a class="headerlink" href="#basic-neural-network-functions" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.relu" title="mxnet.ndarray.NDArray.relu"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.relu</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.relu" title="mxnet.ndarray.relu"><code class="xref py py-func docutils literal"><span class="pre">relu()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.sigmoid" title="mxnet.ndarray.NDArray.sigmoid"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.sigmoid</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.sigmoid" title="mxnet.ndarray.sigmoid"><code class="xref py py-func docutils literal"><span class="pre">sigmoid()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.softmax" title="mxnet.ndarray.NDArray.softmax"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.softmax</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.softmax" title="mxnet.ndarray.softmax"><code class="xref py py-func docutils literal"><span class="pre">softmax()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.log_softmax" title="mxnet.ndarray.NDArray.log_softmax"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.log_softmax</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.log_softmax" title="mxnet.ndarray.log_softmax"><code class="xref py py-func docutils literal"><span class="pre">log_softmax()</span></code></a>.</td>
</tr>
</tbody>
</table>
<div class="section" id="in-place-arithmetic-operations">
<span id="in-place-arithmetic-operations"></span><h3>In-place arithmetic operations<a class="headerlink" href="#in-place-arithmetic-operations" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__iadd__" title="mxnet.ndarray.NDArray.__iadd__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__iadd__</span></code></a></td>
<td>x.__iadd__(y) <=> x+=y</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__isub__" title="mxnet.ndarray.NDArray.__isub__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__isub__</span></code></a></td>
<td>x.__isub__(y) <=> x-=y</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__imul__" title="mxnet.ndarray.NDArray.__imul__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__imul__</span></code></a></td>
<td>x.__imul__(y) <=> x*=y</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__idiv__" title="mxnet.ndarray.NDArray.__idiv__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__idiv__</span></code></a></td>
<td>x.__rdiv__(y) <=> x/=y</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__imod__" title="mxnet.ndarray.NDArray.__imod__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__imod__</span></code></a></td>
<td>x.__rmod__(y) <=> x%=y</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="comparison-operators">
<span id="comparison-operators"></span><h3>Comparison operators<a class="headerlink" href="#comparison-operators" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__lt__" title="mxnet.ndarray.NDArray.__lt__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__lt__</span></code></a></td>
<td>x.__lt__(y) <=> x<y <=> mx.nd.lesser(x, y)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__le__" title="mxnet.ndarray.NDArray.__le__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__le__</span></code></a></td>
<td>x.__le__(y) <=> x<=y <=> mx.nd.less_equal(x, y)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__gt__" title="mxnet.ndarray.NDArray.__gt__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__gt__</span></code></a></td>
<td>x.__gt__(y) <=> x>y <=> mx.nd.greater(x, y)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__ge__" title="mxnet.ndarray.NDArray.__ge__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__ge__</span></code></a></td>
<td>x.__ge__(y) <=> x>=y <=> mx.nd.greater_equal(x, y)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__eq__" title="mxnet.ndarray.NDArray.__eq__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__eq__</span></code></a></td>
<td>x.__eq__(y) <=> x==y <=> mx.nd.equal(x, y)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__ne__" title="mxnet.ndarray.NDArray.__ne__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__ne__</span></code></a></td>
<td>x.__ne__(y) <=> x!=y <=> mx.nd.not_equal(x, y)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="indexing">
<span id="indexing"></span><h3>Indexing<a class="headerlink" href="#indexing" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__getitem__" title="mxnet.ndarray.NDArray.__getitem__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__getitem__</span></code></a></td>
<td>x.__getitem__(i) <=> x[i]</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.__setitem__" title="mxnet.ndarray.NDArray.__setitem__"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.__setitem__</span></code></a></td>
<td>x.__setitem__(i, y) <=> x[i]=y</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.slice" title="mxnet.ndarray.NDArray.slice"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.slice</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.slice" title="mxnet.ndarray.slice"><code class="xref py py-func docutils literal"><span class="pre">slice()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.slice_axis" title="mxnet.ndarray.NDArray.slice_axis"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.slice_axis</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.slice_axis" title="mxnet.ndarray.slice_axis"><code class="xref py py-func docutils literal"><span class="pre">slice_axis()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.slice_like" title="mxnet.ndarray.NDArray.slice_like"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.slice_like</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.slice_like" title="mxnet.ndarray.slice_like"><code class="xref py py-func docutils literal"><span class="pre">slice_like()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.take" title="mxnet.ndarray.NDArray.take"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.take</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.take" title="mxnet.ndarray.take"><code class="xref py py-func docutils literal"><span class="pre">take()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.one_hot" title="mxnet.ndarray.NDArray.one_hot"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.one_hot</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.one_hot" title="mxnet.ndarray.one_hot"><code class="xref py py-func docutils literal"><span class="pre">one_hot()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.pick" title="mxnet.ndarray.NDArray.pick"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.pick</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.pick" title="mxnet.ndarray.pick"><code class="xref py py-func docutils literal"><span class="pre">pick()</span></code></a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="lazy-evaluation">
<span id="lazy-evaluation"></span><h3>Lazy evaluation<a class="headerlink" href="#lazy-evaluation" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.wait_to_read" title="mxnet.ndarray.NDArray.wait_to_read"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.wait_to_read</span></code></a></td>
<td>Waits until all previous write operations on the current array are finished.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="miscellaneous">
<span id="miscellaneous"></span><h3>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.clip" title="mxnet.ndarray.NDArray.clip"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.clip</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.clip" title="mxnet.ndarray.clip"><code class="xref py py-func docutils literal"><span class="pre">clip()</span></code></a>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.NDArray.sign" title="mxnet.ndarray.NDArray.sign"><code class="xref py py-obj docutils literal"><span class="pre">NDArray.sign</span></code></a></td>
<td>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.sign" title="mxnet.ndarray.sign"><code class="xref py py-func docutils literal"><span class="pre">sign()</span></code></a>.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="array-creation-routines">
<span id="array-creation-routines"></span><h2>Array creation routines<a class="headerlink" href="#array-creation-routines" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><code class="xref py py-obj docutils literal"><span class="pre">array</span></code></a></td>
<td>Creates an array from any object exposing the array interface.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.empty" title="mxnet.ndarray.empty"><code class="xref py py-obj docutils literal"><span class="pre">empty</span></code></a></td>
<td>Returns a new array of given shape and type, without initializing entries.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.zeros" title="mxnet.ndarray.zeros"><code class="xref py py-obj docutils literal"><span class="pre">zeros</span></code></a></td>
<td>Return a new array of given shape and type, filled with zeros.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.zeros_like" title="mxnet.ndarray.zeros_like"><code class="xref py py-obj docutils literal"><span class="pre">zeros_like</span></code></a></td>
<td>Return an array of zeros with the same shape, type and storage type as the input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.ones" title="mxnet.ndarray.ones"><code class="xref py py-obj docutils literal"><span class="pre">ones</span></code></a></td>
<td>Returns a new array filled with all ones, with the given shape and type.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.ones_like" title="mxnet.ndarray.ones_like"><code class="xref py py-obj docutils literal"><span class="pre">ones_like</span></code></a></td>
<td>Return an array of ones with the same shape and type as the input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.full" title="mxnet.ndarray.full"><code class="xref py py-obj docutils literal"><span class="pre">full</span></code></a></td>
<td>Returns a new array of given shape and type, filled with the given value <cite>val</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.arange" title="mxnet.ndarray.arange"><code class="xref py py-obj docutils literal"><span class="pre">arange</span></code></a></td>
<td>Returns evenly spaced values within a given interval.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.diag" title="mxnet.ndarray.diag"><code class="xref py py-obj docutils literal"><span class="pre">diag</span></code></a></td>
<td>Extracts a diagonal or constructs a diagonal array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="sparse.html#mxnet.ndarray.load" title="mxnet.ndarray.load"><code class="xref py py-obj docutils literal"><span class="pre">load</span></code></a></td>
<td>Loads an array from file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="sparse.html#mxnet.ndarray.save" title="mxnet.ndarray.save"><code class="xref py py-obj docutils literal"><span class="pre">save</span></code></a></td>
<td>Saves a list of arrays or a dict of str->array to file.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="array-manipulation-routines">
<span id="array-manipulation-routines"></span><h2>Array manipulation routines<a class="headerlink" href="#array-manipulation-routines" title="Permalink to this headline">¶</a></h2>
<div class="section" id="changing-array-shape-and-type">
<span id="changing-array-shape-and-type"></span><h3>Changing array shape and type<a class="headerlink" href="#changing-array-shape-and-type" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.cast" title="mxnet.ndarray.cast"><code class="xref py py-obj docutils literal"><span class="pre">cast</span></code></a></td>
<td>Casts all elements of the input to a new type.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.shape_array" title="mxnet.ndarray.shape_array"><code class="xref py py-obj docutils literal"><span class="pre">shape_array</span></code></a></td>
<td>Returns a 1D int64 array containing the shape of data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.size_array" title="mxnet.ndarray.size_array"><code class="xref py py-obj docutils literal"><span class="pre">size_array</span></code></a></td>
<td>Returns a 1D int64 array containing the size of data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.reshape" title="mxnet.ndarray.reshape"><code class="xref py py-obj docutils literal"><span class="pre">reshape</span></code></a></td>
<td>Reshapes the input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.reshape_like" title="mxnet.ndarray.reshape_like"><code class="xref py py-obj docutils literal"><span class="pre">reshape_like</span></code></a></td>
<td>Reshape some or all dimensions of <cite>lhs</cite> to have the same shape as some or all dimensions of <cite>rhs</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.flatten" title="mxnet.ndarray.flatten"><code class="xref py py-obj docutils literal"><span class="pre">flatten</span></code></a></td>
<td>Flattens the input array into a 2-D array by collapsing the higher dimensions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.expand_dims" title="mxnet.ndarray.expand_dims"><code class="xref py py-obj docutils literal"><span class="pre">expand_dims</span></code></a></td>
<td>Inserts a new axis of size 1 into the array shape</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="expanding-array-elements">
<span id="expanding-array-elements"></span><h3>Expanding array elements<a class="headerlink" href="#expanding-array-elements" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.broadcast_to" title="mxnet.ndarray.broadcast_to"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_to</span></code></a></td>
<td>Broadcasts the input array to a new shape.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.broadcast_axes" title="mxnet.ndarray.broadcast_axes"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_axes</span></code></a></td>
<td>Broadcasts the input array over particular axes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.broadcast_like" title="mxnet.ndarray.broadcast_like"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_like</span></code></a></td>
<td>Broadcasts lhs to have the same shape as rhs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.repeat" title="mxnet.ndarray.repeat"><code class="xref py py-obj docutils literal"><span class="pre">repeat</span></code></a></td>
<td>Repeats elements of an array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.tile" title="mxnet.ndarray.tile"><code class="xref py py-obj docutils literal"><span class="pre">tile</span></code></a></td>
<td>Repeats the whole array multiple times.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.pad" title="mxnet.ndarray.pad"><code class="xref py py-obj docutils literal"><span class="pre">pad</span></code></a></td>
<td>Pads an input array with a constant or edge values of the array.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="rearranging-elements">
<span id="rearranging-elements"></span><h3>Rearranging elements<a class="headerlink" href="#rearranging-elements" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.transpose" title="mxnet.ndarray.transpose"><code class="xref py py-obj docutils literal"><span class="pre">transpose</span></code></a></td>
<td>Permutes the dimensions of an array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.swapaxes" title="mxnet.ndarray.swapaxes"><code class="xref py py-obj docutils literal"><span class="pre">swapaxes</span></code></a></td>
<td>Interchanges two axes of an array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.flip" title="mxnet.ndarray.flip"><code class="xref py py-obj docutils literal"><span class="pre">flip</span></code></a></td>
<td>Reverses the order of elements along given axis while preserving array shape.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.depth_to_space" title="mxnet.ndarray.depth_to_space"><code class="xref py py-obj docutils literal"><span class="pre">depth_to_space</span></code></a></td>
<td>Rearranges(permutes) data from depth into blocks of spatial data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.space_to_depth" title="mxnet.ndarray.space_to_depth"><code class="xref py py-obj docutils literal"><span class="pre">space_to_depth</span></code></a></td>
<td>Rearranges(permutes) blocks of spatial data into depth.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="joining-and-splitting-arrays">
<span id="joining-and-splitting-arrays"></span><h3>Joining and splitting arrays<a class="headerlink" href="#joining-and-splitting-arrays" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.concat" title="mxnet.ndarray.concat"><code class="xref py py-obj docutils literal"><span class="pre">concat</span></code></a></td>
<td>Joins input arrays along a given axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.split" title="mxnet.ndarray.split"><code class="xref py py-obj docutils literal"><span class="pre">split</span></code></a></td>
<td>Splits an array along a particular axis into multiple sub-arrays.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.stack" title="mxnet.ndarray.stack"><code class="xref py py-obj docutils literal"><span class="pre">stack</span></code></a></td>
<td>Join a sequence of arrays along a new axis.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="indexing-routines">
<span id="indexing-routines"></span><h3>Indexing routines<a class="headerlink" href="#indexing-routines" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.slice" title="mxnet.ndarray.slice"><code class="xref py py-obj docutils literal"><span class="pre">slice</span></code></a></td>
<td>Slices a region of the array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.slice_axis" title="mxnet.ndarray.slice_axis"><code class="xref py py-obj docutils literal"><span class="pre">slice_axis</span></code></a></td>
<td>Slices along a given axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.slice_like" title="mxnet.ndarray.slice_like"><code class="xref py py-obj docutils literal"><span class="pre">slice_like</span></code></a></td>
<td>Slices a region of the array like the shape of another array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.take" title="mxnet.ndarray.take"><code class="xref py py-obj docutils literal"><span class="pre">take</span></code></a></td>
<td>Takes elements from an input array along the given axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.batch_take" title="mxnet.ndarray.batch_take"><code class="xref py py-obj docutils literal"><span class="pre">batch_take</span></code></a></td>
<td>Takes elements from a data batch.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.one_hot" title="mxnet.ndarray.one_hot"><code class="xref py py-obj docutils literal"><span class="pre">one_hot</span></code></a></td>
<td>Returns a one-hot array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.pick" title="mxnet.ndarray.pick"><code class="xref py py-obj docutils literal"><span class="pre">pick</span></code></a></td>
<td>Picks elements from an input array according to the input indices along the given axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.where" title="mxnet.ndarray.where"><code class="xref py py-obj docutils literal"><span class="pre">where</span></code></a></td>
<td>Return the elements, either from x or y, depending on the condition.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.ravel_multi_index" title="mxnet.ndarray.ravel_multi_index"><code class="xref py py-obj docutils literal"><span class="pre">ravel_multi_index</span></code></a></td>
<td>Converts a batch of index arrays into an array of flat indices.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.unravel_index" title="mxnet.ndarray.unravel_index"><code class="xref py py-obj docutils literal"><span class="pre">unravel_index</span></code></a></td>
<td>Converts an array of flat indices into a batch of index arrays.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="mathematical-functions">
<span id="mathematical-functions"></span><h2>Mathematical functions<a class="headerlink" href="#mathematical-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="arithmetic-operations">
<span id="id1"></span><h3>Arithmetic operations<a class="headerlink" href="#arithmetic-operations" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.add" title="mxnet.ndarray.add"><code class="xref py py-obj docutils literal"><span class="pre">add</span></code></a></td>
<td>Returns element-wise sum of the input arrays with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.subtract" title="mxnet.ndarray.subtract"><code class="xref py py-obj docutils literal"><span class="pre">subtract</span></code></a></td>
<td>Returns element-wise difference of the input arrays with broadcasting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.negative" title="mxnet.ndarray.negative"><code class="xref py py-obj docutils literal"><span class="pre">negative</span></code></a></td>
<td>Numerical negative of the argument, element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.multiply" title="mxnet.ndarray.multiply"><code class="xref py py-obj docutils literal"><span class="pre">multiply</span></code></a></td>
<td>Returns element-wise product of the input arrays with broadcasting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.divide" title="mxnet.ndarray.divide"><code class="xref py py-obj docutils literal"><span class="pre">divide</span></code></a></td>
<td>Returns element-wise division of the input arrays with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.modulo" title="mxnet.ndarray.modulo"><code class="xref py py-obj docutils literal"><span class="pre">modulo</span></code></a></td>
<td>Returns element-wise modulo of the input arrays with broadcasting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.dot" title="mxnet.ndarray.dot"><code class="xref py py-obj docutils literal"><span class="pre">dot</span></code></a></td>
<td>Dot product of two arrays.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.batch_dot" title="mxnet.ndarray.batch_dot"><code class="xref py py-obj docutils literal"><span class="pre">batch_dot</span></code></a></td>
<td>Batchwise dot product.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.add_n" title="mxnet.ndarray.add_n"><code class="xref py py-obj docutils literal"><span class="pre">add_n</span></code></a></td>
<td>Adds all input arguments element-wise.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="trigonometric-functions">
<span id="id2"></span><h3>Trigonometric functions<a class="headerlink" href="#trigonometric-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.sin" title="mxnet.ndarray.sin"><code class="xref py py-obj docutils literal"><span class="pre">sin</span></code></a></td>
<td>Computes the element-wise sine of the input array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.cos" title="mxnet.ndarray.cos"><code class="xref py py-obj docutils literal"><span class="pre">cos</span></code></a></td>
<td>Computes the element-wise cosine of the input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.tan" title="mxnet.ndarray.tan"><code class="xref py py-obj docutils literal"><span class="pre">tan</span></code></a></td>
<td>Computes the element-wise tangent of the input array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.arcsin" title="mxnet.ndarray.arcsin"><code class="xref py py-obj docutils literal"><span class="pre">arcsin</span></code></a></td>
<td>Returns element-wise inverse sine of the input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.arccos" title="mxnet.ndarray.arccos"><code class="xref py py-obj docutils literal"><span class="pre">arccos</span></code></a></td>
<td>Returns element-wise inverse cosine of the input array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.arctan" title="mxnet.ndarray.arctan"><code class="xref py py-obj docutils literal"><span class="pre">arctan</span></code></a></td>
<td>Returns element-wise inverse tangent of the input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.broadcast_hypot" title="mxnet.ndarray.broadcast_hypot"><code class="xref py py-obj docutils literal"><span class="pre">broadcast_hypot</span></code></a></td>
<td>Returns the hypotenuse of a right angled triangle, given its “legs” with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.degrees" title="mxnet.ndarray.degrees"><code class="xref py py-obj docutils literal"><span class="pre">degrees</span></code></a></td>
<td>Converts each element of the input array from radians to degrees.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.radians" title="mxnet.ndarray.radians"><code class="xref py py-obj docutils literal"><span class="pre">radians</span></code></a></td>
<td>Converts each element of the input array from degrees to radians.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="hyperbolic-functions">
<span id="id3"></span><h3>Hyperbolic functions<a class="headerlink" href="#hyperbolic-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.sinh" title="mxnet.ndarray.sinh"><code class="xref py py-obj docutils literal"><span class="pre">sinh</span></code></a></td>
<td>Returns the hyperbolic sine of the input array, computed element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.cosh" title="mxnet.ndarray.cosh"><code class="xref py py-obj docutils literal"><span class="pre">cosh</span></code></a></td>
<td>Returns the hyperbolic cosine  of the input array, computed element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.tanh" title="mxnet.ndarray.tanh"><code class="xref py py-obj docutils literal"><span class="pre">tanh</span></code></a></td>
<td>Returns the hyperbolic tangent of the input array, computed element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.arcsinh" title="mxnet.ndarray.arcsinh"><code class="xref py py-obj docutils literal"><span class="pre">arcsinh</span></code></a></td>
<td>Returns the element-wise inverse hyperbolic sine of the input array, computed element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.arccosh" title="mxnet.ndarray.arccosh"><code class="xref py py-obj docutils literal"><span class="pre">arccosh</span></code></a></td>
<td>Returns the element-wise inverse hyperbolic cosine of the input array, computed element-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.arctanh" title="mxnet.ndarray.arctanh"><code class="xref py py-obj docutils literal"><span class="pre">arctanh</span></code></a></td>
<td>Returns the element-wise inverse hyperbolic tangent of the input array, computed element-wise.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="reduce-functions">
<span id="reduce-functions"></span><h3>Reduce functions<a class="headerlink" href="#reduce-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.sum" title="mxnet.ndarray.sum"><code class="xref py py-obj docutils literal"><span class="pre">sum</span></code></a></td>
<td>Computes the sum of array elements over given axes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.nansum" title="mxnet.ndarray.nansum"><code class="xref py py-obj docutils literal"><span class="pre">nansum</span></code></a></td>
<td>Computes the sum of array elements over given axes treating Not a Numbers (<code class="docutils literal"><span class="pre">NaN</span></code>) as zero.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.prod" title="mxnet.ndarray.prod"><code class="xref py py-obj docutils literal"><span class="pre">prod</span></code></a></td>
<td>Computes the product of array elements over given axes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.nanprod" title="mxnet.ndarray.nanprod"><code class="xref py py-obj docutils literal"><span class="pre">nanprod</span></code></a></td>
<td>Computes the product of array elements over given axes treating Not a Numbers (<code class="docutils literal"><span class="pre">NaN</span></code>) as one.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.mean" title="mxnet.ndarray.mean"><code class="xref py py-obj docutils literal"><span class="pre">mean</span></code></a></td>
<td>Computes the mean of array elements over given axes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.max" title="mxnet.ndarray.max"><code class="xref py py-obj docutils literal"><span class="pre">max</span></code></a></td>
<td>Computes the max of array elements over given axes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.min" title="mxnet.ndarray.min"><code class="xref py py-obj docutils literal"><span class="pre">min</span></code></a></td>
<td>Computes the min of array elements over given axes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.norm" title="mxnet.ndarray.norm"><code class="xref py py-obj docutils literal"><span class="pre">norm</span></code></a></td>
<td>Computes the norm on an NDArray.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="rounding">
<span id="rounding"></span><h3>Rounding<a class="headerlink" href="#rounding" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.round" title="mxnet.ndarray.round"><code class="xref py py-obj docutils literal"><span class="pre">round</span></code></a></td>
<td>Returns element-wise rounded value to the nearest integer of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.rint" title="mxnet.ndarray.rint"><code class="xref py py-obj docutils literal"><span class="pre">rint</span></code></a></td>
<td>Returns element-wise rounded value to the nearest integer of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.fix" title="mxnet.ndarray.fix"><code class="xref py py-obj docutils literal"><span class="pre">fix</span></code></a></td>
<td>Returns element-wise rounded value to the nearest integer towards zero of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.floor" title="mxnet.ndarray.floor"><code class="xref py py-obj docutils literal"><span class="pre">floor</span></code></a></td>
<td>Returns element-wise floor of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.ceil" title="mxnet.ndarray.ceil"><code class="xref py py-obj docutils literal"><span class="pre">ceil</span></code></a></td>
<td>Returns element-wise ceiling of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.trunc" title="mxnet.ndarray.trunc"><code class="xref py py-obj docutils literal"><span class="pre">trunc</span></code></a></td>
<td>Return the element-wise truncated value of the input.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="exponents-and-logarithms">
<span id="id4"></span><h3>Exponents and logarithms<a class="headerlink" href="#exponents-and-logarithms" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.exp" title="mxnet.ndarray.exp"><code class="xref py py-obj docutils literal"><span class="pre">exp</span></code></a></td>
<td>Returns element-wise exponential value of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.expm1" title="mxnet.ndarray.expm1"><code class="xref py py-obj docutils literal"><span class="pre">expm1</span></code></a></td>
<td>Returns <code class="docutils literal"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code> computed element-wise on the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.log" title="mxnet.ndarray.log"><code class="xref py py-obj docutils literal"><span class="pre">log</span></code></a></td>
<td>Returns element-wise Natural logarithmic value of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.log10" title="mxnet.ndarray.log10"><code class="xref py py-obj docutils literal"><span class="pre">log10</span></code></a></td>
<td>Returns element-wise Base-10 logarithmic value of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.log2" title="mxnet.ndarray.log2"><code class="xref py py-obj docutils literal"><span class="pre">log2</span></code></a></td>
<td>Returns element-wise Base-2 logarithmic value of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.log1p" title="mxnet.ndarray.log1p"><code class="xref py py-obj docutils literal"><span class="pre">log1p</span></code></a></td>
<td>Returns element-wise <code class="docutils literal"><span class="pre">log(1</span> <span class="pre">+</span> <span class="pre">x)</span></code> value of the input.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="powers">
<span id="id5"></span><h3>Powers<a class="headerlink" href="#powers" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.power" title="mxnet.ndarray.power"><code class="xref py py-obj docutils literal"><span class="pre">power</span></code></a></td>
<td>Returns result of first array elements raised to powers from second array, element-wise with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.sqrt" title="mxnet.ndarray.sqrt"><code class="xref py py-obj docutils literal"><span class="pre">sqrt</span></code></a></td>
<td>Returns element-wise square-root value of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.rsqrt" title="mxnet.ndarray.rsqrt"><code class="xref py py-obj docutils literal"><span class="pre">rsqrt</span></code></a></td>
<td>Returns element-wise inverse square-root value of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.cbrt" title="mxnet.ndarray.cbrt"><code class="xref py py-obj docutils literal"><span class="pre">cbrt</span></code></a></td>
<td>Returns element-wise cube-root value of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.rcbrt" title="mxnet.ndarray.rcbrt"><code class="xref py py-obj docutils literal"><span class="pre">rcbrt</span></code></a></td>
<td>Returns element-wise inverse cube-root value of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.square" title="mxnet.ndarray.square"><code class="xref py py-obj docutils literal"><span class="pre">square</span></code></a></td>
<td>Returns element-wise squared value of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.reciprocal" title="mxnet.ndarray.reciprocal"><code class="xref py py-obj docutils literal"><span class="pre">reciprocal</span></code></a></td>
<td>Returns the reciprocal of the argument, element-wise.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="comparison">
<span id="comparison"></span><h3>Comparison<a class="headerlink" href="#comparison" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.equal" title="mxnet.ndarray.equal"><code class="xref py py-obj docutils literal"><span class="pre">equal</span></code></a></td>
<td>Returns the result of element-wise <strong>equal to</strong> (==) comparison operation with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.not_equal" title="mxnet.ndarray.not_equal"><code class="xref py py-obj docutils literal"><span class="pre">not_equal</span></code></a></td>
<td>Returns the result of element-wise <strong>not equal to</strong> (!=) comparison operation with broadcasting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.greater" title="mxnet.ndarray.greater"><code class="xref py py-obj docutils literal"><span class="pre">greater</span></code></a></td>
<td>Returns the result of element-wise <strong>greater than</strong> (>) comparison operation with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.greater_equal" title="mxnet.ndarray.greater_equal"><code class="xref py py-obj docutils literal"><span class="pre">greater_equal</span></code></a></td>
<td>Returns the result of element-wise <strong>greater than or equal to</strong> (>=) comparison operation with broadcasting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.lesser" title="mxnet.ndarray.lesser"><code class="xref py py-obj docutils literal"><span class="pre">lesser</span></code></a></td>
<td>Returns the result of element-wise <strong>lesser than</strong> (<) comparison operation with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.lesser_equal" title="mxnet.ndarray.lesser_equal"><code class="xref py py-obj docutils literal"><span class="pre">lesser_equal</span></code></a></td>
<td>Returns the result of element-wise <strong>lesser than or equal to</strong> (<=) comparison operation with broadcasting.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="logical-operators">
<span id="logical-operators"></span><h3>Logical operators<a class="headerlink" href="#logical-operators" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.logical_and" title="mxnet.ndarray.logical_and"><code class="xref py py-obj docutils literal"><span class="pre">logical_and</span></code></a></td>
<td>Returns the result of element-wise <strong>logical and</strong> comparison operation with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.logical_or" title="mxnet.ndarray.logical_or"><code class="xref py py-obj docutils literal"><span class="pre">logical_or</span></code></a></td>
<td>Returns the result of element-wise <strong>logical or</strong> comparison operation with broadcasting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.logical_xor" title="mxnet.ndarray.logical_xor"><code class="xref py py-obj docutils literal"><span class="pre">logical_xor</span></code></a></td>
<td>Returns the result of element-wise <strong>logical xor</strong> comparison operation with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.logical_not" title="mxnet.ndarray.logical_not"><code class="xref py py-obj docutils literal"><span class="pre">logical_not</span></code></a></td>
<td>Returns the result of logical NOT (!) function</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="random-sampling">
<span id="random-sampling"></span><h3>Random sampling<a class="headerlink" href="#random-sampling" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="random.html#mxnet.ndarray.random.exponential" title="mxnet.ndarray.random.exponential"><code class="xref py py-obj docutils literal"><span class="pre">random.exponential</span></code></a></td>
<td>Draw samples from an exponential distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="random.html#mxnet.ndarray.random.gamma" title="mxnet.ndarray.random.gamma"><code class="xref py py-obj docutils literal"><span class="pre">random.gamma</span></code></a></td>
<td>Draw random samples from a gamma distribution.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="random.html#mxnet.ndarray.random.generalized_negative_binomial" title="mxnet.ndarray.random.generalized_negative_binomial"><code class="xref py py-obj docutils literal"><span class="pre">random.generalized_negative_binomial</span></code></a></td>
<td>Draw random samples from a generalized negative binomial distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="random.html#mxnet.ndarray.random.multinomial" title="mxnet.ndarray.random.multinomial"><code class="xref py py-obj docutils literal"><span class="pre">random.multinomial</span></code></a></td>
<td>Concurrent sampling from multiple multinomial distributions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="random.html#mxnet.ndarray.random.negative_binomial" title="mxnet.ndarray.random.negative_binomial"><code class="xref py py-obj docutils literal"><span class="pre">random.negative_binomial</span></code></a></td>
<td>Draw random samples from a negative binomial distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="random.html#mxnet.ndarray.random.normal" title="mxnet.ndarray.random.normal"><code class="xref py py-obj docutils literal"><span class="pre">random.normal</span></code></a></td>
<td>Draw random samples from a normal (Gaussian) distribution.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="random.html#mxnet.ndarray.random.poisson" title="mxnet.ndarray.random.poisson"><code class="xref py py-obj docutils literal"><span class="pre">random.poisson</span></code></a></td>
<td>Draw random samples from a Poisson distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="random.html#mxnet.ndarray.random.randint" title="mxnet.ndarray.random.randint"><code class="xref py py-obj docutils literal"><span class="pre">random.randint</span></code></a></td>
<td>Draw random samples from a discrete uniform distribution.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="random.html#mxnet.ndarray.random.randn" title="mxnet.ndarray.random.randn"><code class="xref py py-obj docutils literal"><span class="pre">random.randn</span></code></a></td>
<td>Draw random samples from a normal (Gaussian) distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="random.html#mxnet.ndarray.random.shuffle" title="mxnet.ndarray.random.shuffle"><code class="xref py py-obj docutils literal"><span class="pre">random.shuffle</span></code></a></td>
<td>Shuffle the elements randomly.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="random.html#mxnet.ndarray.random.uniform" title="mxnet.ndarray.random.uniform"><code class="xref py py-obj docutils literal"><span class="pre">random.uniform</span></code></a></td>
<td>Draw random samples from a uniform distribution.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../symbol/random.html#mxnet.random.seed" title="mxnet.random.seed"><code class="xref py py-obj docutils literal"><span class="pre">mxnet.random.seed</span></code></a></td>
<td>Seeds the random number generators in MXNet.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sorting-and-searching">
<span id="sorting-and-searching"></span><h3>Sorting and searching<a class="headerlink" href="#sorting-and-searching" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.sort" title="mxnet.ndarray.sort"><code class="xref py py-obj docutils literal"><span class="pre">sort</span></code></a></td>
<td>Returns a sorted copy of an input array along the given axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.topk" title="mxnet.ndarray.topk"><code class="xref py py-obj docutils literal"><span class="pre">topk</span></code></a></td>
<td>Returns the top <em>k</em> elements in an input array along the given axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.argsort" title="mxnet.ndarray.argsort"><code class="xref py py-obj docutils literal"><span class="pre">argsort</span></code></a></td>
<td>Returns the indices that would sort an input array along the given axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.argmax" title="mxnet.ndarray.argmax"><code class="xref py py-obj docutils literal"><span class="pre">argmax</span></code></a></td>
<td>Returns indices of the maximum values along an axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.argmin" title="mxnet.ndarray.argmin"><code class="xref py py-obj docutils literal"><span class="pre">argmin</span></code></a></td>
<td>Returns indices of the minimum values along an axis.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sequence-operation">
<span id="sequence-operation"></span><h3>Sequence operation<a class="headerlink" href="#sequence-operation" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.SequenceLast" title="mxnet.ndarray.SequenceLast"><code class="xref py py-obj docutils literal"><span class="pre">SequenceLast</span></code></a></td>
<td>Takes the last element of a sequence.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.SequenceMask" title="mxnet.ndarray.SequenceMask"><code class="xref py py-obj docutils literal"><span class="pre">SequenceMask</span></code></a></td>
<td>Sets all elements outside the sequence to a constant value.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.SequenceReverse" title="mxnet.ndarray.SequenceReverse"><code class="xref py py-obj docutils literal"><span class="pre">SequenceReverse</span></code></a></td>
<td>Reverses the elements of each sequence.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="miscellaneous">
<span id="id6"></span><h3>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.maximum" title="mxnet.ndarray.maximum"><code class="xref py py-obj docutils literal"><span class="pre">maximum</span></code></a></td>
<td>Returns element-wise maximum of the input arrays with broadcasting.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.minimum" title="mxnet.ndarray.minimum"><code class="xref py py-obj docutils literal"><span class="pre">minimum</span></code></a></td>
<td>Returns element-wise minimum of the input arrays with broadcasting.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.clip" title="mxnet.ndarray.clip"><code class="xref py py-obj docutils literal"><span class="pre">clip</span></code></a></td>
<td>Clips (limits) the values in an array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.abs" title="mxnet.ndarray.abs"><code class="xref py py-obj docutils literal"><span class="pre">abs</span></code></a></td>
<td>Returns element-wise absolute value of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.sign" title="mxnet.ndarray.sign"><code class="xref py py-obj docutils literal"><span class="pre">sign</span></code></a></td>
<td>Returns element-wise sign of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.gamma" title="mxnet.ndarray.gamma"><code class="xref py py-obj docutils literal"><span class="pre">gamma</span></code></a></td>
<td>Returns the gamma function (extension of the factorial function to the reals), computed element-wise on the input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.gammaln" title="mxnet.ndarray.gammaln"><code class="xref py py-obj docutils literal"><span class="pre">gammaln</span></code></a></td>
<td>Returns element-wise log of the absolute value of the gamma function of the input.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="neural-network">
<span id="neural-network"></span><h2>Neural network<a class="headerlink" href="#neural-network" title="Permalink to this headline">¶</a></h2>
<div class="section" id="basic">
<span id="basic"></span><h3>Basic<a class="headerlink" href="#basic" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.FullyConnected" title="mxnet.ndarray.FullyConnected"><code class="xref py py-obj docutils literal"><span class="pre">FullyConnected</span></code></a></td>
<td>Applies a linear transformation: <span class="math">\(Y = XW^T + b\)</span>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.Convolution" title="mxnet.ndarray.Convolution"><code class="xref py py-obj docutils literal"><span class="pre">Convolution</span></code></a></td>
<td>Compute <em>N</em>-D convolution on <em>(N+2)</em>-D input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.Activation" title="mxnet.ndarray.Activation"><code class="xref py py-obj docutils literal"><span class="pre">Activation</span></code></a></td>
<td>Applies an activation function element-wise to the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.BatchNorm" title="mxnet.ndarray.BatchNorm"><code class="xref py py-obj docutils literal"><span class="pre">BatchNorm</span></code></a></td>
<td>Batch normalization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.Pooling" title="mxnet.ndarray.Pooling"><code class="xref py py-obj docutils literal"><span class="pre">Pooling</span></code></a></td>
<td>Performs pooling on the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.SoftmaxOutput" title="mxnet.ndarray.SoftmaxOutput"><code class="xref py py-obj docutils literal"><span class="pre">SoftmaxOutput</span></code></a></td>
<td>Computes the gradient of cross entropy loss with respect to softmax output.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.softmax" title="mxnet.ndarray.softmax"><code class="xref py py-obj docutils literal"><span class="pre">softmax</span></code></a></td>
<td>Applies the softmax function.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.log_softmax" title="mxnet.ndarray.log_softmax"><code class="xref py py-obj docutils literal"><span class="pre">log_softmax</span></code></a></td>
<td>Computes the log softmax of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.relu" title="mxnet.ndarray.relu"><code class="xref py py-obj docutils literal"><span class="pre">relu</span></code></a></td>
<td>Computes rectified linear activation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.sigmoid" title="mxnet.ndarray.sigmoid"><code class="xref py py-obj docutils literal"><span class="pre">sigmoid</span></code></a></td>
<td>Computes sigmoid of x element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.erf" title="mxnet.ndarray.erf"><code class="xref py py-obj docutils literal"><span class="pre">erf</span></code></a></td>
<td>Returns element-wise gauss error function of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.erfinv" title="mxnet.ndarray.erfinv"><code class="xref py py-obj docutils literal"><span class="pre">erfinv</span></code></a></td>
<td>Returns element-wise inverse gauss error function of the input.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="more">
<span id="more"></span><h3>More<a class="headerlink" href="#more" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%"/>
<col width="90%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.Correlation" title="mxnet.ndarray.Correlation"><code class="xref py py-obj docutils literal"><span class="pre">Correlation</span></code></a></td>
<td>Applies correlation to inputs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.Deconvolution" title="mxnet.ndarray.Deconvolution"><code class="xref py py-obj docutils literal"><span class="pre">Deconvolution</span></code></a></td>
<td>Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.RNN" title="mxnet.ndarray.RNN"><code class="xref py py-obj docutils literal"><span class="pre">RNN</span></code></a></td>
<td>Applies recurrent layers to input data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.Embedding" title="mxnet.ndarray.Embedding"><code class="xref py py-obj docutils literal"><span class="pre">Embedding</span></code></a></td>
<td>Maps integer indices to vector representations (embeddings).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.LeakyReLU" title="mxnet.ndarray.LeakyReLU"><code class="xref py py-obj docutils literal"><span class="pre">LeakyReLU</span></code></a></td>
<td>Applies Leaky rectified linear unit activation element-wise to the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.InstanceNorm" title="mxnet.ndarray.InstanceNorm"><code class="xref py py-obj docutils literal"><span class="pre">InstanceNorm</span></code></a></td>
<td>Applies instance normalization to the n-dimensional input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.LayerNorm" title="mxnet.ndarray.LayerNorm"><code class="xref py py-obj docutils literal"><span class="pre">LayerNorm</span></code></a></td>
<td>Layer normalization.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.L2Normalization" title="mxnet.ndarray.L2Normalization"><code class="xref py py-obj docutils literal"><span class="pre">L2Normalization</span></code></a></td>
<td>Normalize the input array using the L2 norm.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.LRN" title="mxnet.ndarray.LRN"><code class="xref py py-obj docutils literal"><span class="pre">LRN</span></code></a></td>
<td>Applies local response normalization to the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.ROIPooling" title="mxnet.ndarray.ROIPooling"><code class="xref py py-obj docutils literal"><span class="pre">ROIPooling</span></code></a></td>
<td>Performs region of interest(ROI) pooling on the input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.SoftmaxActivation" title="mxnet.ndarray.SoftmaxActivation"><code class="xref py py-obj docutils literal"><span class="pre">SoftmaxActivation</span></code></a></td>
<td>Applies softmax activation to input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.Dropout" title="mxnet.ndarray.Dropout"><code class="xref py py-obj docutils literal"><span class="pre">Dropout</span></code></a></td>
<td>Applies dropout operation to input array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.BilinearSampler" title="mxnet.ndarray.BilinearSampler"><code class="xref py py-obj docutils literal"><span class="pre">BilinearSampler</span></code></a></td>
<td>Applies bilinear sampling to input feature map.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.GridGenerator" title="mxnet.ndarray.GridGenerator"><code class="xref py py-obj docutils literal"><span class="pre">GridGenerator</span></code></a></td>
<td>Generates 2D sampling grid for bilinear sampling.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.UpSampling" title="mxnet.ndarray.UpSampling"><code class="xref py py-obj docutils literal"><span class="pre">UpSampling</span></code></a></td>
<td>Upsamples the given input data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.SpatialTransformer" title="mxnet.ndarray.SpatialTransformer"><code class="xref py py-obj docutils literal"><span class="pre">SpatialTransformer</span></code></a></td>
<td>Applies a spatial transformer to input feature map.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.LinearRegressionOutput" title="mxnet.ndarray.LinearRegressionOutput"><code class="xref py py-obj docutils literal"><span class="pre">LinearRegressionOutput</span></code></a></td>
<td>Computes and optimizes for squared loss during backward propagation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.LogisticRegressionOutput" title="mxnet.ndarray.LogisticRegressionOutput"><code class="xref py py-obj docutils literal"><span class="pre">LogisticRegressionOutput</span></code></a></td>
<td>Applies a logistic function to the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.MAERegressionOutput" title="mxnet.ndarray.MAERegressionOutput"><code class="xref py py-obj docutils literal"><span class="pre">MAERegressionOutput</span></code></a></td>
<td>Computes mean absolute error of the input.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.SVMOutput" title="mxnet.ndarray.SVMOutput"><code class="xref py py-obj docutils literal"><span class="pre">SVMOutput</span></code></a></td>
<td>Computes support vector machine based transformation of the input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.softmax_cross_entropy" title="mxnet.ndarray.softmax_cross_entropy"><code class="xref py py-obj docutils literal"><span class="pre">softmax_cross_entropy</span></code></a></td>
<td>Calculate cross entropy of softmax output and one-hot label.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.smooth_l1" title="mxnet.ndarray.smooth_l1"><code class="xref py py-obj docutils literal"><span class="pre">smooth_l1</span></code></a></td>
<td>Calculate Smooth L1 Loss(lhs, scalar) by summing</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.IdentityAttachKLSparseReg" title="mxnet.ndarray.IdentityAttachKLSparseReg"><code class="xref py py-obj docutils literal"><span class="pre">IdentityAttachKLSparseReg</span></code></a></td>
<td>Apply a sparse regularization to the output a sigmoid activation function.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.MakeLoss" title="mxnet.ndarray.MakeLoss"><code class="xref py py-obj docutils literal"><span class="pre">MakeLoss</span></code></a></td>
<td>Make your own loss function in network construction.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mxnet.ndarray.BlockGrad" title="mxnet.ndarray.BlockGrad"><code class="xref py py-obj docutils literal"><span class="pre">BlockGrad</span></code></a></td>
<td>Stops gradient computation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mxnet.ndarray.Custom" title="mxnet.ndarray.Custom"><code class="xref py py-obj docutils literal"><span class="pre">Custom</span></code></a></td>
<td>Apply a custom operator implemented in a frontend language (like Python).</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="api-reference">
<span id="api-reference"></span><h2>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h2>
<script src="../../../_static/js/auto_module_index.js" type="text/javascript"></script><dl class="class">
<dt id="mxnet.ndarray.NDArray">
<em class="property">class </em><code class="descclassname">mxnet.ndarray.</code><code class="descname">NDArray</code><span class="sig-paren">(</span><em>handle</em>, <em>writable=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray" title="Permalink to this definition">¶</a></dt>
<dd><p>An array object representing a multidimensional, homogeneous array of
fixed-size items.</p>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__repr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string representation of the array.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__add__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__add__(y) <=> x+y <=> mx.nd.add(x, y)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__iadd__">
<code class="descname">__iadd__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__iadd__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__iadd__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__iadd__(y) <=> x+=y</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__sub__">
<code class="descname">__sub__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__sub__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__sub__(y) <=> x-y <=> mx.nd.subtract(x, y)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__isub__">
<code class="descname">__isub__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__isub__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__isub__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__isub__(y) <=> x-=y</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__rsub__">
<code class="descname">__rsub__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__rsub__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__rsub__(y) <=> y-x <=> mx.nd.subtract(y, x)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__mul__">
<code class="descname">__mul__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__mul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__mul__(y) <=> x*y <=> mx.nd.multiply(x, y)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__neg__">
<code class="descname">__neg__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__neg__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__neg__(y) <=> -x</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__imul__">
<code class="descname">__imul__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__imul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__imul__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__imul__(y) <=> x*=y</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__div__">
<code class="descname">__div__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__div__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__div__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__div__(y) <=> x/y <=> mx.nd.divide(x, y)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__rdiv__">
<code class="descname">__rdiv__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__rdiv__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__rdiv__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__rdiv__(y) <=> y/x <=> mx.nd.divide(y, x)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__idiv__">
<code class="descname">__idiv__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__idiv__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__idiv__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__rdiv__(y) <=> x/=y</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__mod__">
<code class="descname">__mod__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__mod__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__mod__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__mod__(y) <=> x%y <=> mx.nd.modulo(x, y)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__rmod__">
<code class="descname">__rmod__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__rmod__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__rmod__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__rmod__(y) <=> y%x <=> mx.nd.modulo(y, x)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__imod__">
<code class="descname">__imod__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__imod__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__imod__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__rmod__(y) <=> x%=y</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__pow__">
<code class="descname">__pow__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__pow__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__pow__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__pow__(y) <=> x**y <=> mx.nd.power(x,y)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__rpow__">
<code class="descname">__rpow__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__rpow__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__rpow__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__pow__(y) <=> y**x <=> mx.nd.power(y,x)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__eq__">
<code class="descname">__eq__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__eq__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__eq__(y) <=> x==y <=> mx.nd.equal(x, y)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__hash__">
<code class="descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__hash__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default hash function.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__ne__">
<code class="descname">__ne__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__ne__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__ne__(y) <=> x!=y <=> mx.nd.not_equal(x, y)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__gt__">
<code class="descname">__gt__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__gt__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__gt__(y) <=> x>y <=> mx.nd.greater(x, y)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__ge__">
<code class="descname">__ge__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__ge__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__ge__(y) <=> x>=y <=> mx.nd.greater_equal(x, y)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__lt__">
<code class="descname">__lt__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__lt__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__lt__(y) <=> x<y <=> mx.nd.lesser(x, y)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__le__">
<code class="descname">__le__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__le__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__le__(y) <=> x<=y <=> mx.nd.less_equal(x, y)</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__len__">
<code class="descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__len__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of element along the first axis.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__setitem__">
<code class="descname">__setitem__</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__setitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__setitem__(i, y) <=> x[i]=y</p>
<p>Sets value to self[key]. This functions supports advanced indexing defined in the following reference with
some restrictions.</p>
<p><a class="reference external" href="https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html#combining-advanced-and-basic-indexing">https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html#combining-advanced-and-basic-indexing</a></p>
<ul class="simple">
<li>If key is a list type, only a list of integers is supported, e.g. key=[1, 2] is supported,
while not for key=[[1, 2]].</li>
<li>Ellipsis (...) and np.newaxis are not supported.</li>
<li>Boolean array indexing is not supported.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>int</em><em>, </em><a class="reference internal" href="#mxnet.ndarray.slice" title="mxnet.ndarray.slice"><em>mxnet.ndarray.slice</em></a><em>, </em><em>list</em><em>, </em><em>np.ndarray</em><em>, </em><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, or </em><em>tuple of all previous types</em>) – The indexing key.</li>
<li><strong>value</strong> (<em>scalar</em><em> or </em><em>array-like object that can be broadcast to the shape of self</em><em>[</em><em>key</em><em>]</em>) – The value to set.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  2.,  1.],</span>
<span class="go">       [ 1.,  2.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  2.,  1.],</span>
<span class="go">       [ 1.,  3.,  3.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  2.,  1.],</span>
<span class="go">       [ 0.,  0.,  3.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  2.,  1.],</span>
<span class="go">       [ 0.,  0.,  4.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  5.,  5.],</span>
<span class="go">       [ 0.,  0.,  4.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 6.,  5.,  5.],</span>
<span class="go">       [ 6.,  0.,  4.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__getitem__(i) <=> x[i]</p>
<p>Returns a sliced view of this array if the elements fetched are contiguous in memory;
otherwise, returns a newly created NDArray.
This functions supports advanced indexing defined in the following reference with
some restrictions.</p>
<p><a class="reference external" href="https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html#combining-advanced-and-basic-indexing">https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html#combining-advanced-and-basic-indexing</a></p>
<ul class="simple">
<li>If key is a list type, only a list of integers is supported, e.g. key=[1, 2] is supported,
while not for key=[[1, 2]].</li>
<li>Ellipsis (...) and np.newaxis are not supported.</li>
<li>Boolean array indexing is not supported.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>int</em><em>, </em><a class="reference internal" href="#mxnet.ndarray.slice" title="mxnet.ndarray.slice"><em>mxnet.ndarray.slice</em></a><em>, </em><em>list</em><em>, </em><em>np.ndarray</em><em>, </em><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, or </em><em>tuple of all previous types</em>) – Indexing key.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4.,  5.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 3.,  4.,  5.], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">>>> </span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 2.,  2.,  2.],</span>
<span class="go">       [ 3.,  4.,  5.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'int32'</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="go">[[[0 1]</span>
<span class="go">  [2 3]]</span>
<span class="go"> [[4 5]</span>
<span class="go">  [6 7]]]</span>
<span class="gp">>>> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="go">[[[4 5]</span>
<span class="go">  [6 7]]]</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'int32'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">y</span><span class="p">]</span>
<span class="go">[[[4 5]</span>
<span class="go">  [6 7]]]</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'int32'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">y</span><span class="p">]</span>
<span class="go">[[[4 5]</span>
<span class="go">  [6 7]]]</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.reshape">
<code class="descname">reshape</code><span class="sig-paren">(</span><em>*shape</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.reshape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <strong>view</strong> of this array with a new shape without altering any data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>shape</strong> (<em>tuple of int</em><em>, or </em><em>n ints</em>) – <p>The new shape should not change the array size, namely
<code class="docutils literal"><span class="pre">np.prod(new_shape)</span></code> should be equal to <code class="docutils literal"><span class="pre">np.prod(self.shape)</span></code>.
Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}.
The significance of each is explained below:</p>
<ul>
<li><code class="docutils literal"><span class="pre">0</span></code>  copy this dimension from the input to the output shape.<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><code class="docutils literal"><span class="pre">-1</span></code> infers the dimension of the output shape by using the remainder of the
input dimensions keeping the size of the new array same as that of the input array.
At most one dimension of shape can be -1.<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">24</span><span class="p">,)</span>
</pre></div>
</div>
</li>
<li><code class="docutils literal"><span class="pre">-2</span></code> copy all/remainder of the input dimensions to the output shape.<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><code class="docutils literal"><span class="pre">-3</span></code> use the product of two consecutive dimensions of the input shape as the
output dimension.<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">12</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><code class="docutils literal"><span class="pre">-4</span></code> split one dimension of the input into two dimensions passed subsequent to
-4 in shape (can contain -1).<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li>If the argument <cite>reverse</cite> is set to 1, then the special values are inferred from right
to left.<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">without</span> <span class="n">reverse</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="k">for</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="n">would</span> <span class="n">be</span>                 <span class="p">(</span><span class="mi">40</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span>
<span class="o">-</span> <span class="k">with</span> <span class="n">reverse</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output</span> <span class="n">shape</span> <span class="n">will</span> <span class="n">be</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><strong>reverse</strong> (<em>bool</em><em>, </em><em>default False</em>) – If true then the special values are inferred from right to left. Only supported as
keyword argument.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An array with desired shape that shares data with this array.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4.,  5.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.],</span>
<span class="go">       [ 2.,  3.],</span>
<span class="go">       [ 4.,  5.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.],</span>
<span class="go">       [ 2.,  3.],</span>
<span class="go">       [ 4.,  5.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.],</span>
<span class="go">       [ 2.,  3.],</span>
<span class="go">       [ 4.,  5.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 0.  1.  2.  3.  4.  5.], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[-1., -1., -1.],</span>
<span class="go">       [-1., -1., -1.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.reshape_like">
<code class="descname">reshape_like</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.reshape_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.reshape_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.reshape_like" title="mxnet.ndarray.reshape_like"><code class="xref py py-func docutils literal"><span class="pre">reshape_like()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.reshape_like" title="mxnet.ndarray.reshape_like"><code class="xref py py-func docutils literal"><span class="pre">reshape_like()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.zeros_like">
<code class="descname">zeros_like</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.zeros_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.zeros_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.zeros_like" title="mxnet.ndarray.zeros_like"><code class="xref py py-func docutils literal"><span class="pre">zeros_like()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.zeros_like" title="mxnet.ndarray.zeros_like"><code class="xref py py-func docutils literal"><span class="pre">zeros_like()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.ones_like">
<code class="descname">ones_like</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.ones_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.ones_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.ones_like" title="mxnet.ndarray.ones_like"><code class="xref py py-func docutils literal"><span class="pre">ones_like()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.ones_like" title="mxnet.ndarray.ones_like"><code class="xref py py-func docutils literal"><span class="pre">ones_like()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.broadcast_axes">
<code class="descname">broadcast_axes</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.broadcast_axes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.broadcast_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.broadcast_axes" title="mxnet.ndarray.broadcast_axes"><code class="xref py py-func docutils literal"><span class="pre">broadcast_axes()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.broadcast_axes" title="mxnet.ndarray.broadcast_axes"><code class="xref py py-func docutils literal"><span class="pre">broadcast_axes()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.repeat">
<code class="descname">repeat</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.repeat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.repeat" title="mxnet.ndarray.repeat"><code class="xref py py-func docutils literal"><span class="pre">repeat()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.repeat" title="mxnet.ndarray.repeat"><code class="xref py py-func docutils literal"><span class="pre">repeat()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.pad">
<code class="descname">pad</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.pad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.pad" title="mxnet.ndarray.pad"><code class="xref py py-func docutils literal"><span class="pre">pad()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.pad" title="mxnet.ndarray.pad"><code class="xref py py-func docutils literal"><span class="pre">pad()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.swapaxes">
<code class="descname">swapaxes</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.swapaxes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.swapaxes" title="mxnet.ndarray.swapaxes"><code class="xref py py-func docutils literal"><span class="pre">swapaxes()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.swapaxes" title="mxnet.ndarray.swapaxes"><code class="xref py py-func docutils literal"><span class="pre">swapaxes()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.split">
<code class="descname">split</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.split" title="mxnet.ndarray.split"><code class="xref py py-func docutils literal"><span class="pre">split()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.split" title="mxnet.ndarray.split"><code class="xref py py-func docutils literal"><span class="pre">split()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.split_v2">
<code class="descname">split_v2</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.split_v2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.split_v2" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.split_v2" title="mxnet.ndarray.split_v2"><code class="xref py py-func docutils literal"><span class="pre">split_v2()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.split_v2" title="mxnet.ndarray.split_v2"><code class="xref py py-func docutils literal"><span class="pre">split_v2()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.slice">
<code class="descname">slice</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.slice" title="mxnet.ndarray.slice"><code class="xref py py-func docutils literal"><span class="pre">slice()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.slice" title="mxnet.ndarray.slice"><code class="xref py py-func docutils literal"><span class="pre">slice()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.slice_axis">
<code class="descname">slice_axis</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.slice_axis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.slice_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.slice_axis" title="mxnet.ndarray.slice_axis"><code class="xref py py-func docutils literal"><span class="pre">slice_axis()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.slice_axis" title="mxnet.ndarray.slice_axis"><code class="xref py py-func docutils literal"><span class="pre">slice_axis()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.slice_like">
<code class="descname">slice_like</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.slice_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.slice_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.slice_like" title="mxnet.ndarray.slice_like"><code class="xref py py-func docutils literal"><span class="pre">slice_like()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.slice_like" title="mxnet.ndarray.slice_like"><code class="xref py py-func docutils literal"><span class="pre">slice_like()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.take">
<code class="descname">take</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.take"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.take" title="mxnet.ndarray.take"><code class="xref py py-func docutils literal"><span class="pre">take()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.take" title="mxnet.ndarray.take"><code class="xref py py-func docutils literal"><span class="pre">take()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.one_hot">
<code class="descname">one_hot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.one_hot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.one_hot" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.one_hot" title="mxnet.ndarray.one_hot"><code class="xref py py-func docutils literal"><span class="pre">one_hot()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.one_hot" title="mxnet.ndarray.one_hot"><code class="xref py py-func docutils literal"><span class="pre">one_hot()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.pick">
<code class="descname">pick</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.pick"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.pick" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.pick" title="mxnet.ndarray.pick"><code class="xref py py-func docutils literal"><span class="pre">pick()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.pick" title="mxnet.ndarray.pick"><code class="xref py py-func docutils literal"><span class="pre">pick()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.sort" title="mxnet.ndarray.sort"><code class="xref py py-func docutils literal"><span class="pre">sort()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.sort" title="mxnet.ndarray.sort"><code class="xref py py-func docutils literal"><span class="pre">sort()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.topk">
<code class="descname">topk</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.topk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.topk" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.topk" title="mxnet.ndarray.topk"><code class="xref py py-func docutils literal"><span class="pre">topk()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.topk" title="mxnet.ndarray.topk"><code class="xref py py-func docutils literal"><span class="pre">topk()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.argsort">
<code class="descname">argsort</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.argsort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.argsort" title="mxnet.ndarray.argsort"><code class="xref py py-func docutils literal"><span class="pre">argsort()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.argsort" title="mxnet.ndarray.argsort"><code class="xref py py-func docutils literal"><span class="pre">argsort()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.argmax">
<code class="descname">argmax</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.argmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.argmax" title="mxnet.ndarray.argmax"><code class="xref py py-func docutils literal"><span class="pre">argmax()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.argmax" title="mxnet.ndarray.argmax"><code class="xref py py-func docutils literal"><span class="pre">argmax()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.argmax_channel">
<code class="descname">argmax_channel</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.argmax_channel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.argmax_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.argmax_channel" title="mxnet.ndarray.argmax_channel"><code class="xref py py-func docutils literal"><span class="pre">argmax_channel()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.argmax_channel" title="mxnet.ndarray.argmax_channel"><code class="xref py py-func docutils literal"><span class="pre">argmax_channel()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.argmin">
<code class="descname">argmin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.argmin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.argmin" title="mxnet.ndarray.argmin"><code class="xref py py-func docutils literal"><span class="pre">argmin()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.argmin" title="mxnet.ndarray.argmin"><code class="xref py py-func docutils literal"><span class="pre">argmin()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.clip">
<code class="descname">clip</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.clip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.clip" title="mxnet.ndarray.clip"><code class="xref py py-func docutils literal"><span class="pre">clip()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.clip" title="mxnet.ndarray.clip"><code class="xref py py-func docutils literal"><span class="pre">clip()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.abs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.abs" title="mxnet.ndarray.abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.abs" title="mxnet.ndarray.abs"><code class="xref py py-func docutils literal"><span class="pre">abs()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.sign">
<code class="descname">sign</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.sign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.sign" title="mxnet.ndarray.sign"><code class="xref py py-func docutils literal"><span class="pre">sign()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.sign" title="mxnet.ndarray.sign"><code class="xref py py-func docutils literal"><span class="pre">sign()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.flatten">
<code class="descname">flatten</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.flatten"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.flatten" title="mxnet.ndarray.flatten"><code class="xref py py-func docutils literal"><span class="pre">flatten()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.flatten" title="mxnet.ndarray.flatten"><code class="xref py py-func docutils literal"><span class="pre">flatten()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.shape_array">
<code class="descname">shape_array</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.shape_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.shape_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.shape_array" title="mxnet.ndarray.shape_array"><code class="xref py py-func docutils literal"><span class="pre">shape_array()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.shape_array" title="mxnet.ndarray.shape_array"><code class="xref py py-func docutils literal"><span class="pre">shape_array()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.size_array">
<code class="descname">size_array</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.size_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.size_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.size_array" title="mxnet.ndarray.size_array"><code class="xref py py-func docutils literal"><span class="pre">size_array()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.size_array" title="mxnet.ndarray.size_array"><code class="xref py py-func docutils literal"><span class="pre">size_array()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.expand_dims">
<code class="descname">expand_dims</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.expand_dims"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.expand_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.expand_dims" title="mxnet.ndarray.expand_dims"><code class="xref py py-func docutils literal"><span class="pre">expand_dims()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.expand_dims" title="mxnet.ndarray.expand_dims"><code class="xref py py-func docutils literal"><span class="pre">expand_dims()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.tile">
<code class="descname">tile</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.tile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.tile" title="mxnet.ndarray.tile"><code class="xref py py-func docutils literal"><span class="pre">tile()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.tile" title="mxnet.ndarray.tile"><code class="xref py py-func docutils literal"><span class="pre">tile()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.transpose" title="mxnet.ndarray.transpose"><code class="xref py py-func docutils literal"><span class="pre">transpose()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.transpose" title="mxnet.ndarray.transpose"><code class="xref py py-func docutils literal"><span class="pre">transpose()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.flip">
<code class="descname">flip</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.flip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.flip" title="mxnet.ndarray.flip"><code class="xref py py-func docutils literal"><span class="pre">flip()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.flip" title="mxnet.ndarray.flip"><code class="xref py py-func docutils literal"><span class="pre">flip()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.depth_to_space">
<code class="descname">depth_to_space</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.depth_to_space"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.depth_to_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.depth_to_space" title="mxnet.ndarray.depth_to_space"><code class="xref py py-func docutils literal"><span class="pre">depth_to_space()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.depth_to_space" title="mxnet.ndarray.depth_to_space"><code class="xref py py-func docutils literal"><span class="pre">depth_to_space()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.space_to_depth">
<code class="descname">space_to_depth</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.space_to_depth"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.space_to_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.space_to_depth" title="mxnet.ndarray.space_to_depth"><code class="xref py py-func docutils literal"><span class="pre">space_to_depth()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.space_to_depth" title="mxnet.ndarray.space_to_depth"><code class="xref py py-func docutils literal"><span class="pre">space_to_depth()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.diag">
<code class="descname">diag</code><span class="sig-paren">(</span><em>k=0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.diag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.diag" title="mxnet.ndarray.diag"><code class="xref py py-func docutils literal"><span class="pre">diag()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.diag" title="mxnet.ndarray.diag"><code class="xref py py-func docutils literal"><span class="pre">diag()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.sum" title="mxnet.ndarray.sum"><code class="xref py py-func docutils literal"><span class="pre">sum()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.sum" title="mxnet.ndarray.sum"><code class="xref py py-func docutils literal"><span class="pre">sum()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.nansum">
<code class="descname">nansum</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.nansum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.nansum" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.nansum" title="mxnet.ndarray.nansum"><code class="xref py py-func docutils literal"><span class="pre">nansum()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.nansum" title="mxnet.ndarray.nansum"><code class="xref py py-func docutils literal"><span class="pre">nansum()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.prod">
<code class="descname">prod</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.prod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.prod" title="mxnet.ndarray.prod"><code class="xref py py-func docutils literal"><span class="pre">prod()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.prod" title="mxnet.ndarray.prod"><code class="xref py py-func docutils literal"><span class="pre">prod()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.nanprod">
<code class="descname">nanprod</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.nanprod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.nanprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.nanprod" title="mxnet.ndarray.nanprod"><code class="xref py py-func docutils literal"><span class="pre">nanprod()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.nanprod" title="mxnet.ndarray.nanprod"><code class="xref py py-func docutils literal"><span class="pre">nanprod()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.mean">
<code class="descname">mean</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.mean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.mean" title="mxnet.ndarray.mean"><code class="xref py py-func docutils literal"><span class="pre">mean()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.mean" title="mxnet.ndarray.mean"><code class="xref py py-func docutils literal"><span class="pre">mean()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.max"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.max" title="mxnet.ndarray.max"><code class="xref py py-func docutils literal"><span class="pre">max()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.max" title="mxnet.ndarray.max"><code class="xref py py-func docutils literal"><span class="pre">max()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.min" title="mxnet.ndarray.min"><code class="xref py py-func docutils literal"><span class="pre">min()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.min" title="mxnet.ndarray.min"><code class="xref py py-func docutils literal"><span class="pre">min()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.norm">
<code class="descname">norm</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.norm" title="mxnet.ndarray.norm"><code class="xref py py-func docutils literal"><span class="pre">norm()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.norm" title="mxnet.ndarray.norm"><code class="xref py py-func docutils literal"><span class="pre">norm()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.round">
<code class="descname">round</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.round"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.round" title="mxnet.ndarray.round"><code class="xref py py-func docutils literal"><span class="pre">round()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.round" title="mxnet.ndarray.round"><code class="xref py py-func docutils literal"><span class="pre">round()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.rint">
<code class="descname">rint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.rint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.rint" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.rint" title="mxnet.ndarray.rint"><code class="xref py py-func docutils literal"><span class="pre">rint()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.rint" title="mxnet.ndarray.rint"><code class="xref py py-func docutils literal"><span class="pre">rint()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.fix">
<code class="descname">fix</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.fix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.fix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.fix" title="mxnet.ndarray.fix"><code class="xref py py-func docutils literal"><span class="pre">fix()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.fix" title="mxnet.ndarray.fix"><code class="xref py py-func docutils literal"><span class="pre">fix()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.floor">
<code class="descname">floor</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.floor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.floor" title="mxnet.ndarray.floor"><code class="xref py py-func docutils literal"><span class="pre">floor()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.floor" title="mxnet.ndarray.floor"><code class="xref py py-func docutils literal"><span class="pre">floor()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.ceil">
<code class="descname">ceil</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.ceil"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.ceil" title="mxnet.ndarray.ceil"><code class="xref py py-func docutils literal"><span class="pre">ceil()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.ceil" title="mxnet.ndarray.ceil"><code class="xref py py-func docutils literal"><span class="pre">ceil()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.trunc">
<code class="descname">trunc</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.trunc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.trunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.trunc" title="mxnet.ndarray.trunc"><code class="xref py py-func docutils literal"><span class="pre">trunc()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.trunc" title="mxnet.ndarray.trunc"><code class="xref py py-func docutils literal"><span class="pre">trunc()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.sin">
<code class="descname">sin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.sin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.sin" title="mxnet.ndarray.sin"><code class="xref py py-func docutils literal"><span class="pre">sin()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.sin" title="mxnet.ndarray.sin"><code class="xref py py-func docutils literal"><span class="pre">sin()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.cos">
<code class="descname">cos</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.cos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.cos" title="mxnet.ndarray.cos"><code class="xref py py-func docutils literal"><span class="pre">cos()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.cos" title="mxnet.ndarray.cos"><code class="xref py py-func docutils literal"><span class="pre">cos()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.tan">
<code class="descname">tan</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.tan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.tan" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.tan" title="mxnet.ndarray.tan"><code class="xref py py-func docutils literal"><span class="pre">tan()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.tan" title="mxnet.ndarray.tan"><code class="xref py py-func docutils literal"><span class="pre">tan()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.arcsin">
<code class="descname">arcsin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.arcsin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.arcsin" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.arcsin" title="mxnet.ndarray.arcsin"><code class="xref py py-func docutils literal"><span class="pre">arcsin()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.arcsin" title="mxnet.ndarray.arcsin"><code class="xref py py-func docutils literal"><span class="pre">arcsin()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.arccos">
<code class="descname">arccos</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.arccos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.arccos" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.arccos" title="mxnet.ndarray.arccos"><code class="xref py py-func docutils literal"><span class="pre">arccos()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.arccos" title="mxnet.ndarray.arccos"><code class="xref py py-func docutils literal"><span class="pre">arccos()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.arctan">
<code class="descname">arctan</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.arctan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.arctan" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.arctan" title="mxnet.ndarray.arctan"><code class="xref py py-func docutils literal"><span class="pre">arctan()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.arctan" title="mxnet.ndarray.arctan"><code class="xref py py-func docutils literal"><span class="pre">arctan()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.degrees">
<code class="descname">degrees</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.degrees"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.degrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.degrees" title="mxnet.ndarray.degrees"><code class="xref py py-func docutils literal"><span class="pre">degrees()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.degrees" title="mxnet.ndarray.degrees"><code class="xref py py-func docutils literal"><span class="pre">degrees()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.radians">
<code class="descname">radians</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.radians"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.radians" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.radians" title="mxnet.ndarray.radians"><code class="xref py py-func docutils literal"><span class="pre">radians()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.radians" title="mxnet.ndarray.radians"><code class="xref py py-func docutils literal"><span class="pre">radians()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.sinh">
<code class="descname">sinh</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.sinh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.sinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.sinh" title="mxnet.ndarray.sinh"><code class="xref py py-func docutils literal"><span class="pre">sinh()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.sinh" title="mxnet.ndarray.sinh"><code class="xref py py-func docutils literal"><span class="pre">sinh()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.cosh">
<code class="descname">cosh</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.cosh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.cosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.cosh" title="mxnet.ndarray.cosh"><code class="xref py py-func docutils literal"><span class="pre">cosh()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.cosh" title="mxnet.ndarray.cosh"><code class="xref py py-func docutils literal"><span class="pre">cosh()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.tanh">
<code class="descname">tanh</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.tanh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.tanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.tanh" title="mxnet.ndarray.tanh"><code class="xref py py-func docutils literal"><span class="pre">tanh()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.tanh" title="mxnet.ndarray.tanh"><code class="xref py py-func docutils literal"><span class="pre">tanh()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.arcsinh">
<code class="descname">arcsinh</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.arcsinh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.arcsinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.arcsinh" title="mxnet.ndarray.arcsinh"><code class="xref py py-func docutils literal"><span class="pre">arcsinh()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.arcsinh" title="mxnet.ndarray.arcsinh"><code class="xref py py-func docutils literal"><span class="pre">arcsinh()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.arccosh">
<code class="descname">arccosh</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.arccosh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.arccosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.arccosh" title="mxnet.ndarray.arccosh"><code class="xref py py-func docutils literal"><span class="pre">arccosh()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.arccosh" title="mxnet.ndarray.arccosh"><code class="xref py py-func docutils literal"><span class="pre">arccosh()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.arctanh">
<code class="descname">arctanh</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.arctanh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.arctanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.arctanh" title="mxnet.ndarray.arctanh"><code class="xref py py-func docutils literal"><span class="pre">arctanh()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.arctanh" title="mxnet.ndarray.arctanh"><code class="xref py py-func docutils literal"><span class="pre">arctanh()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.exp">
<code class="descname">exp</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.exp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.exp" title="mxnet.ndarray.exp"><code class="xref py py-func docutils literal"><span class="pre">exp()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.exp" title="mxnet.ndarray.exp"><code class="xref py py-func docutils literal"><span class="pre">exp()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.expm1">
<code class="descname">expm1</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.expm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.expm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.expm1" title="mxnet.ndarray.expm1"><code class="xref py py-func docutils literal"><span class="pre">expm1()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.expm1" title="mxnet.ndarray.expm1"><code class="xref py py-func docutils literal"><span class="pre">expm1()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.log">
<code class="descname">log</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.log" title="mxnet.ndarray.log"><code class="xref py py-func docutils literal"><span class="pre">log()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.log" title="mxnet.ndarray.log"><code class="xref py py-func docutils literal"><span class="pre">log()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.log10">
<code class="descname">log10</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.log10"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.log10" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.log10" title="mxnet.ndarray.log10"><code class="xref py py-func docutils literal"><span class="pre">log10()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.log10" title="mxnet.ndarray.log10"><code class="xref py py-func docutils literal"><span class="pre">log10()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.log2">
<code class="descname">log2</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.log2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.log2" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.log2" title="mxnet.ndarray.log2"><code class="xref py py-func docutils literal"><span class="pre">log2()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.log2" title="mxnet.ndarray.log2"><code class="xref py py-func docutils literal"><span class="pre">log2()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.log1p">
<code class="descname">log1p</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.log1p"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.log1p" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.log1p" title="mxnet.ndarray.log1p"><code class="xref py py-func docutils literal"><span class="pre">log1p()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.log1p" title="mxnet.ndarray.log1p"><code class="xref py py-func docutils literal"><span class="pre">log1p()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.sqrt">
<code class="descname">sqrt</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.sqrt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.sqrt" title="mxnet.ndarray.sqrt"><code class="xref py py-func docutils literal"><span class="pre">sqrt()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.sqrt" title="mxnet.ndarray.sqrt"><code class="xref py py-func docutils literal"><span class="pre">sqrt()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.rsqrt">
<code class="descname">rsqrt</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.rsqrt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.rsqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.rsqrt" title="mxnet.ndarray.rsqrt"><code class="xref py py-func docutils literal"><span class="pre">rsqrt()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.rsqrt" title="mxnet.ndarray.rsqrt"><code class="xref py py-func docutils literal"><span class="pre">rsqrt()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.cbrt">
<code class="descname">cbrt</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.cbrt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.cbrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.cbrt" title="mxnet.ndarray.cbrt"><code class="xref py py-func docutils literal"><span class="pre">cbrt()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.cbrt" title="mxnet.ndarray.cbrt"><code class="xref py py-func docutils literal"><span class="pre">cbrt()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.rcbrt">
<code class="descname">rcbrt</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.rcbrt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.rcbrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.rcbrt" title="mxnet.ndarray.rcbrt"><code class="xref py py-func docutils literal"><span class="pre">rcbrt()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.rcbrt" title="mxnet.ndarray.rcbrt"><code class="xref py py-func docutils literal"><span class="pre">rcbrt()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.square">
<code class="descname">square</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.square" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.square" title="mxnet.ndarray.square"><code class="xref py py-func docutils literal"><span class="pre">square()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.square" title="mxnet.ndarray.square"><code class="xref py py-func docutils literal"><span class="pre">square()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.reciprocal">
<code class="descname">reciprocal</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.reciprocal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.reciprocal" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.reciprocal" title="mxnet.ndarray.reciprocal"><code class="xref py py-func docutils literal"><span class="pre">reciprocal()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.reciprocal" title="mxnet.ndarray.reciprocal"><code class="xref py py-func docutils literal"><span class="pre">reciprocal()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.relu">
<code class="descname">relu</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.relu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.relu" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.relu" title="mxnet.ndarray.relu"><code class="xref py py-func docutils literal"><span class="pre">relu()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.relu" title="mxnet.ndarray.relu"><code class="xref py py-func docutils literal"><span class="pre">relu()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.sigmoid">
<code class="descname">sigmoid</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.sigmoid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.sigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.sigmoid" title="mxnet.ndarray.sigmoid"><code class="xref py py-func docutils literal"><span class="pre">sigmoid()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.sigmoid" title="mxnet.ndarray.sigmoid"><code class="xref py py-func docutils literal"><span class="pre">sigmoid()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.softmax">
<code class="descname">softmax</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.softmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.softmax" title="mxnet.ndarray.softmax"><code class="xref py py-func docutils literal"><span class="pre">softmax()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.softmax" title="mxnet.ndarray.softmax"><code class="xref py py-func docutils literal"><span class="pre">softmax()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.log_softmax">
<code class="descname">log_softmax</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.log_softmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.log_softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.log_softmax" title="mxnet.ndarray.log_softmax"><code class="xref py py-func docutils literal"><span class="pre">log_softmax()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.log_softmax" title="mxnet.ndarray.log_softmax"><code class="xref py py-func docutils literal"><span class="pre">log_softmax()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.softmin">
<code class="descname">softmin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.softmin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.softmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.softmin" title="mxnet.ndarray.softmin"><code class="xref py py-func docutils literal"><span class="pre">softmin()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.softmin" title="mxnet.ndarray.softmin"><code class="xref py py-func docutils literal"><span class="pre">softmin()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience fluent method for <a class="reference internal" href="#mxnet.ndarray.squeeze" title="mxnet.ndarray.squeeze"><code class="xref py py-func docutils literal"><span class="pre">squeeze()</span></code></a>.</p>
<p>The arguments are the same as for <a class="reference internal" href="#mxnet.ndarray.squeeze" title="mxnet.ndarray.squeeze"><code class="xref py py-func docutils literal"><span class="pre">squeeze()</span></code></a>, with
this array as data.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.broadcast_to">
<code class="descname">broadcast_to</code><span class="sig-paren">(</span><em>shape</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.broadcast_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.broadcast_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcasts the input array to a new shape.</p>
<p>Broadcasting is only allowed on axes with size 1. The new shape cannot change
the number of dimensions.
For example, you could broadcast from shape (2, 1) to (2, 3), but not from
shape (2, 3) to (2, 3, 3).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>shape</strong> (<em>tuple of int</em>) – The shape of the desired array.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A NDArray with the desired shape that is not sharing data with this
array, even if the new shape is the same as <code class="docutils literal"><span class="pre">self.shape</span></code>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[[ 0.],</span>
<span class="go">        [ 1.],</span>
<span class="go">        [ 2.]]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[[ 0.,  0.,  0.],</span>
<span class="go">        [ 1.,  1.,  1.],</span>
<span class="go">        [ 2.,  2.,  2.]],</span>

<span class="go">       [[ 0.,  0.,  0.],</span>
<span class="go">        [ 1.,  1.,  1.],</span>
<span class="go">        [ 2.,  2.,  2.]]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.broadcast_like">
<code class="descname">broadcast_like</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.broadcast_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.broadcast_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcasts the input array to the shape of other.</p>
<p>Broadcasting is only allowed on axes with size 1. The new shape cannot change
the number of dimensions.
For example, you could broadcast from shape (2, 1) to (2, 3), but not from
shape (2, 3) to (2, 3, 3).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Array with shape of the desired array.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A NDArray with the desired shape that is not sharing data with this
array, even if the new shape is the same as <code class="docutils literal"><span class="pre">self.shape</span></code>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[[ 0.],</span>
<span class="go">        [ 1.],</span>
<span class="go">        [ 2.]]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">broadcast_like</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)))</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[[ 0.,  0.,  0.],</span>
<span class="go">        [ 1.,  1.,  1.],</span>
<span class="go">        [ 2.,  2.,  2.]],</span>

<span class="go">       [[ 0.,  0.,  0.],</span>
<span class="go">        [ 1.,  1.,  1.],</span>
<span class="go">        [ 2.,  2.,  2.]]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.wait_to_read">
<code class="descname">wait_to_read</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.wait_to_read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.wait_to_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Waits until all previous write operations on the current array are finished.</p>
<p>This method guarantees that all previous write operations that pushed
into the backend engine for execution are actually finished.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="kn">import</span> <span class="nn">time</span>
<span class="gp">>>> </span><span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="gp">>>> </span><span class="n">a</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">b</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">>>> </span><span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tic</span><span class="p">)</span> 
<span class="go">0.003854036331176758</span>
<span class="gp">>>> </span><span class="n">b</span><span class="o">.</span><span class="n">wait_to_read</span><span class="p">()</span>
<span class="gp">>>> </span><span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tic</span><span class="p">)</span> 
<span class="go">0.0893700122833252</span>
</pre></div>
</div>
</dd></dl>
<dl class="attribute">
<dt id="mxnet.ndarray.NDArray.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#mxnet.ndarray.NDArray.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of dimensions of this array</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
<span class="go">1</span>
<span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>
<dl class="attribute">
<dt id="mxnet.ndarray.NDArray.shape">
<code class="descname">shape</code><a class="headerlink" href="#mxnet.ndarray.NDArray.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of array dimensions.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4L,)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2L, 3L, 4L)</span>
</pre></div>
</div>
</dd></dl>
<dl class="attribute">
<dt id="mxnet.ndarray.NDArray.size">
<code class="descname">size</code><a class="headerlink" href="#mxnet.ndarray.NDArray.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of elements in the array.</p>
<p>Equivalent to the product of the array’s dimensions.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">size</span>
<span class="go">30</span>
<span class="gp">>>> </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">30</span>
</pre></div>
</div>
</dd></dl>
<dl class="attribute">
<dt id="mxnet.ndarray.NDArray.context">
<code class="descname">context</code><a class="headerlink" href="#mxnet.ndarray.NDArray.context" title="Permalink to this definition">¶</a></dt>
<dd><p>Device context of the array.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">context</span>
<span class="go">cpu(0)</span>
<span class="gp">>>> </span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>
<span class="go"><class 'mxnet.context.Context'></span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">context</span>
<span class="go">gpu(0)</span>
</pre></div>
</div>
</dd></dl>
<dl class="attribute">
<dt id="mxnet.ndarray.NDArray.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mxnet.ndarray.NDArray.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Data-type of the array’s elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">This NDArray’s data type.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">numpy.dtype</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span>
<span class="go"><type 'numpy.float32'></span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'int32'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span>
<span class="go"><type 'numpy.int32'></span>
</pre></div>
</div>
</dd></dl>
<dl class="attribute">
<dt id="mxnet.ndarray.NDArray.stype">
<code class="descname">stype</code><a class="headerlink" href="#mxnet.ndarray.NDArray.stype" title="Permalink to this definition">¶</a></dt>
<dd><p>Storage-type of the array.</p>
</dd></dl>
<dl class="attribute">
<dt id="mxnet.ndarray.NDArray.T">
<code class="descname">T</code><a class="headerlink" href="#mxnet.ndarray.NDArray.T" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the array with axes transposed.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">mx.nd.transpose(self)</span></code> except that
self is returned if <code class="docutils literal"><span class="pre">self.ndim</span> <span class="pre"><</span> <span class="pre">2</span></code>.</p>
<p>Unlike <code class="docutils literal"><span class="pre">numpy.ndarray.T</span></code>, this function returns a copy
rather than a view of the array unless <code class="docutils literal"><span class="pre">self.ndim</span> <span class="pre"><</span> <span class="pre">2</span></code>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4.,  5.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  3.],</span>
<span class="go">       [ 1.,  4.],</span>
<span class="go">       [ 2.,  5.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.asnumpy">
<code class="descname">asnumpy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.asnumpy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.asnumpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <code class="docutils literal"><span class="pre">numpy.ndarray</span></code> object with value copied from this array.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="gp">>>> </span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go"><type 'numpy.ndarray'></span>
<span class="gp">>>> </span><span class="n">y</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'int32'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[1, 1, 1],</span>
<span class="go">       [1, 1, 1]], dtype=int32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.asscalar">
<code class="descname">asscalar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.asscalar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.asscalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a scalar whose value is copied from this array.</p>
<p>This function is equivalent to <code class="docutils literal"><span class="pre">self.asnumpy()[0]</span></code>. This NDArray must have shape (1,).</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'int32'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asscalar</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">>>> </span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">asscalar</span><span class="p">())</span>
<span class="go"><type 'numpy.int32'></span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.astype">
<code class="descname">astype</code><span class="sig-paren">(</span><em>dtype</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.astype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the array after casting to a specified type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dtype</strong> (<em>numpy.dtype</em><em> or </em><em>str</em>) – The type of the returned array.</li>
<li><strong>copy</strong> (<em>bool</em>) – Default <cite>True</cite>. By default, astype always returns a newly
allocated ndarray on the same context. If this is set to
<cite>False</cite>, and the dtype requested is the same as the ndarray’s
dtype, the ndarray is returned instead of a copy.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The copied array after casting to the specified type, or
the same array if copy=False and dtype is the same as the input
array.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a>, <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray">CSRNDArray</a> or <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray">RowSparseNDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'float32'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'int32'</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span>
<span class="go"><type 'numpy.int32'></span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.copyto">
<code class="descname">copyto</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.copyto"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.copyto" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the value of this array to another array.</p>
<p>If <code class="docutils literal"><span class="pre">other</span></code> is a <code class="docutils literal"><span class="pre">NDArray</span></code> object, then <code class="docutils literal"><span class="pre">other.shape</span></code> and
<code class="docutils literal"><span class="pre">self.shape</span></code> should be the same. This function copies the value from
<code class="docutils literal"><span class="pre">self</span></code> to <code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">other</span></code> is a context, a new <code class="docutils literal"><span class="pre">NDArray</span></code> will be first created on
the target context, and the value of <code class="docutils literal"><span class="pre">self</span></code> is copied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em> or </em><em>Context</em>) – The destination array or context.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The copied array. If <code class="docutils literal"><span class="pre">other</span></code> is an <code class="docutils literal"><span class="pre">NDArray</span></code>, then the return value
and <code class="docutils literal"><span class="pre">other</span></code> will point to the same <code class="docutils literal"><span class="pre">NDArray</span></code>.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a>, <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray">CSRNDArray</a> or <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray">RowSparseNDArray</a></td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="ow">is</span> <span class="n">y</span>
<span class="go">True</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go"><NDArray 2x3 @gpu(0)></span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of this <code class="docutils literal"><span class="pre">NDArray</span></code>, keeping the same context.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The copied array</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a>, <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray">CSRNDArray</a> or <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray">RowSparseNDArray</a></td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.as_in_context">
<code class="descname">as_in_context</code><span class="sig-paren">(</span><em>context</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.as_in_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.as_in_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array on the target device with the same value as this array.</p>
<p>If the target context is the same as <code class="docutils literal"><span class="pre">self.context</span></code>, then <code class="docutils literal"><span class="pre">self</span></code> is
returned.  Otherwise, a copy is made.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>context</strong> (<em>Context</em>) – The target context.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The target array.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a>, <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray">CSRNDArray</a> or <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray">RowSparseNDArray</a></td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">as_in_context</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">as_in_context</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.attach_grad">
<code class="descname">attach_grad</code><span class="sig-paren">(</span><em>grad_req='write'</em>, <em>stype=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.attach_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.attach_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a gradient buffer to this NDArray, so that <cite>backward</cite>
can compute gradient with respect to it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>grad_req</strong> (<em>{'write'</em><em>, </em><em>'add'</em><em>, </em><em>'null'}</em>) – How gradient will be accumulated.
- ‘write’: gradient will be overwritten on every backward.
- ‘add’: gradient will be added to existing value on every backward.
- ‘null’: do not compute gradient for this NDArray.</li>
<li><strong>stype</strong> (<em>str</em><em>, </em><em>optional</em>) – The storage type of the gradient array. Defaults to the same stype of this NDArray.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="attribute">
<dt id="mxnet.ndarray.NDArray.grad">
<code class="descname">grad</code><a class="headerlink" href="#mxnet.ndarray.NDArray.grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns gradient buffer attached to this NDArray.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.detach">
<code class="descname">detach</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.detach"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.detach" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new NDArray, detached from the current graph.</p>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.backward">
<code class="descname">backward</code><span class="sig-paren">(</span><em>out_grad=None</em>, <em>retain_graph=False</em>, <em>train_mode=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.backward"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.backward" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gradients of this NDArray w.r.t variables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>out_grad</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – Gradient with respect to head.</li>
<li><strong>retain_graph</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to retain the computaion graph for another backward
pass on the same graph. By default the computaion history
is cleared.</li>
<li><strong>train_mode</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to compute gradient for training or inference.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.tostype">
<code class="descname">tostype</code><span class="sig-paren">(</span><em>stype</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.tostype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.tostype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the array with chosen storage type.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mxnet.ndarray.cast_storage" title="mxnet.ndarray.cast_storage"><code class="xref py py-meth docutils literal"><span class="pre">mxnet.ndarray.cast_storage()</span></code></a></p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A copy of the array with the chosen storage stype</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a>, <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray">CSRNDArray</a> or <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray">RowSparseNDArray</a></td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.to_dlpack_for_read">
<code class="descname">to_dlpack_for_read</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.to_dlpack_for_read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.to_dlpack_for_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference view of NDArray that represents as DLManagedTensor until
all previous write operations on the current array are finished.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a reference view of NDArray that represents as DLManagedTensor.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">PyCapsule (the pointer of DLManagedTensor)</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">to_dlpack_for_read</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">>>> </span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go"><class 'PyCapsule'></span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">from_dlpack</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span>
<span class="go">[[1. 1. 1.]</span>
<span class="go"> [1. 1. 1.]]</span>
<span class="go"><NDArray 2x3 @cpu(0)></span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="mxnet.ndarray.NDArray.to_dlpack_for_write">
<code class="descname">to_dlpack_for_write</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#NDArray.to_dlpack_for_write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.NDArray.to_dlpack_for_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference view of NDArray that represents as DLManagedTensor until
all previous read/write operations on the current array are finished.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a reference view of NDArray that represents as DLManagedTensor.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">PyCapsule (the pointer of DLManagedTensor)</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">w</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">to_dlpack_for_write</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">>>> </span><span class="nb">type</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go"><class 'PyCapsule'></span>
<span class="gp">>>> </span><span class="n">u</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">from_dlpack</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">u</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">>>> </span><span class="n">x</span>
<span class="go">[[2. 2. 2.]</span>
<span class="go"> [2. 2. 2.]]</span>
<span class="go"><NDArray 2x3 @cpu(0)></span>
</pre></div>
</div>
</dd></dl>
</dd></dl>
<span class="target" id="module-mxnet.ndarray"></span><p>NDArray API of MXNet.</p>
<dl class="function">
<dt id="mxnet.ndarray.Activation">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Activation</code><span class="sig-paren">(</span><em>data=None</em>, <em>act_type=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Activation" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies an activation function element-wise to the input.</p>
<p>The following activation functions are supported:</p>
<ul class="simple">
<li><cite>relu</cite>: Rectified Linear Unit, <span class="math">\(y = max(x, 0)\)</span></li>
<li><cite>sigmoid</cite>: <span class="math">\(y = \frac{1}{1 + exp(-x)}\)</span></li>
<li><cite>tanh</cite>: Hyperbolic tangent, <span class="math">\(y = \frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}\)</span></li>
<li><cite>softrelu</cite>: Soft ReLU, or SoftPlus, <span class="math">\(y = log(1 + exp(x))\)</span></li>
<li><cite>softsign</cite>: <span class="math">\(y = \frac{x}{1 + abs(x)}\)</span></li>
</ul>
<p>Defined in src/operator/nn/activation.cc:L167</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>act_type</strong> (<em>{'relu'</em><em>, </em><em>'sigmoid'</em><em>, </em><em>'softrelu'</em><em>, </em><em>'softsign'</em><em>, </em><em>'tanh'}</em><em>, </em><em>required</em>) – Activation function to be applied.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.BatchNorm">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">BatchNorm</code><span class="sig-paren">(</span><em>data=None</em>, <em>gamma=None</em>, <em>beta=None</em>, <em>moving_mean=None</em>, <em>moving_var=None</em>, <em>eps=_Null</em>, <em>momentum=_Null</em>, <em>fix_gamma=_Null</em>, <em>use_global_stats=_Null</em>, <em>output_mean_var=_Null</em>, <em>axis=_Null</em>, <em>cudnn_off=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.BatchNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Batch normalization.</p>
<p>Normalizes a data batch by mean and variance, and applies a scale <code class="docutils literal"><span class="pre">gamma</span></code> as
well as offset <code class="docutils literal"><span class="pre">beta</span></code>.</p>
<p>Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis:</p>
<div class="math">
\[\begin{split}data\_mean[i] = mean(data[:,i,:,...]) \\
data\_var[i] = var(data[:,i,:,...])\end{split}\]</div>
<p>Then compute the normalized output, which has the same shape as input, as following:</p>
<div class="math">
\[out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]\]</div>
<p>Both <em>mean</em> and <em>var</em> returns a scalar by treating the input as a vector.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both <code class="docutils literal"><span class="pre">gamma</span></code> and <code class="docutils literal"><span class="pre">beta</span></code>
have shape <em>(k,)</em>. If <code class="docutils literal"><span class="pre">output_mean_var</span></code> is set to be true, then outputs both <code class="docutils literal"><span class="pre">data_mean</span></code> and
the inverse of <code class="docutils literal"><span class="pre">data_var</span></code>, which are needed for the backward pass. Note that gradient of these
two outputs are blocked.</p>
<p>Besides the inputs and the outputs, this operator accepts two auxiliary
states, <code class="docutils literal"><span class="pre">moving_mean</span></code> and <code class="docutils literal"><span class="pre">moving_var</span></code>, which are <em>k</em>-length
vectors. They are global statistics for the whole dataset, which are updated
by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">moving_mean</span> <span class="o">=</span> <span class="n">moving_mean</span> <span class="o">*</span> <span class="n">momentum</span> <span class="o">+</span> <span class="n">data_mean</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">momentum</span><span class="p">)</span>
<span class="n">moving_var</span> <span class="o">=</span> <span class="n">moving_var</span> <span class="o">*</span> <span class="n">momentum</span> <span class="o">+</span> <span class="n">data_var</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">momentum</span><span class="p">)</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">use_global_stats</span></code> is set to be true, then <code class="docutils literal"><span class="pre">moving_mean</span></code> and
<code class="docutils literal"><span class="pre">moving_var</span></code> are used instead of <code class="docutils literal"><span class="pre">data_mean</span></code> and <code class="docutils literal"><span class="pre">data_var</span></code> to compute
the output. It is often used during inference.</p>
<p>The parameter <code class="docutils literal"><span class="pre">axis</span></code> specifies which axis of the input shape denotes
the ‘channel’ (separately normalized groups).  The default is 1.  Specifying -1 sets the channel
axis to be the last item in the input shape.</p>
<p>Both <code class="docutils literal"><span class="pre">gamma</span></code> and <code class="docutils literal"><span class="pre">beta</span></code> are learnable parameters. But if <code class="docutils literal"><span class="pre">fix_gamma</span></code> is true,
then set <code class="docutils literal"><span class="pre">gamma</span></code> to 1 and its gradient to 0.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When <code class="docutils literal"><span class="pre">fix_gamma</span></code> is set to True, no sparse support is provided. If <code class="docutils literal"><span class="pre">fix_gamma</span> <span class="pre">is</span></code> set to False,
the sparse tensors will fallback.</p>
</div>
<p>Defined in src/operator/nn/batch_norm.cc:L572</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to batch normalization</li>
<li><strong>gamma</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – gamma array</li>
<li><strong>beta</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – beta array</li>
<li><strong>moving_mean</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – running mean of input</li>
<li><strong>moving_var</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – running variance of input</li>
<li><strong>eps</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=0.0010000000474974513</em>) – Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)</li>
<li><strong>momentum</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.899999976</em>) – Momentum for moving average</li>
<li><strong>fix_gamma</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Fix gamma while training</li>
<li><strong>use_global_stats</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</li>
<li><strong>output_mean_var</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Output the mean and inverse std</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='1'</em>) – Specify which shape axis the channel is specified</li>
<li><strong>cudnn_off</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Do not select CUDNN operator, if available</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.BatchNorm_v1">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">BatchNorm_v1</code><span class="sig-paren">(</span><em>data=None</em>, <em>gamma=None</em>, <em>beta=None</em>, <em>eps=_Null</em>, <em>momentum=_Null</em>, <em>fix_gamma=_Null</em>, <em>use_global_stats=_Null</em>, <em>output_mean_var=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.BatchNorm_v1" title="Permalink to this definition">¶</a></dt>
<dd><p>Batch normalization.</p>
<p>This operator is DEPRECATED. Perform BatchNorm on the input.</p>
<p>Normalizes a data batch by mean and variance, and applies a scale <code class="docutils literal"><span class="pre">gamma</span></code> as
well as offset <code class="docutils literal"><span class="pre">beta</span></code>.</p>
<p>Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis:</p>
<div class="math">
\[\begin{split}data\_mean[i] = mean(data[:,i,:,...]) \\
data\_var[i] = var(data[:,i,:,...])\end{split}\]</div>
<p>Then compute the normalized output, which has the same shape as input, as following:</p>
<div class="math">
\[out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}} * gamma[i] + beta[i]\]</div>
<p>Both <em>mean</em> and <em>var</em> returns a scalar by treating the input as a vector.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both <code class="docutils literal"><span class="pre">gamma</span></code> and <code class="docutils literal"><span class="pre">beta</span></code>
have shape <em>(k,)</em>. If <code class="docutils literal"><span class="pre">output_mean_var</span></code> is set to be true, then outputs both <code class="docutils literal"><span class="pre">data_mean</span></code> and
<code class="docutils literal"><span class="pre">data_var</span></code> as well, which are needed for the backward pass.</p>
<p>Besides the inputs and the outputs, this operator accepts two auxiliary
states, <code class="docutils literal"><span class="pre">moving_mean</span></code> and <code class="docutils literal"><span class="pre">moving_var</span></code>, which are <em>k</em>-length
vectors. They are global statistics for the whole dataset, which are updated
by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">moving_mean</span> <span class="o">=</span> <span class="n">moving_mean</span> <span class="o">*</span> <span class="n">momentum</span> <span class="o">+</span> <span class="n">data_mean</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">momentum</span><span class="p">)</span>
<span class="n">moving_var</span> <span class="o">=</span> <span class="n">moving_var</span> <span class="o">*</span> <span class="n">momentum</span> <span class="o">+</span> <span class="n">data_var</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">momentum</span><span class="p">)</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">use_global_stats</span></code> is set to be true, then <code class="docutils literal"><span class="pre">moving_mean</span></code> and
<code class="docutils literal"><span class="pre">moving_var</span></code> are used instead of <code class="docutils literal"><span class="pre">data_mean</span></code> and <code class="docutils literal"><span class="pre">data_var</span></code> to compute
the output. It is often used during inference.</p>
<p>Both <code class="docutils literal"><span class="pre">gamma</span></code> and <code class="docutils literal"><span class="pre">beta</span></code> are learnable parameters. But if <code class="docutils literal"><span class="pre">fix_gamma</span></code> is true,
then set <code class="docutils literal"><span class="pre">gamma</span></code> to 1 and its gradient to 0.</p>
<p>There’s no sparse support for this operator, and it will exhibit problematic behavior if used with
sparse tensors.</p>
<p>Defined in src/operator/batch_norm_v1.cc:L95</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to batch normalization</li>
<li><strong>gamma</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – gamma array</li>
<li><strong>beta</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – beta array</li>
<li><strong>eps</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.00100000005</em>) – Epsilon to prevent div 0</li>
<li><strong>momentum</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.899999976</em>) – Momentum for moving average</li>
<li><strong>fix_gamma</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Fix gamma while training</li>
<li><strong>use_global_stats</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator.</li>
<li><strong>output_mean_var</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Output All,normal mean and var</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.BilinearSampler">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">BilinearSampler</code><span class="sig-paren">(</span><em>data=None</em>, <em>grid=None</em>, <em>cudnn_off=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.BilinearSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies bilinear sampling to input feature map.</p>
<p>Bilinear Sampling is the key of  [NIPS2015] “Spatial Transformer Networks”. The usage of the operator is very similar to remap function in OpenCV,
except that the operator has the backward pass.</p>
<p>Given <span class="math">\(data\)</span> and <span class="math">\(grid\)</span>, then the output is computed by</p>
<div class="math">
\[\begin{split}x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\
y_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\
output[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})\end{split}\]</div>
<p><span class="math">\(x_{dst}\)</span>, <span class="math">\(y_{dst}\)</span> enumerate all spatial locations in <span class="math">\(output\)</span>, and <span class="math">\(G()\)</span> denotes the bilinear interpolation kernel.
The out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).</p>
<p>The operator assumes that <span class="math">\(data\)</span> has ‘NCHW’ layout and <span class="math">\(grid\)</span> has been normalized to [-1, 1].</p>
<p>BilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler.
GridGenerator supports two kinds of transformation: <code class="docutils literal"><span class="pre">affine</span></code> and <code class="docutils literal"><span class="pre">warp</span></code>.
If users want to design a CustomOp to manipulate <span class="math">\(grid\)</span>, please firstly refer to the code of GridGenerator.</p>
<p>Example 1:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">## Zoom out data two times</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]]])</span>

<span class="n">affine_matrix</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="n">affine_matrix</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">affine_matrix</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="n">grid</span> <span class="o">=</span> <span class="n">GridGenerator</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">affine_matrix</span><span class="p">,</span> <span class="n">transform_type</span><span class="o">=</span><span class="s1">'affine'</span><span class="p">,</span> <span class="n">target_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="n">out</span> <span class="o">=</span> <span class="n">BilinearSampler</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

<span class="n">out</span>
<span class="p">[[[[</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">],</span>
   <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>   <span class="mf">3.5</span><span class="p">,</span>   <span class="mf">6.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
   <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>   <span class="mf">1.25</span><span class="p">,</span>  <span class="mf">2.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
   <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Example 2:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">## shift data horizontally by -1 pixel</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]]])</span>

<span class="n">warp_maxtrix</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                       <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]]])</span>

<span class="n">grid</span> <span class="o">=</span> <span class="n">GridGenerator</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">warp_matrix</span><span class="p">,</span> <span class="n">transform_type</span><span class="o">=</span><span class="s1">'warp'</span><span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">BilinearSampler</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

<span class="n">out</span>
<span class="p">[[[[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
   <span class="p">[</span> <span class="mi">8</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
   <span class="p">[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
   <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/bilinear_sampler.cc:L256</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to the BilinearsamplerOp.</li>
<li><strong>grid</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input grid to the BilinearsamplerOp.grid has two channels: x_src, y_src</li>
<li><strong>cudnn_off</strong> (<em>boolean</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – whether to turn cudnn off</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.BlockGrad">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">BlockGrad</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.BlockGrad" title="Permalink to this definition">¶</a></dt>
<dd><p>Stops gradient computation.</p>
<p>Stops the accumulated gradient of the inputs from flowing through this operator
in the backward direction. In other words, this operator prevents the contribution
of its inputs to be taken into account for computing gradients.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">v1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">v2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="n">b_stop_grad</span> <span class="o">=</span> <span class="n">stop_gradient</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
<span class="n">loss</span> <span class="o">=</span> <span class="n">MakeLoss</span><span class="p">(</span><span class="n">b_stop_grad</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span>

<span class="n">executor</span> <span class="o">=</span> <span class="n">loss</span><span class="o">.</span><span class="n">simple_bind</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">executor</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">is_train</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">v1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">v2</span><span class="p">)</span>
<span class="n">executor</span><span class="o">.</span><span class="n">outputs</span>
<span class="p">[</span> <span class="mf">1.</span>  <span class="mf">5.</span><span class="p">]</span>

<span class="n">executor</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="n">executor</span><span class="o">.</span><span class="n">grad_arrays</span>
<span class="p">[</span> <span class="mf">0.</span>  <span class="mf">0.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L299</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.CTCLoss">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">CTCLoss</code><span class="sig-paren">(</span><em>data=None</em>, <em>label=None</em>, <em>data_lengths=None</em>, <em>label_lengths=None</em>, <em>use_data_lengths=_Null</em>, <em>use_label_lengths=_Null</em>, <em>blank_label=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.CTCLoss" title="Permalink to this definition">¶</a></dt>
<dd><p>Connectionist Temporal Classification Loss.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The existing alias <code class="docutils literal"><span class="pre">contrib_CTCLoss</span></code> is deprecated.</p>
</div>
<p>The shapes of the inputs and outputs:</p>
<ul class="simple">
<li><strong>data</strong>: <cite>(sequence_length, batch_size, alphabet_size)</cite></li>
<li><strong>label</strong>: <cite>(batch_size, label_sequence_length)</cite></li>
<li><strong>out</strong>: <cite>(batch_size)</cite></li>
</ul>
<p>The <cite>data</cite> tensor consists of sequences of activation vectors (without applying softmax),
with i-th channel in the last dimension corresponding to i-th label
for i between 0 and alphabet_size-1 (i.e always 0-indexed).
Alphabet size should include one additional value reserved for blank label.
When <cite>blank_label</cite> is <code class="docutils literal"><span class="pre">"first"</span></code>, the <code class="docutils literal"><span class="pre">0</span></code>-th channel is be reserved for
activation of blank label, or otherwise if it is “last”, <code class="docutils literal"><span class="pre">(alphabet_size-1)</span></code>-th channel should be
reserved for blank label.</p>
<p><code class="docutils literal"><span class="pre">label</span></code> is an index matrix of integers. When <cite>blank_label</cite> is <code class="docutils literal"><span class="pre">"first"</span></code>,
the value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,
when <cite>blank_label</cite> is <code class="docutils literal"><span class="pre">"last"</span></code>, the value <cite>(alphabet_size-1)</cite> is reserved for blank label.</p>
<p>If a sequence of labels is shorter than <em>label_sequence_length</em>, use the special
padding value at the end of the sequence to conform it to the correct
length. The padding value is <cite>0</cite> when <cite>blank_label</cite> is <code class="docutils literal"><span class="pre">"first"</span></code>, and <cite>-1</cite> otherwise.</p>
<p>For example, suppose the vocabulary is <cite>[a, b, c]</cite>, and in one batch we have three sequences
‘ba’, ‘cbb’, and ‘abac’. When <cite>blank_label</cite> is <code class="docutils literal"><span class="pre">"first"</span></code>, we can index the labels as
<cite>{‘a’: 1, ‘b’: 2, ‘c’: 3}</cite>, and we reserve the 0-th channel for blank label in data tensor.
The resulting <cite>label</cite> tensor should be padded to be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
</pre></div>
</div>
<p>When <cite>blank_label</cite> is <code class="docutils literal"><span class="pre">"last"</span></code>, we can index the labels as
<cite>{‘a’: 0, ‘b’: 1, ‘c’: 2}</cite>, and we reserve the channel index 3 for blank label in data tensor.
The resulting <cite>label</cite> tensor should be padded to be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">out</span></code> is a list of CTC loss values, one per example in the batch.</p>
<p>See <em>Connectionist Temporal Classification: Labelling Unsegmented
Sequence Data with Recurrent Neural Networks</em>, A. Graves <em>et al</em>. for more
information on the definition and the algorithm.</p>
<p>Defined in src/operator/nn/ctc_loss.cc:L100</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input ndarray</li>
<li><strong>label</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Ground-truth labels for the loss.</li>
<li><strong>data_lengths</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Lengths of data for each of the samples. Only required when use_data_lengths is true.</li>
<li><strong>label_lengths</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Lengths of labels for each of the samples. Only required when use_label_lengths is true.</li>
<li><strong>use_data_lengths</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether the data lenghts are decided by <cite>data_lengths</cite>. If false, the lengths are equal to the max sequence length.</li>
<li><strong>use_label_lengths</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether the label lenghts are decided by <cite>label_lengths</cite>, or derived from <cite>padding_mask</cite>. If false, the lengths are derived from the first occurrence of the value of <cite>padding_mask</cite>. The value of <cite>padding_mask</cite> is <code class="docutils literal"><span class="pre">0</span></code> when first CTC label is reserved for blank, and <code class="docutils literal"><span class="pre">-1</span></code> when last label is reserved for blank. See <cite>blank_label</cite>.</li>
<li><strong>blank_label</strong> (<em>{'first'</em><em>, </em><em>'last'}</em><em>,</em><em>optional</em><em>, </em><em>default='first'</em>) – Set the label that is reserved for blank label.If “first”, 0-th label is reserved, and label values for tokens in the vocabulary are between <code class="docutils literal"><span class="pre">1</span></code> and <code class="docutils literal"><span class="pre">alphabet_size-1</span></code>, and the padding mask is <code class="docutils literal"><span class="pre">-1</span></code>. If “last”, last label value <code class="docutils literal"><span class="pre">alphabet_size-1</span></code> is reserved for blank label instead, and label values for tokens in the vocabulary are between <code class="docutils literal"><span class="pre">0</span></code> and <code class="docutils literal"><span class="pre">alphabet_size-2</span></code>, and the padding mask is <code class="docutils literal"><span class="pre">0</span></code>.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Cast">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Cast</code><span class="sig-paren">(</span><em>data=None</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Casts all elements of the input to a new type.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">Cast</span></code> is deprecated. Use <code class="docutils literal"><span class="pre">cast</span></code> instead.</p>
</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cast</span><span class="p">([</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'int32'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">cast</span><span class="p">([</span><span class="mf">1e20</span><span class="p">,</span> <span class="mf">11.1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'float16'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="mf">11.09375</span><span class="p">]</span>
<span class="n">cast</span><span class="p">([</span><span class="mi">300</span><span class="p">,</span> <span class="mf">11.1</span><span class="p">,</span> <span class="mf">10.9</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'uint8'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">44</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">253</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L634</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input.</li>
<li><strong>dtype</strong> (<em>{'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'</em><em>, </em><em>'int32'</em><em>, </em><em>'int64'</em><em>, </em><em>'int8'</em><em>, </em><em>'uint8'}</em><em>, </em><em>required</em>) – Output data type.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Concat">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Concat</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Joins input arrays along a given axis.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>Concat</cite> is deprecated. Use <cite>concat</cite> instead.</p>
</div>
<p>The dimensions of the input arrays should be the same except the axis along
which they will be concatenated.
The dimension of the output array along the concatenated axis will be equal
to the sum of the corresponding dimensions of the input arrays.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">concat</span></code> output depends on storage types of inputs</p>
<ul class="simple">
<li>concat(csr, csr, ..., csr, dim=0) = csr</li>
<li>otherwise, <code class="docutils literal"><span class="pre">concat</span></code> generates output with default storage</li>
</ul>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">]]</span>

<span class="n">concat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">6.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">7.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">8.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]</span>

<span class="n">Note</span> <span class="n">that</span> <span class="n">you</span> <span class="n">cannot</span> <span class="n">concat</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="n">along</span> <span class="n">dimension</span> <span class="mi">1</span> <span class="n">since</span> <span class="n">dimension</span>
<span class="mi">0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">the</span> <span class="n">same</span> <span class="k">for</span> <span class="nb">all</span> <span class="n">the</span> <span class="nb">input</span> <span class="n">arrays</span><span class="o">.</span>

<span class="n">concat</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/nn/concat.cc:L371</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>[</em><em>]</em>) – List of arrays to concatenate</li>
<li><strong>dim</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='1'</em>) – the dimension to be concated.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Convolution">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Convolution</code><span class="sig-paren">(</span><em>data=None</em>, <em>weight=None</em>, <em>bias=None</em>, <em>kernel=_Null</em>, <em>stride=_Null</em>, <em>dilate=_Null</em>, <em>pad=_Null</em>, <em>num_filter=_Null</em>, <em>num_group=_Null</em>, <em>workspace=_Null</em>, <em>no_bias=_Null</em>, <em>cudnn_tune=_Null</em>, <em>cudnn_off=_Null</em>, <em>layout=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Convolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute <em>N</em>-D convolution on <em>(N+2)</em>-D input.</p>
<p>In the 2-D convolution, given input data with shape <em>(batch_size,
channel, height, width)</em>, the output is computed by</p>
<div class="math">
\[out[n,i,:,:] = bias[i] + \sum_{j=0}^{channel} data[n,j,:,:] \star
weight[i,j,:,:]\]</div>
<p>where <span class="math">\(\star\)</span> is the 2-D cross-correlation operator.</p>
<p>For general 2-D convolution, the shapes are</p>
<ul class="simple">
<li><strong>data</strong>: <em>(batch_size, channel, height, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0], kernel[1])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch_size, num_filter, out_height, out_width)</em>.</li>
</ul>
<p>Define:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">floor</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">-</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
<p>then we have:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">out_height</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stride</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dilate</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">out_width</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pad</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stride</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dilate</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">no_bias</span></code> is set to be true, then the <code class="docutils literal"><span class="pre">bias</span></code> term is ignored.</p>
<p>The default data <code class="docutils literal"><span class="pre">layout</span></code> is <em>NCHW</em>, namely <em>(batch_size, channel, height,
width)</em>. We can choose other layouts such as <em>NWC</em>.</p>
<p>If <code class="docutils literal"><span class="pre">num_group</span></code> is larger than 1, denoted by <em>g</em>, then split the input <code class="docutils literal"><span class="pre">data</span></code>
evenly into <em>g</em> parts along the channel axis, and also evenly split <code class="docutils literal"><span class="pre">weight</span></code>
along the first dimension. Next compute the convolution on the <em>i</em>-th part of
the data with the <em>i</em>-th weight part. The output is obtained by concatenating all
the <em>g</em> results.</p>
<p>1-D convolution does not have <em>height</em> dimension but only <em>width</em> in space.</p>
<ul class="simple">
<li><strong>data</strong>: <em>(batch_size, channel, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch_size, num_filter, out_width)</em>.</li>
</ul>
<p>3-D convolution adds an additional <em>depth</em> dimension besides <em>height</em> and
<em>width</em>. The shapes are</p>
<ul class="simple">
<li><strong>data</strong>: <em>(batch_size, channel, depth, height, width)</em></li>
<li><strong>weight</strong>: <em>(num_filter, channel, kernel[0], kernel[1], kernel[2])</em></li>
<li><strong>bias</strong>: <em>(num_filter,)</em></li>
<li><strong>out</strong>: <em>(batch_size, num_filter, out_depth, out_height, out_width)</em>.</li>
</ul>
<p>Both <code class="docutils literal"><span class="pre">weight</span></code> and <code class="docutils literal"><span class="pre">bias</span></code> are learnable parameters.</p>
<p>There are other options to tune the performance.</p>
<ul class="simple">
<li><strong>cudnn_tune</strong>: enable this option leads to higher startup time but may give
faster speed. Options are<ul>
<li><strong>off</strong>: no tuning</li>
<li><strong>limited_workspace</strong>:run test and pick the fastest algorithm that doesn’t
exceed workspace limit.</li>
<li><strong>fastest</strong>: pick the fastest algorithm and ignore workspace limit.</li>
<li><strong>None</strong> (default): the behavior is determined by environment variable
<code class="docutils literal"><span class="pre">MXNET_CUDNN_AUTOTUNE_DEFAULT</span></code>. 0 for off, 1 for limited workspace
(default), 2 for fastest.</li>
</ul>
</li>
<li><strong>workspace</strong>: A large number leads to more (GPU) memory usage but may improve
the performance.</li>
</ul>
<p>Defined in src/operator/nn/convolution.cc:L472</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to the ConvolutionOp.</li>
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight matrix.</li>
<li><strong>bias</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Bias parameter.</li>
<li><strong>kernel</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>required</em>) – Convolution kernel size: (w,), (h, w) or (d, h, w)</li>
<li><strong>stride</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><strong>dilate</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><strong>pad</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding.</li>
<li><strong>num_filter</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>required</em>) – Convolution filter(channel) number</li>
<li><strong>num_group</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Number of group partitions.</li>
<li><strong>workspace</strong> (<em>long</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=1024</em>) – Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when <cite>limited_workspace</cite> strategy is used.</li>
<li><strong>no_bias</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to disable bias parameter.</li>
<li><strong>cudnn_tune</strong> (<em>{None</em><em>, </em><em>'fastest'</em><em>, </em><em>'limited_workspace'</em><em>, </em><em>'off'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – Whether to pick convolution algo by running performance test.</li>
<li><strong>cudnn_off</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Turn off cudnn for this layer.</li>
<li><strong>layout</strong> (<em>{None</em><em>, </em><em>'NCDHW'</em><em>, </em><em>'NCHW'</em><em>, </em><em>'NCW'</em><em>, </em><em>'NDHWC'</em><em>, </em><em>'NHWC'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – Set layout for input, output and weight. Empty for
default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Convolution_v1">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Convolution_v1</code><span class="sig-paren">(</span><em>data=None</em>, <em>weight=None</em>, <em>bias=None</em>, <em>kernel=_Null</em>, <em>stride=_Null</em>, <em>dilate=_Null</em>, <em>pad=_Null</em>, <em>num_filter=_Null</em>, <em>num_group=_Null</em>, <em>workspace=_Null</em>, <em>no_bias=_Null</em>, <em>cudnn_tune=_Null</em>, <em>cudnn_off=_Null</em>, <em>layout=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Convolution_v1" title="Permalink to this definition">¶</a></dt>
<dd><p>This operator is DEPRECATED. Apply convolution to input then add a bias.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to the ConvolutionV1Op.</li>
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight matrix.</li>
<li><strong>bias</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Bias parameter.</li>
<li><strong>kernel</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>required</em>) – convolution kernel size: (h, w) or (d, h, w)</li>
<li><strong>stride</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – convolution stride: (h, w) or (d, h, w)</li>
<li><strong>dilate</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – convolution dilate: (h, w) or (d, h, w)</li>
<li><strong>pad</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – pad for convolution: (h, w) or (d, h, w)</li>
<li><strong>num_filter</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>required</em>) – convolution filter(channel) number</li>
<li><strong>num_group</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Number of group partitions. Equivalent to slicing input into num_group
partitions, apply convolution on each, then concatenate the results</li>
<li><strong>workspace</strong> (<em>long</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=1024</em>) – Maximum temporary workspace allowed for convolution (MB).This parameter determines the effective batch size of the convolution kernel, which may be smaller than the given batch size. Also, the workspace will be automatically enlarged to make sure that we can run the kernel with batch_size=1</li>
<li><strong>no_bias</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to disable bias parameter.</li>
<li><strong>cudnn_tune</strong> (<em>{None</em><em>, </em><em>'fastest'</em><em>, </em><em>'limited_workspace'</em><em>, </em><em>'off'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – Whether to pick convolution algo by running performance test.
Leads to higher startup time but may give faster speed. Options are:
‘off’: no tuning
‘limited_workspace’: run test and pick the fastest algorithm that doesn’t exceed workspace limit.
‘fastest’: pick the fastest algorithm and ignore workspace limit.
If set to None (default), behavior is determined by environment
variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off,
1 for limited workspace (default), 2 for fastest.</li>
<li><strong>cudnn_off</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Turn off cudnn for this layer.</li>
<li><strong>layout</strong> (<em>{None</em><em>, </em><em>'NCDHW'</em><em>, </em><em>'NCHW'</em><em>, </em><em>'NDHWC'</em><em>, </em><em>'NHWC'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – Set layout for input, output and weight. Empty for
default layout: NCHW for 2d and NCDHW for 3d.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Correlation">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Correlation</code><span class="sig-paren">(</span><em>data1=None</em>, <em>data2=None</em>, <em>kernel_size=_Null</em>, <em>max_displacement=_Null</em>, <em>stride1=_Null</em>, <em>stride2=_Null</em>, <em>pad_size=_Null</em>, <em>is_multiply=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies correlation to inputs.</p>
<p>The correlation layer performs multiplicative patch comparisons between two feature maps.</p>
<p>Given two multi-channel feature maps <span class="math">\(f_{1}, f_{2}\)</span>, with <span class="math">\(w\)</span>, <span class="math">\(h\)</span>, and <span class="math">\(c\)</span> being their width, height, and number of channels,
the correlation layer lets the network compare each patch from <span class="math">\(f_{1}\)</span> with each patch from <span class="math">\(f_{2}\)</span>.</p>
<p>For now we consider only a single comparison of two patches. The ‘correlation’ of two patches centered at <span class="math">\(x_{1}\)</span> in the first map and
<span class="math">\(x_{2}\)</span> in the second map is then defined as:</p>
<div class="math">
\[c(x_{1}, x_{2}) = \sum_{o \in [-k,k] \times [-k,k]} <f_{1}(x_{1} + o), f_{2}(x_{2} + o)>\]</div>
<p>for a square patch of size <span class="math">\(K:=2k+1\)</span>.</p>
<p>Note that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other
data. For this reason, it has no training weights.</p>
<p>Computing <span class="math">\(c(x_{1}, x_{2})\)</span> involves <span class="math">\(c * K^{2}\)</span> multiplications. Comparing all patch combinations involves <span class="math">\(w^{2}*h^{2}\)</span> such computations.</p>
<p>Given a maximum displacement <span class="math">\(d\)</span>, for each location <span class="math">\(x_{1}\)</span> it computes correlations <span class="math">\(c(x_{1}, x_{2})\)</span> only in a neighborhood of size <span class="math">\(D:=2d+1\)</span>,
by limiting the range of <span class="math">\(x_{2}\)</span>. We use strides <span class="math">\(s_{1}, s_{2}\)</span>, to quantize <span class="math">\(x_{1}\)</span> globally and to quantize <span class="math">\(x_{2}\)</span> within the neighborhood
centered around <span class="math">\(x_{1}\)</span>.</p>
<p>The final output is defined by the following expression:</p>
<div class="math">
\[out[n, q, i, j] = c(x_{i, j}, x_{q})\]</div>
<p>where <span class="math">\(i\)</span> and <span class="math">\(j\)</span> enumerate spatial locations in <span class="math">\(f_{1}\)</span>, and <span class="math">\(q\)</span> denotes the <span class="math">\(q^{th}\)</span> neighborhood of <span class="math">\(x_{i,j}\)</span>.</p>
<p>Defined in src/operator/correlation.cc:L198</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data1</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data1 to the correlation.</li>
<li><strong>data2</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data2 to the correlation.</li>
<li><strong>kernel_size</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – kernel size for Correlation must be an odd number</li>
<li><strong>max_displacement</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Max displacement of Correlation</li>
<li><strong>stride1</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – stride1 quantize data1 globally</li>
<li><strong>stride2</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – stride2 quantize data2 within the neighborhood centered around data1</li>
<li><strong>pad_size</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – pad for Correlation</li>
<li><strong>is_multiply</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – operation type is either multiplication or subduction</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Crop">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Crop</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Crop" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>Crop</cite> is deprecated. Use <cite>slice</cite> instead.</p>
</div>
<p>Crop the 2nd and 3rd dim of input data, with the corresponding size of h_w or
with width and height of the second input symbol, i.e., with one input, we need h_w to
specify the crop height and width, otherwise the second input symbol’s size will be used</p>
<p>Defined in src/operator/crop.cc:L50</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="../symbol/symbol.html#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a><em> or </em><a class="reference internal" href="../symbol/symbol.html#mxnet.symbol.Symbol" title="mxnet.symbol.Symbol"><em>Symbol</em></a><em>[</em><em>]</em>) – Tensor or List of Tensors, the second input will be used as crop_like shape reference</li>
<li><strong>offset</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>0</em><em>,</em><em>0</em><em>]</em>) – crop offset coordinate: (y, x)</li>
<li><strong>h_w</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>0</em><em>,</em><em>0</em><em>]</em>) – crop height and width: (h, w)</li>
<li><strong>center_crop</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If set to true, then it will use be the center_crop,or it will crop using the shape of crop_like</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Custom">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Custom</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Custom" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a custom operator implemented in a frontend language (like Python).</p>
<p>Custom operators should override required methods like <cite>forward</cite> and <cite>backward</cite>.
The custom operator must be registered before it can be used.
Please check the tutorial here: <a class="reference external" href="/faq/new_op.html">/faq/new_op.html</a>.</p>
<p>Defined in src/operator/custom/custom.cc:L546</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>[</em><em>]</em>) – Input data for the custom operator.</li>
<li><strong>op_type</strong> (<em>string</em>) – Name of the custom operator. This is the name that is passed to <cite>mx.operator.register</cite> to register the operator.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<p>Applies a custom operator named <cite>my_custom_operator</cite> to <cite>input</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">output</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">symbol</span><span class="o">.</span><span class="n">Custom</span><span class="p">(</span><span class="n">op_type</span><span class="o">=</span><span class="s1">'my_custom_operator'</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="nb">input</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Deconvolution">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Deconvolution</code><span class="sig-paren">(</span><em>data=None</em>, <em>weight=None</em>, <em>bias=None</em>, <em>kernel=_Null</em>, <em>stride=_Null</em>, <em>dilate=_Null</em>, <em>pad=_Null</em>, <em>adj=_Null</em>, <em>target_shape=_Null</em>, <em>num_filter=_Null</em>, <em>num_group=_Null</em>, <em>workspace=_Null</em>, <em>no_bias=_Null</em>, <em>cudnn_tune=_Null</em>, <em>cudnn_off=_Null</em>, <em>layout=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Deconvolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input tensor to the deconvolution operation.</li>
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weights representing the kernel.</li>
<li><strong>bias</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Bias added to the result after the deconvolution operation.</li>
<li><strong>kernel</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>required</em>) – Deconvolution kernel size: (w,), (h, w) or (d, h, w). This is same as the kernel size used for the corresponding convolution</li>
<li><strong>stride</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – The stride used for the corresponding convolution: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><strong>dilate</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – Dilation factor for each dimension of the input: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension.</li>
<li><strong>pad</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – The amount of implicit zero padding added during convolution for each dimension of the input: (w,), (h, w) or (d, h, w). <code class="docutils literal"><span class="pre">(kernel-1)/2</span></code> is usually a good choice. If <cite>target_shape</cite> is set, <cite>pad</cite> will be ignored and a padding that will generate the target shape will be used. Defaults to no padding.</li>
<li><strong>adj</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – Adjustment for output shape: (w,), (h, w) or (d, h, w). If <cite>target_shape</cite> is set, <cite>adj</cite> will be ignored and computed accordingly.</li>
<li><strong>target_shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – Shape of the output tensor: (w,), (h, w) or (d, h, w).</li>
<li><strong>num_filter</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>required</em>) – Number of output filters.</li>
<li><strong>num_group</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Number of groups partition.</li>
<li><strong>workspace</strong> (<em>long</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=512</em>) – Maximum temporary workspace allowed (MB) in deconvolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the deconvolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when <cite>limited_workspace</cite> strategy is used.</li>
<li><strong>no_bias</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Whether to disable bias parameter.</li>
<li><strong>cudnn_tune</strong> (<em>{None</em><em>, </em><em>'fastest'</em><em>, </em><em>'limited_workspace'</em><em>, </em><em>'off'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – Whether to pick convolution algorithm by running performance test.</li>
<li><strong>cudnn_off</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Turn off cudnn for this layer.</li>
<li><strong>layout</strong> (<em>{None</em><em>, </em><em>'NCDHW'</em><em>, </em><em>'NCHW'</em><em>, </em><em>'NCW'</em><em>, </em><em>'NDHWC'</em><em>, </em><em>'NHWC'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Dropout">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Dropout</code><span class="sig-paren">(</span><em>data=None</em>, <em>p=_Null</em>, <em>mode=_Null</em>, <em>axes=_Null</em>, <em>cudnn_off=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Dropout" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies dropout operation to input array.</p>
<ul class="simple">
<li>During training, each element of the input is set to zero with probability p.
The whole array is rescaled by <span class="math">\(1/(1-p)\)</span> to keep the expected
sum of the input unchanged.</li>
<li>During testing, this operator does not change the input if mode is ‘training’.
If mode is ‘always’, the same computaion as during training will be applied.</li>
</ul>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">998</span><span class="p">)</span>
<span class="n">input_array</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span>  <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">],</span>
                    <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4</span><span class="p">,</span>   <span class="mf">7.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]])</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="n">dropout</span> <span class="o">=</span> <span class="n">symbol</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="n">executor</span> <span class="o">=</span> <span class="n">dropout</span><span class="o">.</span><span class="n">simple_bind</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="n">input_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="c1">## If training</span>
<span class="n">executor</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">is_train</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">input_array</span><span class="p">)</span>
<span class="n">executor</span><span class="o">.</span><span class="n">outputs</span>
<span class="p">[[</span> <span class="mf">3.75</span>   <span class="mf">0.625</span> <span class="o">-</span><span class="mf">0.</span>     <span class="mf">2.5</span>    <span class="mf">8.75</span> <span class="p">]</span>
 <span class="p">[</span> <span class="mf">2.5</span>   <span class="o">-</span><span class="mf">0.5</span>    <span class="mf">8.75</span>   <span class="mf">3.75</span>   <span class="mf">0.</span>   <span class="p">]]</span>

<span class="c1">## If testing</span>
<span class="n">executor</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">is_train</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">input_array</span><span class="p">)</span>
<span class="n">executor</span><span class="o">.</span><span class="n">outputs</span>
<span class="p">[[</span> <span class="mf">3.</span>     <span class="mf">0.5</span>   <span class="o">-</span><span class="mf">0.5</span>    <span class="mf">2.</span>     <span class="mf">7.</span>   <span class="p">]</span>
 <span class="p">[</span> <span class="mf">2.</span>    <span class="o">-</span><span class="mf">0.4</span>    <span class="mf">7.</span>     <span class="mf">3.</span>     <span class="mf">0.2</span>  <span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/nn/dropout.cc:L95</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input array to which dropout will be applied.</li>
<li><strong>p</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.5</em>) – Fraction of the input that gets dropped out during training time.</li>
<li><strong>mode</strong> (<em>{'always'</em><em>, </em><em>'training'}</em><em>,</em><em>optional</em><em>, </em><em>default='training'</em>) – Whether to only turn on dropout during training or to also turn on for inference.</li>
<li><strong>axes</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – Axes for variational dropout kernel.</li>
<li><strong>cudnn_off</strong> (<em>boolean</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to turn off cudnn in dropout operator. This option is ignored if axes is specified.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.ElementWiseSum">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">ElementWiseSum</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.ElementWiseSum" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds all input arguments element-wise.</p>
<div class="math">
\[add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\]</div>
<p><code class="docutils literal"><span class="pre">add_n</span></code> is potentially more efficient than calling <code class="docutils literal"><span class="pre">add</span></code> by <cite>n</cite> times.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">add_n</span></code> output depends on storage types of inputs</p>
<ul class="simple">
<li>add_n(row_sparse, row_sparse, ..) = row_sparse</li>
<li>add_n(default, csr, default) = default</li>
<li>add_n(any input combinations longer than 4 (>4) with at least one default type) = default</li>
<li>otherwise, <code class="docutils literal"><span class="pre">add_n</span></code> falls all inputs back to default storage and generates default storage</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_sum.cc:L155</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>[</em><em>]</em>) – Positional input arguments</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Embedding">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Embedding</code><span class="sig-paren">(</span><em>data=None</em>, <em>weight=None</em>, <em>input_dim=_Null</em>, <em>output_dim=_Null</em>, <em>dtype=_Null</em>, <em>sparse_grad=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Embedding" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps integer indices to vector representations (embeddings).</p>
<p>This operator maps words to real-valued vectors in a high-dimensional space,
called word embeddings. These embeddings can capture semantic and syntactic properties of the words.
For example, it has been noted that in the learned embedding spaces, similar words tend
to be close to each other and dissimilar words far apart.</p>
<p>For an input array of shape (d1, ..., dK),
the shape of an output array is (d1, ..., dK, output_dim).
All the input values should be integers in the range [0, input_dim).</p>
<p>If the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be
(ip0, op0).</p>
<p>By default, if any index mentioned is too large, it is replaced by the index that addresses
the last vector in an embedding matrix.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">input_dim</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">output_dim</span> <span class="o">=</span> <span class="mi">5</span>

<span class="o">//</span> <span class="n">Each</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">weight</span> <span class="n">matrix</span> <span class="n">y</span> <span class="n">represents</span> <span class="n">a</span> <span class="n">word</span><span class="o">.</span> <span class="n">So</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">w0</span><span class="p">,</span><span class="n">w1</span><span class="p">,</span><span class="n">w2</span><span class="p">,</span><span class="n">w3</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">0.</span><span class="p">,</span>   <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">,</span>   <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">,</span>   <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>   <span class="mf">9.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">,</span>  <span class="mf">13.</span><span class="p">,</span>  <span class="mf">14.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">15.</span><span class="p">,</span>  <span class="mf">16.</span><span class="p">,</span>  <span class="mf">17.</span><span class="p">,</span>  <span class="mf">18.</span><span class="p">,</span>  <span class="mf">19.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Input</span> <span class="n">array</span> <span class="n">x</span> <span class="n">represents</span> <span class="n">n</span><span class="o">-</span><span class="n">grams</span><span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="n">gram</span><span class="p">)</span><span class="o">.</span> <span class="n">So</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[(</span><span class="n">w1</span><span class="p">,</span><span class="n">w3</span><span class="p">),</span> <span class="p">(</span><span class="n">w0</span><span class="p">,</span><span class="n">w2</span><span class="p">)]</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Mapped</span> <span class="nb">input</span> <span class="n">x</span> <span class="n">to</span> <span class="n">its</span> <span class="n">vector</span> <span class="n">representation</span> <span class="n">y</span><span class="o">.</span>
<span class="n">Embedding</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span>  <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">,</span>   <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>   <span class="mf">9.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">15.</span><span class="p">,</span>  <span class="mf">16.</span><span class="p">,</span>  <span class="mf">17.</span><span class="p">,</span>  <span class="mf">18.</span><span class="p">,</span>  <span class="mf">19.</span><span class="p">]],</span>

                         <span class="p">[[</span>  <span class="mf">0.</span><span class="p">,</span>   <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">,</span>   <span class="mf">4.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">,</span>  <span class="mf">13.</span><span class="p">,</span>  <span class="mf">14.</span><span class="p">]]]</span>
</pre></div>
</div>
<p>The storage type of weight can be either row_sparse or default.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If “sparse_grad” is set to True, the storage type of gradient w.r.t weights will be
“row_sparse”. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
and Adam. Note that by default lazy updates is turned on, which may perform differently
from standard updates. For more details, please check the Optimization API at:
<a class="reference external" href="/api/python/optimization/optimization.html">/api/python/optimization/optimization.html</a></p>
</div>
<p>Defined in src/operator/tensor/indexing_op.cc:L519</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array to the embedding operator.</li>
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The embedding weight matrix.</li>
<li><strong>input_dim</strong> (<em>int</em><em>, </em><em>required</em>) – Vocabulary size of the input indices.</li>
<li><strong>output_dim</strong> (<em>int</em><em>, </em><em>required</em>) – Dimension of the embedding vectors.</li>
<li><strong>dtype</strong> (<em>{'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'</em><em>, </em><em>'int32'</em><em>, </em><em>'int64'</em><em>, </em><em>'int8'</em><em>, </em><em>'uint8'}</em><em>,</em><em>optional</em><em>, </em><em>default='float32'</em>) – Data type of weight.</li>
<li><strong>sparse_grad</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Compute row sparse gradient in the backward calculation. If set to True, the grad’s storage type is row_sparse.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Flatten">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Flatten</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Flattens the input array into a 2-D array by collapsing the higher dimensions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>Flatten</cite> is deprecated. Use <cite>flatten</cite> instead.</p>
</div>
<p>For an input array with shape <code class="docutils literal"><span class="pre">(d1,</span> <span class="pre">d2,</span> <span class="pre">...,</span> <span class="pre">dk)</span></code>, <cite>flatten</cite> operation reshapes
the input array into an output array of shape <code class="docutils literal"><span class="pre">(d1,</span> <span class="pre">d2*...*dk)</span></code>.</p>
<p>Note that the bahavior of this function is different from numpy.ndarray.flatten,
which behaves similar to mxnet.ndarray.reshape((-1,)).</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="p">],</span>
<span class="p">[</span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="p">]],</span>

<span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">],</span>
   <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L291</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.FullyConnected">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">FullyConnected</code><span class="sig-paren">(</span><em>data=None</em>, <em>weight=None</em>, <em>bias=None</em>, <em>num_hidden=_Null</em>, <em>no_bias=_Null</em>, <em>flatten=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.FullyConnected" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a linear transformation: <span class="math">\(Y = XW^T + b\)</span>.</p>
<p>If <code class="docutils literal"><span class="pre">flatten</span></code> is set to be true, then the shapes are:</p>
<ul class="simple">
<li><strong>data</strong>: <cite>(batch_size, x1, x2, ..., xn)</cite></li>
<li><strong>weight</strong>: <cite>(num_hidden, x1 * x2 * ... * xn)</cite></li>
<li><strong>bias</strong>: <cite>(num_hidden,)</cite></li>
<li><strong>out</strong>: <cite>(batch_size, num_hidden)</cite></li>
</ul>
<p>If <code class="docutils literal"><span class="pre">flatten</span></code> is set to be false, then the shapes are:</p>
<ul class="simple">
<li><strong>data</strong>: <cite>(x1, x2, ..., xn, input_dim)</cite></li>
<li><strong>weight</strong>: <cite>(num_hidden, input_dim)</cite></li>
<li><strong>bias</strong>: <cite>(num_hidden,)</cite></li>
<li><strong>out</strong>: <cite>(x1, x2, ..., xn, num_hidden)</cite></li>
</ul>
<p>The learnable parameters include both <code class="docutils literal"><span class="pre">weight</span></code> and <code class="docutils literal"><span class="pre">bias</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">no_bias</span></code> is set to be true, then the <code class="docutils literal"><span class="pre">bias</span></code> term is ignored.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The sparse support for FullyConnected is limited to forward evaluation with <cite>row_sparse</cite>
weight and bias, where the length of <cite>weight.indices</cite> and <cite>bias.indices</cite> must be equal
to <cite>num_hidden</cite>. This could be useful for model inference with <cite>row_sparse</cite> weights
trained with importance sampling or noise contrastive estimation.</p>
<p class="last">To compute linear transformation with ‘csr’ sparse data, sparse.dot is recommended instead
of sparse.FullyConnected.</p>
</div>
<p>Defined in src/operator/nn/fully_connected.cc:L277</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data.</li>
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight matrix.</li>
<li><strong>bias</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Bias parameter.</li>
<li><strong>num_hidden</strong> (<em>int</em><em>, </em><em>required</em>) – Number of hidden nodes of the output.</li>
<li><strong>no_bias</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to disable bias parameter.</li>
<li><strong>flatten</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Whether to collapse all but the first axis of the input data tensor.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.GridGenerator">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">GridGenerator</code><span class="sig-paren">(</span><em>data=None</em>, <em>transform_type=_Null</em>, <em>target_shape=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.GridGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates 2D sampling grid for bilinear sampling.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to the function.</li>
<li><strong>transform_type</strong> (<em>{'affine'</em><em>, </em><em>'warp'}</em><em>, </em><em>required</em>) – The type of transformation. For <cite>affine</cite>, input data should be an affine matrix of size (batch, 6). For <cite>warp</cite>, input data should be an optical flow of size (batch, 2, h, w).</li>
<li><strong>target_shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>0</em><em>,</em><em>0</em><em>]</em>) – Specifies the output shape (H, W). This is required if transformation type is <cite>affine</cite>. If transformation type is <cite>warp</cite>, this parameter is ignored.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.IdentityAttachKLSparseReg">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">IdentityAttachKLSparseReg</code><span class="sig-paren">(</span><em>data=None</em>, <em>sparseness_target=_Null</em>, <em>penalty=_Null</em>, <em>momentum=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.IdentityAttachKLSparseReg" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a sparse regularization to the output a sigmoid activation function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data.</li>
<li><strong>sparseness_target</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.100000001</em>) – The sparseness target</li>
<li><strong>penalty</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.00100000005</em>) – The tradeoff parameter for the sparseness penalty</li>
<li><strong>momentum</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.899999976</em>) – The momentum for running average</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.InstanceNorm">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">InstanceNorm</code><span class="sig-paren">(</span><em>data=None</em>, <em>gamma=None</em>, <em>beta=None</em>, <em>eps=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.InstanceNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies instance normalization to the n-dimensional input array.</p>
<p>This operator takes an n-dimensional input array where (n>2) and normalizes
the input using the following formula:</p>
<div class="math">
\[out = \frac{x - mean[data]}{ \sqrt{Var[data]} + \epsilon} * gamma + beta\]</div>
<p>This layer is similar to batch normalization layer (<cite>BatchNorm</cite>)
with two differences: first, the normalization is
carried out per example (instance), not over a batch. Second, the
same normalization is applied both at test and train time. This
operation is also known as <cite>contrast normalization</cite>.</p>
<p>If the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, ...],
<cite>gamma</cite> and <cite>beta</cite> parameters must be vectors of shape [channel].</p>
<p>This implementation is based on paper:</p>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Instance Normalization: The Missing Ingredient for Fast Stylization,
D. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).</td></tr>
</tbody>
</table>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Input</span> <span class="n">of</span> <span class="n">shape</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.1</span><span class="p">,</span>  <span class="mf">2.2</span><span class="p">]],</span>
     <span class="p">[[</span> <span class="mf">3.3</span><span class="p">,</span>  <span class="mf">4.4</span><span class="p">]]]</span>

<span class="o">//</span> <span class="n">gamma</span> <span class="n">parameter</span> <span class="n">of</span> <span class="n">length</span> <span class="mi">1</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">]</span>

<span class="o">//</span> <span class="n">beta</span> <span class="n">parameter</span> <span class="n">of</span> <span class="n">length</span> <span class="mi">1</span>
<span class="n">beta</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">]</span>

<span class="o">//</span> <span class="n">Instance</span> <span class="n">normalization</span> <span class="ow">is</span> <span class="n">calculated</span> <span class="k">with</span> <span class="n">the</span> <span class="n">above</span> <span class="n">formula</span>
<span class="n">InstanceNorm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">gamma</span><span class="p">,</span><span class="n">beta</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span><span class="o">-</span><span class="mf">0.997527</span>  <span class="p">,</span>  <span class="mf">1.99752665</span><span class="p">]],</span>
                              <span class="p">[[</span><span class="o">-</span><span class="mf">0.99752653</span><span class="p">,</span>  <span class="mf">1.99752724</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/instance_norm.cc:L95</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – An n-dimensional input array (n > 2) of the form [batch, channel, spatial_dim1, spatial_dim2, ...].</li>
<li><strong>gamma</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – A vector of length ‘channel’, which multiplies the normalized input.</li>
<li><strong>beta</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – A vector of length ‘channel’, which is added to the product of the normalized input and the weight.</li>
<li><strong>eps</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.00100000005</em>) – An <cite>epsilon</cite> parameter to prevent division by 0.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.L2Normalization">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">L2Normalization</code><span class="sig-paren">(</span><em>data=None</em>, <em>eps=_Null</em>, <em>mode=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.L2Normalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize the input array using the L2 norm.</p>
<p>For 1-D NDArray, it computes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="n">data</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">data</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
</pre></div>
</div>
<p>For N-D NDArray, if the input array has shape (N, N, ..., N),</p>
<p>with <code class="docutils literal"><span class="pre">mode</span></code> = <code class="docutils literal"><span class="pre">instance</span></code>, it normalizes each instance in the multidimensional
array by its L2 norm.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">..</span><span class="n">N</span>
  <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:,</span><span class="o">...</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:,</span><span class="o">...</span><span class="p">,:]</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:,</span><span class="o">...</span><span class="p">,:]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal"><span class="pre">mode</span></code> = <code class="docutils literal"><span class="pre">channel</span></code>, it normalizes each channel in the array by its L2 norm.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">..</span><span class="n">N</span>
  <span class="n">out</span><span class="p">[:,</span><span class="n">i</span><span class="p">,:,</span><span class="o">...</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="n">i</span><span class="p">,:,</span><span class="o">...</span><span class="p">,:]</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="n">i</span><span class="p">,:,</span><span class="o">...</span><span class="p">,:]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal"><span class="pre">mode</span></code> = <code class="docutils literal"><span class="pre">spatial</span></code>, it normalizes the cross channel norm for each position
in the array by its L2 norm.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="mf">2.</span><span class="o">..</span><span class="n">N</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="mf">0.</span><span class="o">..</span><span class="n">N</span>
    <span class="n">out</span><span class="p">[</span><span class="o">.....</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">take</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
        <span class="o">-</span><span class="n">dim</span><span class="o">-</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span>
     <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]]</span>

<span class="n">L2Normalization</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'instance'</span><span class="p">)</span>
<span class="o">=</span><span class="p">[[[</span> <span class="mf">0.18257418</span>  <span class="mf">0.36514837</span><span class="p">]</span>
   <span class="p">[</span> <span class="mf">0.54772252</span>  <span class="mf">0.73029673</span><span class="p">]]</span>
  <span class="p">[[</span> <span class="mf">0.24077171</span>  <span class="mf">0.24077171</span><span class="p">]</span>
   <span class="p">[</span> <span class="mf">0.60192931</span>  <span class="mf">0.72231513</span><span class="p">]]]</span>

<span class="n">L2Normalization</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'channel'</span><span class="p">)</span>
<span class="o">=</span><span class="p">[[[</span> <span class="mf">0.31622776</span>  <span class="mf">0.44721359</span><span class="p">]</span>
   <span class="p">[</span> <span class="mf">0.94868326</span>  <span class="mf">0.89442718</span><span class="p">]]</span>
  <span class="p">[[</span> <span class="mf">0.37139067</span>  <span class="mf">0.31622776</span><span class="p">]</span>
   <span class="p">[</span> <span class="mf">0.92847669</span>  <span class="mf">0.94868326</span><span class="p">]]]</span>

<span class="n">L2Normalization</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'spatial'</span><span class="p">)</span>
<span class="o">=</span><span class="p">[[[</span> <span class="mf">0.44721359</span>  <span class="mf">0.89442718</span><span class="p">]</span>
   <span class="p">[</span> <span class="mf">0.60000002</span>  <span class="mf">0.80000001</span><span class="p">]]</span>
  <span class="p">[[</span> <span class="mf">0.70710677</span>  <span class="mf">0.70710677</span><span class="p">]</span>
   <span class="p">[</span> <span class="mf">0.6401844</span>   <span class="mf">0.76822126</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/l2_normalization.cc:L196</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input array to normalize.</li>
<li><strong>eps</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1.00000001e-10</em>) – A small constant for numerical stability.</li>
<li><strong>mode</strong> (<em>{'channel'</em><em>, </em><em>'instance'</em><em>, </em><em>'spatial'}</em><em>,</em><em>optional</em><em>, </em><em>default='instance'</em>) – Specify the dimension along which to compute L2 norm.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.LRN">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">LRN</code><span class="sig-paren">(</span><em>data=None</em>, <em>alpha=_Null</em>, <em>beta=_Null</em>, <em>knorm=_Null</em>, <em>nsize=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.LRN" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies local response normalization to the input.</p>
<p>The local response normalization layer performs “lateral inhibition” by normalizing
over local input regions.</p>
<p>If <span class="math">\(a_{x,y}^{i}\)</span> is the activity of a neuron computed by applying kernel <span class="math">\(i\)</span> at position
<span class="math">\((x, y)\)</span> and then applying the ReLU nonlinearity, the response-normalized
activity <span class="math">\(b_{x,y}^{i}\)</span> is given by the expression:</p>
<div class="math">
\[b_{x,y}^{i} = \frac{a_{x,y}^{i}}{\Bigg({k + \frac{\alpha}{n} \sum_{j=max(0, i-\frac{n}{2})}^{min(N-1, i+\frac{n}{2})} (a_{x,y}^{j})^{2}}\Bigg)^{\beta}}\]</div>
<p>where the sum runs over <span class="math">\(n\)</span> “adjacent” kernel maps at the same spatial position, and <span class="math">\(N\)</span> is the total
number of kernels in the layer.</p>
<p>Defined in src/operator/nn/lrn.cc:L164</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to LRN</li>
<li><strong>alpha</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=9.99999975e-05</em>) – The variance scaling parameter <span class="math">\(lpha\)</span> in the LRN expression.</li>
<li><strong>beta</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.75</em>) – The power parameter <span class="math">\(eta\)</span> in the LRN expression.</li>
<li><strong>knorm</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=2</em>) – The parameter <span class="math">\(k\)</span> in the LRN expression.</li>
<li><strong>nsize</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>required</em>) – normalization window width in elements.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.LayerNorm">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">LayerNorm</code><span class="sig-paren">(</span><em>data=None</em>, <em>gamma=None</em>, <em>beta=None</em>, <em>axis=_Null</em>, <em>eps=_Null</em>, <em>output_mean_var=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.LayerNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer normalization.</p>
<p>Normalizes the channels of the input tensor by mean and variance, and applies a scale <code class="docutils literal"><span class="pre">gamma</span></code> as
well as offset <code class="docutils literal"><span class="pre">beta</span></code>.</p>
<p>Assume the input has more than one dimension and we normalize along axis 1.
We first compute the mean and variance along this axis and then
compute the normalized output, which has the same shape as input, as following:</p>
<div class="math">
\[out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis) + \epsilon}} * gamma + beta\]</div>
<p>Both <code class="docutils literal"><span class="pre">gamma</span></code> and <code class="docutils literal"><span class="pre">beta</span></code> are learnable parameters.</p>
<p>Unlike BatchNorm and InstanceNorm,  the <em>mean</em> and <em>var</em> are computed along the channel dimension.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both <code class="docutils literal"><span class="pre">gamma</span></code> and <code class="docutils literal"><span class="pre">beta</span></code>
have shape <em>(k,)</em>. If <code class="docutils literal"><span class="pre">output_mean_var</span></code> is set to be true, then outputs both <code class="docutils literal"><span class="pre">data_mean</span></code> and
<code class="docutils literal"><span class="pre">data_std</span></code>. Note that no gradient will be passed through these two outputs.</p>
<p>The parameter <code class="docutils literal"><span class="pre">axis</span></code> specifies which axis of the input shape denotes
the ‘channel’ (separately normalized groups).  The default is -1, which sets the channel
axis to be the last item in the input shape.</p>
<p>Defined in src/operator/nn/layer_norm.cc:L155</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to layer normalization</li>
<li><strong>gamma</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – gamma array</li>
<li><strong>beta</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – beta array</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='-1'</em>) – The axis to perform layer normalization. Usually, this should be be axis of the channel dimension. Negative values means indexing from right to left.</li>
<li><strong>eps</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=9.99999975e-06</em>) – An <cite>epsilon</cite> parameter to prevent division by 0.</li>
<li><strong>output_mean_var</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Output the mean and std calculated along the given axis.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.LeakyReLU">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">LeakyReLU</code><span class="sig-paren">(</span><em>data=None</em>, <em>gamma=None</em>, <em>act_type=_Null</em>, <em>slope=_Null</em>, <em>lower_bound=_Null</em>, <em>upper_bound=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.LeakyReLU" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies Leaky rectified linear unit activation element-wise to the input.</p>
<p>Leaky ReLUs attempt to fix the “dying ReLU” problem by allowing a small <cite>slope</cite>
when the input is negative and has a slope of one when input is positive.</p>
<p>The following modified ReLU Activation functions are supported:</p>
<ul class="simple">
<li><em>elu</em>: Exponential Linear Unit. <cite>y = x > 0 ? x : slope * (exp(x)-1)</cite></li>
<li><em>selu</em>: Scaled Exponential Linear Unit. <cite>y = lambda * (x > 0 ? x : alpha * (exp(x) - 1))</cite> where
<em>lambda = 1.0507009873554804934193349852946</em> and <em>alpha = 1.6732632423543772848170429916717</em>.</li>
<li><em>leaky</em>: Leaky ReLU. <cite>y = x > 0 ? x : slope * x</cite></li>
<li><em>prelu</em>: Parametric ReLU. This is same as <em>leaky</em> except that <cite>slope</cite> is learnt during training.</li>
<li><em>rrelu</em>: Randomized ReLU. same as <em>leaky</em> but the <cite>slope</cite> is uniformly and randomly chosen from
<em>[lower_bound, upper_bound)</em> for training, while fixed to be
<em>(lower_bound+upper_bound)/2</em> for inference.</li>
</ul>
<p>Defined in src/operator/leaky_relu.cc:L65</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to activation function.</li>
<li><strong>gamma</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Slope parameter for PReLU. Only required when act_type is ‘prelu’. It should be either a vector of size 1, or the same size as the second dimension of data.</li>
<li><strong>act_type</strong> (<em>{'elu'</em><em>, </em><em>'gelu'</em><em>, </em><em>'leaky'</em><em>, </em><em>'prelu'</em><em>, </em><em>'rrelu'</em><em>, </em><em>'selu'}</em><em>,</em><em>optional</em><em>, </em><em>default='leaky'</em>) – Activation function to be applied.</li>
<li><strong>slope</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.25</em>) – Init slope for the activation. (For leaky and elu only)</li>
<li><strong>lower_bound</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.125</em>) – Lower bound of random slope. (For rrelu only)</li>
<li><strong>upper_bound</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.333999991</em>) – Upper bound of random slope. (For rrelu only)</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.LinearRegressionOutput">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">LinearRegressionOutput</code><span class="sig-paren">(</span><em>data=None</em>, <em>label=None</em>, <em>grad_scale=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.LinearRegressionOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes and optimizes for squared loss during backward propagation.
Just outputs <code class="docutils literal"><span class="pre">data</span></code> during forward propagation.</p>
<p>If <span class="math">\(\hat{y}_i\)</span> is the predicted value of the i-th sample, and <span class="math">\(y_i\)</span> is the corresponding target value,
then the squared loss estimated over <span class="math">\(n\)</span> samples is defined as</p>
<p><span class="math">\(\text{SquaredLoss}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert  \textbf{y}_i - \hat{\textbf{y}}_i  \rVert_2\)</span></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Use the LinearRegressionOutput as the final output layer of a net.</p>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">label</span></code> can be <code class="docutils literal"><span class="pre">default</span></code> or <code class="docutils literal"><span class="pre">csr</span></code></p>
<ul class="simple">
<li>LinearRegressionOutput(default, default) = default</li>
<li>LinearRegressionOutput(default, csr) = default</li>
</ul>
<p>By default, gradients of this loss function are scaled by factor <cite>1/m</cite>, where m is the number of regression outputs of a training example.
The parameter <cite>grad_scale</cite> can be used to change this scale to <cite>grad_scale/m</cite>.</p>
<p>Defined in src/operator/regression_output.cc:L92</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to the function.</li>
<li><strong>label</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input label to the function.</li>
<li><strong>grad_scale</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Scale the gradient by a float factor</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.LogisticRegressionOutput">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">LogisticRegressionOutput</code><span class="sig-paren">(</span><em>data=None</em>, <em>label=None</em>, <em>grad_scale=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.LogisticRegressionOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a logistic function to the input.</p>
<p>The logistic function, also known as the sigmoid function, is computed as
<span class="math">\(\frac{1}{1+exp(-\textbf{x})}\)</span>.</p>
<p>Commonly, the sigmoid is used to squash the real-valued output of a linear model
<span class="math">\(wTx+b\)</span> into the [0,1] range so that it can be interpreted as a probability.
It is suitable for binary classification or probability prediction tasks.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Use the LogisticRegressionOutput as the final output layer of a net.</p>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">label</span></code> can be <code class="docutils literal"><span class="pre">default</span></code> or <code class="docutils literal"><span class="pre">csr</span></code></p>
<ul class="simple">
<li>LogisticRegressionOutput(default, default) = default</li>
<li>LogisticRegressionOutput(default, csr) = default</li>
</ul>
<p>The loss function used is the Binary Cross Entropy Loss:</p>
<p><span class="math">\(-{(y\log(p) + (1 - y)\log(1 - p))}\)</span></p>
<p>Where <cite>y</cite> is the ground truth probability of positive outcome for a given example, and <cite>p</cite> the probability predicted by the model. By default, gradients of this loss function are scaled by factor <cite>1/m</cite>, where m is the number of regression outputs of a training example.
The parameter <cite>grad_scale</cite> can be used to change this scale to <cite>grad_scale/m</cite>.</p>
<p>Defined in src/operator/regression_output.cc:L152</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to the function.</li>
<li><strong>label</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input label to the function.</li>
<li><strong>grad_scale</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Scale the gradient by a float factor</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.MAERegressionOutput">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">MAERegressionOutput</code><span class="sig-paren">(</span><em>data=None</em>, <em>label=None</em>, <em>grad_scale=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.MAERegressionOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes mean absolute error of the input.</p>
<p>MAE is a risk metric corresponding to the expected value of the absolute error.</p>
<p>If <span class="math">\(\hat{y}_i\)</span> is the predicted value of the i-th sample, and <span class="math">\(y_i\)</span> is the corresponding target value,
then the mean absolute error (MAE) estimated over <span class="math">\(n\)</span> samples is defined as</p>
<p><span class="math">\(\text{MAE}(\textbf{Y}, \hat{\textbf{Y}} ) = \frac{1}{n} \sum_{i=0}^{n-1} \lVert \textbf{y}_i - \hat{\textbf{y}}_i \rVert_1\)</span></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Use the MAERegressionOutput as the final output layer of a net.</p>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">label</span></code> can be <code class="docutils literal"><span class="pre">default</span></code> or <code class="docutils literal"><span class="pre">csr</span></code></p>
<ul class="simple">
<li>MAERegressionOutput(default, default) = default</li>
<li>MAERegressionOutput(default, csr) = default</li>
</ul>
<p>By default, gradients of this loss function are scaled by factor <cite>1/m</cite>, where m is the number of regression outputs of a training example.
The parameter <cite>grad_scale</cite> can be used to change this scale to <cite>grad_scale/m</cite>.</p>
<p>Defined in src/operator/regression_output.cc:L120</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to the function.</li>
<li><strong>label</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input label to the function.</li>
<li><strong>grad_scale</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Scale the gradient by a float factor</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.MakeLoss">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">MakeLoss</code><span class="sig-paren">(</span><em>data=None</em>, <em>grad_scale=_Null</em>, <em>valid_thresh=_Null</em>, <em>normalization=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.MakeLoss" title="Permalink to this definition">¶</a></dt>
<dd><p>Make your own loss function in network construction.</p>
<p>This operator accepts a customized loss function symbol as a terminal loss and
the symbol should be an operator with no backward dependency.
The output of this function is the gradient of loss with respect to the input data.</p>
<p>For example, if you are a making a cross entropy loss function. Assume <code class="docutils literal"><span class="pre">out</span></code> is the
predicted output and <code class="docutils literal"><span class="pre">label</span></code> is the true label, then the cross entropy can be defined as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cross_entropy</span> <span class="o">=</span> <span class="n">label</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">label</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">out</span><span class="p">)</span>
<span class="n">loss</span> <span class="o">=</span> <span class="n">MakeLoss</span><span class="p">(</span><span class="n">cross_entropy</span><span class="p">)</span>
</pre></div>
</div>
<p>We will need to use <code class="docutils literal"><span class="pre">MakeLoss</span></code> when we are creating our own loss function or we want to
combine multiple loss functions. Also we may want to stop some variables’ gradients
from backpropagation. See more detail in <code class="docutils literal"><span class="pre">BlockGrad</span></code> or <code class="docutils literal"><span class="pre">stop_gradient</span></code>.</p>
<p>In addition, we can give a scale to the loss by setting <code class="docutils literal"><span class="pre">grad_scale</span></code>,
so that the gradient of the loss will be rescaled in the backpropagation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This operator should be used as a Symbol instead of NDArray.</p>
</div>
<p>Defined in src/operator/make_loss.cc:L71</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input array.</li>
<li><strong>grad_scale</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Gradient scale as a supplement to unary and binary operators</li>
<li><strong>valid_thresh</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – clip each element in the array to 0 when it is less than <code class="docutils literal"><span class="pre">valid_thresh</span></code>. This is used when <code class="docutils literal"><span class="pre">normalization</span></code> is set to <code class="docutils literal"><span class="pre">'valid'</span></code>.</li>
<li><strong>normalization</strong> (<em>{'batch'</em><em>, </em><em>'null'</em><em>, </em><em>'valid'}</em><em>,</em><em>optional</em><em>, </em><em>default='null'</em>) – If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the number of valid input elements.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Pad">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Pad</code><span class="sig-paren">(</span><em>data=None</em>, <em>mode=_Null</em>, <em>pad_width=_Null</em>, <em>constant_value=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Pads an input array with a constant or edge values of the array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>Pad</cite> is deprecated. Use <cite>pad</cite> instead.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Current implementation only supports 4D and 5D input arrays with padding applied
only on axes 1, 2 and 3. Expects axes 4 and 5 in <cite>pad_width</cite> to be zero.</p>
</div>
<p>This operation pads an input array with either a <cite>constant_value</cite> or edge values
along each axis of the input array. The amount of padding is specified by <cite>pad_width</cite>.</p>
<p><cite>pad_width</cite> is a tuple of integer padding widths for each axis of the format
<code class="docutils literal"><span class="pre">(before_1,</span> <span class="pre">after_1,</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">before_N,</span> <span class="pre">after_N)</span></code>. The <cite>pad_width</cite> should be of length <code class="docutils literal"><span class="pre">2*N</span></code>
where <code class="docutils literal"><span class="pre">N</span></code> is the number of dimensions of the array.</p>
<p>For dimension <code class="docutils literal"><span class="pre">N</span></code> of the input array, <code class="docutils literal"><span class="pre">before_N</span></code> and <code class="docutils literal"><span class="pre">after_N</span></code> indicates how many values
to add before and after the elements of the array along dimension <code class="docutils literal"><span class="pre">N</span></code>.
The widths of the higher two dimensions <code class="docutils literal"><span class="pre">before_1</span></code>, <code class="docutils literal"><span class="pre">after_1</span></code>, <code class="docutils literal"><span class="pre">before_2</span></code>,
<code class="docutils literal"><span class="pre">after_2</span></code> must be 0.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[[[</span>  <span class="mf">1.</span>   <span class="mf">2.</span>   <span class="mf">3.</span><span class="p">]</span>
       <span class="p">[</span>  <span class="mf">4.</span>   <span class="mf">5.</span>   <span class="mf">6.</span><span class="p">]]</span>

      <span class="p">[[</span>  <span class="mf">7.</span>   <span class="mf">8.</span>   <span class="mf">9.</span><span class="p">]</span>
       <span class="p">[</span> <span class="mf">10.</span>  <span class="mf">11.</span>  <span class="mf">12.</span><span class="p">]]]</span>


     <span class="p">[[[</span> <span class="mf">11.</span>  <span class="mf">12.</span>  <span class="mf">13.</span><span class="p">]</span>
       <span class="p">[</span> <span class="mf">14.</span>  <span class="mf">15.</span>  <span class="mf">16.</span><span class="p">]]</span>

      <span class="p">[[</span> <span class="mf">17.</span>  <span class="mf">18.</span>  <span class="mf">19.</span><span class="p">]</span>
       <span class="p">[</span> <span class="mf">20.</span>  <span class="mf">21.</span>  <span class="mf">22.</span><span class="p">]]]]</span>

<span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">"edge"</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span>

      <span class="p">[[[[</span>  <span class="mf">1.</span>   <span class="mf">1.</span>   <span class="mf">2.</span>   <span class="mf">3.</span>   <span class="mf">3.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">1.</span>   <span class="mf">1.</span>   <span class="mf">2.</span>   <span class="mf">3.</span>   <span class="mf">3.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">4.</span>   <span class="mf">4.</span>   <span class="mf">5.</span>   <span class="mf">6.</span>   <span class="mf">6.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">4.</span>   <span class="mf">4.</span>   <span class="mf">5.</span>   <span class="mf">6.</span>   <span class="mf">6.</span><span class="p">]]</span>

        <span class="p">[[</span>  <span class="mf">7.</span>   <span class="mf">7.</span>   <span class="mf">8.</span>   <span class="mf">9.</span>   <span class="mf">9.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">7.</span>   <span class="mf">7.</span>   <span class="mf">8.</span>   <span class="mf">9.</span>   <span class="mf">9.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">10.</span>  <span class="mf">10.</span>  <span class="mf">11.</span>  <span class="mf">12.</span>  <span class="mf">12.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">10.</span>  <span class="mf">10.</span>  <span class="mf">11.</span>  <span class="mf">12.</span>  <span class="mf">12.</span><span class="p">]]]</span>


       <span class="p">[[[</span> <span class="mf">11.</span>  <span class="mf">11.</span>  <span class="mf">12.</span>  <span class="mf">13.</span>  <span class="mf">13.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">11.</span>  <span class="mf">11.</span>  <span class="mf">12.</span>  <span class="mf">13.</span>  <span class="mf">13.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">14.</span>  <span class="mf">14.</span>  <span class="mf">15.</span>  <span class="mf">16.</span>  <span class="mf">16.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">14.</span>  <span class="mf">14.</span>  <span class="mf">15.</span>  <span class="mf">16.</span>  <span class="mf">16.</span><span class="p">]]</span>

        <span class="p">[[</span> <span class="mf">17.</span>  <span class="mf">17.</span>  <span class="mf">18.</span>  <span class="mf">19.</span>  <span class="mf">19.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">17.</span>  <span class="mf">17.</span>  <span class="mf">18.</span>  <span class="mf">19.</span>  <span class="mf">19.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">20.</span>  <span class="mf">20.</span>  <span class="mf">21.</span>  <span class="mf">22.</span>  <span class="mf">22.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">20.</span>  <span class="mf">20.</span>  <span class="mf">21.</span>  <span class="mf">22.</span>  <span class="mf">22.</span><span class="p">]]]]</span>

<span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"constant"</span><span class="p">,</span> <span class="n">constant_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span>

      <span class="p">[[[[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>   <span class="mf">1.</span>   <span class="mf">2.</span>   <span class="mf">3.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>   <span class="mf">4.</span>   <span class="mf">5.</span>   <span class="mf">6.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]]</span>

        <span class="p">[[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>   <span class="mf">7.</span>   <span class="mf">8.</span>   <span class="mf">9.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>  <span class="mf">10.</span>  <span class="mf">11.</span>  <span class="mf">12.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]]]</span>


       <span class="p">[[[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>  <span class="mf">11.</span>  <span class="mf">12.</span>  <span class="mf">13.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>  <span class="mf">14.</span>  <span class="mf">15.</span>  <span class="mf">16.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]]</span>

        <span class="p">[[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>  <span class="mf">17.</span>  <span class="mf">18.</span>  <span class="mf">19.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>  <span class="mf">20.</span>  <span class="mf">21.</span>  <span class="mf">22.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/pad.cc:L766</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – An n-dimensional input array.</li>
<li><strong>mode</strong> (<em>{'constant'</em><em>, </em><em>'edge'</em><em>, </em><em>'reflect'}</em><em>, </em><em>required</em>) – Padding type to use. “constant” pads with <cite>constant_value</cite> “edge” pads using the edge values of the input array “reflect” pads by reflecting values with respect to the edges.</li>
<li><strong>pad_width</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>required</em>) – Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format <code class="docutils literal"><span class="pre">(before_1,</span> <span class="pre">after_1,</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">before_N,</span> <span class="pre">after_N)</span></code>. It should be of length <code class="docutils literal"><span class="pre">2*N</span></code> where <code class="docutils literal"><span class="pre">N</span></code> is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.</li>
<li><strong>constant_value</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – The value used for padding when <cite>mode</cite> is “constant”.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Pooling">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Pooling</code><span class="sig-paren">(</span><em>data=None</em>, <em>kernel=_Null</em>, <em>pool_type=_Null</em>, <em>global_pool=_Null</em>, <em>cudnn_off=_Null</em>, <em>pooling_convention=_Null</em>, <em>stride=_Null</em>, <em>pad=_Null</em>, <em>p_value=_Null</em>, <em>count_include_pad=_Null</em>, <em>layout=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Pooling" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs pooling on the input.</p>
<p>The shapes for 1-D pooling are</p>
<ul class="simple">
<li><strong>data</strong> and <strong>out</strong>: <em>(batch_size, channel, width)</em> (NCW layout) or
<em>(batch_size, width, channel)</em> (NWC layout),</li>
</ul>
<p>The shapes for 2-D pooling are</p>
<ul>
<li><p class="first"><strong>data</strong> and <strong>out</strong>: <em>(batch_size, channel, height, width)</em> (NCHW layout) or
<em>(batch_size, height, width, channel)</em> (NHWC layout),</p>
<blockquote>
<div><p>out_height = f(height, kernel[0], pad[0], stride[0])
out_width = f(width, kernel[1], pad[1], stride[1])</p>
</div></blockquote>
</li>
</ul>
<p>The definition of <em>f</em> depends on <code class="docutils literal"><span class="pre">pooling_convention</span></code>, which has two options:</p>
<ul>
<li><p class="first"><strong>valid</strong> (default):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">floor</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>full</strong>, which is compatible with Caffe:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
</li>
</ul>
<p>But <code class="docutils literal"><span class="pre">global_pool</span></code> is set to be true, then do a global pooling, namely reset
<code class="docutils literal"><span class="pre">kernel=(height,</span> <span class="pre">width)</span></code>.</p>
<p>Three pooling options are supported by <code class="docutils literal"><span class="pre">pool_type</span></code>:</p>
<ul class="simple">
<li><strong>avg</strong>: average pooling</li>
<li><strong>max</strong>: max pooling</li>
<li><strong>sum</strong>: sum pooling</li>
<li><strong>lp</strong>: Lp pooling</li>
</ul>
<p>For 3-D pooling, an additional <em>depth</em> dimension is added before
<em>height</em>. Namely the input data and output will have shape <em>(batch_size, channel, depth,
height, width)</em> (NCDHW layout) or <em>(batch_size, depth, height, width, channel)</em> (NDHWC layout).</p>
<p>Notes on Lp pooling:</p>
<p>Lp pooling was first introduced by this paper: <a class="reference external" href="https://arxiv.org/pdf/1204.3968.pdf">https://arxiv.org/pdf/1204.3968.pdf</a>.
L-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.
We can see that Lp pooling stands between those two, in practice the most common value for p is 2.</p>
<p>For each window <code class="docutils literal"><span class="pre">X</span></code>, the mathematical expression for Lp pooling is:</p>
<p><span class="math">\(f(X) = \sqrt[p]{\sum_{x}^{X} x^p}\)</span></p>
<p>Defined in src/operator/nn/pooling.cc:L416</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to the pooling operator.</li>
<li><strong>kernel</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – Pooling kernel size: (y, x) or (d, y, x)</li>
<li><strong>pool_type</strong> (<em>{'avg'</em><em>, </em><em>'lp'</em><em>, </em><em>'max'</em><em>, </em><em>'sum'}</em><em>,</em><em>optional</em><em>, </em><em>default='max'</em>) – Pooling type to be applied.</li>
<li><strong>global_pool</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Ignore kernel size, do global pooling based on current input feature map.</li>
<li><strong>cudnn_off</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Turn off cudnn pooling and use MXNet pooling operator.</li>
<li><strong>pooling_convention</strong> (<em>{'full'</em><em>, </em><em>'same'</em><em>, </em><em>'valid'}</em><em>,</em><em>optional</em><em>, </em><em>default='valid'</em>) – Pooling convention to be applied.</li>
<li><strong>stride</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension.</li>
<li><strong>pad</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – Pad for pooling: (y, x) or (d, y, x). Defaults to no padding.</li>
<li><strong>p_value</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default='None'</em>) – Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling.</li>
<li><strong>count_include_pad</strong> (<em>boolean</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true.</li>
<li><strong>layout</strong> (<em>{None</em><em>, </em><em>'NCDHW'</em><em>, </em><em>'NCHW'</em><em>, </em><em>'NCW'</em><em>, </em><em>'NDHWC'</em><em>, </em><em>'NHWC'</em><em>, </em><em>'NWC'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – Set layout for input and output. Empty for
default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Pooling_v1">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Pooling_v1</code><span class="sig-paren">(</span><em>data=None</em>, <em>kernel=_Null</em>, <em>pool_type=_Null</em>, <em>global_pool=_Null</em>, <em>pooling_convention=_Null</em>, <em>stride=_Null</em>, <em>pad=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Pooling_v1" title="Permalink to this definition">¶</a></dt>
<dd><p>This operator is DEPRECATED.
Perform pooling on the input.</p>
<p>The shapes for 2-D pooling is</p>
<ul>
<li><p class="first"><strong>data</strong>: <em>(batch_size, channel, height, width)</em></p>
</li>
<li><p class="first"><strong>out</strong>: <em>(batch_size, num_filter, out_height, out_width)</em>, with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">out_height</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stride</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">out_width</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pad</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stride</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</li>
</ul>
<p>The definition of <em>f</em> depends on <code class="docutils literal"><span class="pre">pooling_convention</span></code>, which has two options:</p>
<ul>
<li><p class="first"><strong>valid</strong> (default):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">floor</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>full</strong>, which is compatible with Caffe:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
</li>
</ul>
<p>But <code class="docutils literal"><span class="pre">global_pool</span></code> is set to be true, then do a global pooling, namely reset
<code class="docutils literal"><span class="pre">kernel=(height,</span> <span class="pre">width)</span></code>.</p>
<p>Three pooling options are supported by <code class="docutils literal"><span class="pre">pool_type</span></code>:</p>
<ul class="simple">
<li><strong>avg</strong>: average pooling</li>
<li><strong>max</strong>: max pooling</li>
<li><strong>sum</strong>: sum pooling</li>
</ul>
<p>1-D pooling is special case of 2-D pooling with <em>weight=1</em> and
<em>kernel[1]=1</em>.</p>
<p>For 3-D pooling, an additional <em>depth</em> dimension is added before
<em>height</em>. Namely the input data will have shape <em>(batch_size, channel, depth,
height, width)</em>.</p>
<p>Defined in src/operator/pooling_v1.cc:L104</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to the pooling operator.</li>
<li><strong>kernel</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – pooling kernel size: (y, x) or (d, y, x)</li>
<li><strong>pool_type</strong> (<em>{'avg'</em><em>, </em><em>'max'</em><em>, </em><em>'sum'}</em><em>,</em><em>optional</em><em>, </em><em>default='max'</em>) – Pooling type to be applied.</li>
<li><strong>global_pool</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Ignore kernel size, do global pooling based on current input feature map.</li>
<li><strong>pooling_convention</strong> (<em>{'full'</em><em>, </em><em>'valid'}</em><em>,</em><em>optional</em><em>, </em><em>default='valid'</em>) – Pooling convention to be applied.</li>
<li><strong>stride</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – stride: for pooling (y, x) or (d, y, x)</li>
<li><strong>pad</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – pad for pooling: (y, x) or (d, y, x)</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.RNN">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">RNN</code><span class="sig-paren">(</span><em>data=None</em>, <em>parameters=None</em>, <em>state=None</em>, <em>state_cell=None</em>, <em>sequence_length=None</em>, <em>state_size=_Null</em>, <em>num_layers=_Null</em>, <em>bidirectional=_Null</em>, <em>mode=_Null</em>, <em>p=_Null</em>, <em>state_outputs=_Null</em>, <em>projection_size=_Null</em>, <em>lstm_state_clip_min=_Null</em>, <em>lstm_state_clip_max=_Null</em>, <em>lstm_state_clip_nan=_Null</em>, <em>use_sequence_length=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.RNN" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are
implemented, with both multi-layer and bidirectional support.</p>
<p>When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.</p>
<p><strong>Vanilla RNN</strong></p>
<p>Applies a single-gate recurrent layer to input X. Two kinds of activation function are supported:
ReLU and Tanh.</p>
<p>With ReLU activation function:</p>
<div class="math">
\[h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})\]</div>
<p>With Tanh activtion function:</p>
<div class="math">
\[h_t = \tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})\]</div>
<p>Reference paper: Finding structure in time - Elman, 1988.
<a class="reference external" href="https://crl.ucsd.edu/~elman/Papers/fsit.pdf">https://crl.ucsd.edu/~elman/Papers/fsit.pdf</a></p>
<p><strong>LSTM</strong></p>
<p>Long Short-Term Memory - Hochreiter, 1997. <a class="reference external" href="http://www.bioinf.jku.at/publications/older/2604.pdf">http://www.bioinf.jku.at/publications/older/2604.pdf</a></p>
<div class="math">
\[\begin{split}\begin{array}{ll}
          i_t = \mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\
          f_t = \mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\
          g_t = \tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\
          o_t = \mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\
          c_t = f_t * c_{(t-1)} + i_t * g_t \\
          h_t = o_t * \tanh(c_t)
          \end{array}\end{split}\]</div>
<p><strong>GRU</strong></p>
<p>Gated Recurrent Unit - Cho et al. 2014. <a class="reference external" href="http://arxiv.org/abs/1406.1078">http://arxiv.org/abs/1406.1078</a></p>
<p>The definition of GRU here is slightly different from paper but compatible with CUDNN.</p>
<div class="math">
\[\begin{split}\begin{array}{ll}
          r_t = \mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\
          z_t = \mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\
          n_t = \tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\
          h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\
          \end{array}\end{split}\]</div>
<p>Defined in src/operator/rnn.cc:L690</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to RNN</li>
<li><strong>parameters</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Vector of all RNN trainable parameters concatenated</li>
<li><strong>state</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – initial hidden state of the RNN</li>
<li><strong>state_cell</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – initial cell state for LSTM networks (only for LSTM)</li>
<li><strong>sequence_length</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Vector of valid sequence lengths for each element in batch. (Only used if use_sequence_length kwarg is True)</li>
<li><strong>state_size</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>required</em>) – size of the state for each layer</li>
<li><strong>num_layers</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>required</em>) – number of stacked layers</li>
<li><strong>bidirectional</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – whether to use bidirectional recurrent layers</li>
<li><strong>mode</strong> (<em>{'gru'</em><em>, </em><em>'lstm'</em><em>, </em><em>'rnn_relu'</em><em>, </em><em>'rnn_tanh'}</em><em>, </em><em>required</em>) – the type of RNN to compute</li>
<li><strong>p</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – drop rate of the dropout on the outputs of each RNN layer, except the last layer.</li>
<li><strong>state_outputs</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to have the states as symbol outputs.</li>
<li><strong>projection_size</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default='None'</em>) – size of project size</li>
<li><strong>lstm_state_clip_min</strong> (<em>double</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Minimum clip value of LSTM states. This option must be used together with lstm_state_clip_max.</li>
<li><strong>lstm_state_clip_max</strong> (<em>double</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Maximum clip value of LSTM states. This option must be used together with lstm_state_clip_min.</li>
<li><strong>lstm_state_clip_nan</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to stop NaN from propagating in state by clipping it to min/max. If clipping range is not specified, this option is ignored.</li>
<li><strong>use_sequence_length</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If set to true, this layer takes in an extra input parameter <cite>sequence_length</cite> to specify variable length sequence</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.ROIPooling">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">ROIPooling</code><span class="sig-paren">(</span><em>data=None</em>, <em>rois=None</em>, <em>pooled_size=_Null</em>, <em>spatial_scale=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.ROIPooling" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs region of interest(ROI) pooling on the input array.</p>
<p>ROI pooling is a variant of a max pooling layer, in which the output size is fixed and
region of interest is a parameter. Its purpose is to perform max pooling on the inputs
of non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net
layer mostly used in training a <cite>Fast R-CNN</cite> network for object detection.</p>
<p>This operator takes a 4D feature map as an input array and region proposals as <cite>rois</cite>,
then it pools over sub-regions of input and produces a fixed-sized output array
regardless of the ROI size.</p>
<p>To crop the feature map accordingly, you can resize the bounding box coordinates
by changing the parameters <cite>rois</cite> and <cite>spatial_scale</cite>.</p>
<p>The cropped feature maps are pooled by standard max pooling operation to a fixed size output
indicated by a <cite>pooled_size</cite> parameter. batch_size will change to the number of region
bounding boxes after <cite>ROIPooling</cite>.</p>
<p>The size of each region of interest doesn’t have to be perfectly divisible by
the number of pooling sections(<cite>pooled_size</cite>).</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],
       [  6.,   7.,   8.,   9.,  10.,  11.],
       [ 12.,  13.,  14.,  15.,  16.,  17.],
       [ 18.,  19.,  20.,  21.,  22.,  23.],
       [ 24.,  25.,  26.,  27.,  28.,  29.],
       [ 30.,  31.,  32.,  33.,  34.,  35.],
       [ 36.,  37.,  38.,  39.,  40.,  41.],
       [ 42.,  43.,  44.,  45.,  46.,  47.]]]]

// region of interest i.e. bounding box coordinates.
y = [[0,0,0,4,4]]

// returns array of shape (2,2) according to the given roi with max pooling.
ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],
                                  [ 26.,  28.]]]]

// region of interest is changed due to the change in `spacial_scale` parameter.
ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],
                                  [ 19.,  21.]]]]
</pre></div>
</div>
<p>Defined in src/operator/roi_pooling.cc:L295</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array to the pooling operator,  a 4D Feature maps</li>
<li><strong>rois</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. <cite>batch_index</cite> indicates the index of corresponding image in the input array</li>
<li><strong>pooled_size</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>required</em>) – ROI pooling output shape (h,w)</li>
<li><strong>spatial_scale</strong> (<em>float</em><em>, </em><em>required</em>) – Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Reshape">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Reshape</code><span class="sig-paren">(</span><em>data=None</em>, <em>shape=_Null</em>, <em>reverse=_Null</em>, <em>target_shape=_Null</em>, <em>keep_highest=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshapes the input array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">Reshape</span></code> is deprecated, use <code class="docutils literal"><span class="pre">reshape</span></code></p>
</div>
<p>Given an array and a shape, this function returns a copy of the array in the new shape.
The shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
</pre></div>
</div>
<p>Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">0</span></code>  copy this dimension from the input to the output shape.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-1</span></code> infers the dimension of the output shape by using the remainder of the input dimensions
keeping the size of the new array same as that of the input array.
At most one dimension of shape can be -1.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">24</span><span class="p">,)</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-2</span></code> copy all/remainder of the input dimensions to the output shape.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-3</span></code> use the product of two consecutive dimensions of the input shape as the output dimension.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">12</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-4</span></code> split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>If the argument <cite>reverse</cite> is set to 1, then the special values are inferred from right to left.</p>
<blockquote>
<div><p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">without</span> <span class="n">reverse</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="k">for</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="n">would</span> <span class="n">be</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="o">-</span> <span class="k">with</span> <span class="n">reverse</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output</span> <span class="n">shape</span> <span class="n">will</span> <span class="n">be</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
</div></blockquote>
<p>Defined in src/operator/tensor/matrix_op.cc:L202</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to reshape.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – The target shape</li>
<li><strong>reverse</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If true then the special values are inferred from right to left</li>
<li><strong>target_shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – (Deprecated! Use <code class="docutils literal"><span class="pre">shape</span></code> instead.) Target new shape. One and only one dim can be 0, in which case it will be inferred from the rest of dims</li>
<li><strong>keep_highest</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – (Deprecated! Use <code class="docutils literal"><span class="pre">shape</span></code> instead.) Whether keep the highest dim unchanged.If set to true, then the first dim in target_shape is ignored,and always fixed as input</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Reshapes the input array into a new shape.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4L,)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2L, 2L)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  2.],</span>
<span class="go">   [ 3.,  4.]], dtype=float32)</span>
</pre></div>
</div>
<p>You can use <code class="docutils literal"><span class="pre">0</span></code> to copy a particular dimension from the input to the output shape
and ‘-1’ to infer the dimensions of the output.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2L, 3L, 4L)</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4L, 3L, 2L)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.SVMOutput">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">SVMOutput</code><span class="sig-paren">(</span><em>data=None</em>, <em>label=None</em>, <em>margin=_Null</em>, <em>regularization_coefficient=_Null</em>, <em>use_linear=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.SVMOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes support vector machine based transformation of the input.</p>
<p>This tutorial demonstrates using SVM as output layer for classification instead of softmax:
<a class="reference external" href="https://github.com/dmlc/mxnet/tree/master/example/svm_mnist">https://github.com/dmlc/mxnet/tree/master/example/svm_mnist</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data for SVM transformation.</li>
<li><strong>label</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Class label for the input data.</li>
<li><strong>margin</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – The loss function penalizes outputs that lie outside this margin. Default margin is 1.</li>
<li><strong>regularization_coefficient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Regularization parameter for the SVM. This balances the tradeoff between coefficient size and error.</li>
<li><strong>use_linear</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to use L1-SVM objective. L2-SVM objective is used by default.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.SequenceLast">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">SequenceLast</code><span class="sig-paren">(</span><em>data=None</em>, <em>sequence_length=None</em>, <em>use_sequence_length=_Null</em>, <em>axis=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.SequenceLast" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the last element of a sequence.</p>
<p>This function takes an n-dimensional input array of the form
[max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array
of the form [batch_size, other_feature_dims].</p>
<p>Parameter <cite>sequence_length</cite> is used to handle variable-length sequences. <cite>sequence_length</cite> should be
an input array of positive ints of dimension [batch_size]. To use this parameter,
set <cite>use_sequence_length</cite> to <cite>True</cite>, otherwise each example in the batch is assumed
to have the max sequence length.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Alternatively, you can also use <cite>take</cite> operator.</p>
</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">],</span>
      <span class="p">[</span>  <span class="mf">4.</span><span class="p">,</span>   <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">],</span>
      <span class="p">[</span>  <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>   <span class="mf">9.</span><span class="p">]],</span>

     <span class="p">[[</span> <span class="mf">10.</span><span class="p">,</span>   <span class="mf">11.</span><span class="p">,</span>   <span class="mf">12.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">13.</span><span class="p">,</span>   <span class="mf">14.</span><span class="p">,</span>   <span class="mf">15.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">16.</span><span class="p">,</span>   <span class="mf">17.</span><span class="p">,</span>   <span class="mf">18.</span><span class="p">]],</span>

     <span class="p">[[</span>  <span class="mf">19.</span><span class="p">,</span>   <span class="mf">20.</span><span class="p">,</span>   <span class="mf">21.</span><span class="p">],</span>
      <span class="p">[</span>  <span class="mf">22.</span><span class="p">,</span>   <span class="mf">23.</span><span class="p">,</span>   <span class="mf">24.</span><span class="p">],</span>
      <span class="p">[</span>  <span class="mf">25.</span><span class="p">,</span>   <span class="mf">26.</span><span class="p">,</span>   <span class="mf">27.</span><span class="p">]]]</span>

<span class="o">//</span> <span class="n">returns</span> <span class="n">last</span> <span class="n">sequence</span> <span class="n">when</span> <span class="n">sequence_length</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span>
<span class="n">SequenceLast</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">19.</span><span class="p">,</span>   <span class="mf">20.</span><span class="p">,</span>   <span class="mf">21.</span><span class="p">],</span>
                   <span class="p">[</span>  <span class="mf">22.</span><span class="p">,</span>   <span class="mf">23.</span><span class="p">,</span>   <span class="mf">24.</span><span class="p">],</span>
                   <span class="p">[</span>  <span class="mf">25.</span><span class="p">,</span>   <span class="mf">26.</span><span class="p">,</span>   <span class="mf">27.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">sequence_length</span> <span class="ow">is</span> <span class="n">used</span>
<span class="n">SequenceLast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">use_sequence_length</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">=</span>
         <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">],</span>
          <span class="p">[</span>  <span class="mf">4.</span><span class="p">,</span>   <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">],</span>
          <span class="p">[</span>  <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>   <span class="mf">9.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">sequence_length</span> <span class="ow">is</span> <span class="n">used</span>
<span class="n">SequenceLast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">use_sequence_length</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">=</span>
         <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>    <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">],</span>
          <span class="p">[</span>  <span class="mf">13.</span><span class="p">,</span>  <span class="mf">14.</span><span class="p">,</span>  <span class="mf">15.</span><span class="p">],</span>
          <span class="p">[</span>  <span class="mf">25.</span><span class="p">,</span>  <span class="mf">26.</span><span class="p">,</span>  <span class="mf">27.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/sequence_last.cc:L100</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n>2</li>
<li><strong>sequence_length</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – vector of sequence lengths of the form [batch_size]</li>
<li><strong>use_sequence_length</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If set to true, this layer takes in an extra input parameter <cite>sequence_length</cite> to specify variable length sequence</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='0'</em>) – The sequence axis. Only values of 0 and 1 are currently supported.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.SequenceMask">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">SequenceMask</code><span class="sig-paren">(</span><em>data=None</em>, <em>sequence_length=None</em>, <em>use_sequence_length=_Null</em>, <em>value=_Null</em>, <em>axis=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.SequenceMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets all elements outside the sequence to a constant value.</p>
<p>This function takes an n-dimensional input array of the form
[max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.</p>
<p>Parameter <cite>sequence_length</cite> is used to handle variable-length sequences. <cite>sequence_length</cite>
should be an input array of positive ints of dimension [batch_size].
To use this parameter, set <cite>use_sequence_length</cite> to <cite>True</cite>,
otherwise each example in the batch is assumed to have the max sequence length and
this operator works as the <cite>identity</cite> operator.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">],</span>
      <span class="p">[</span>  <span class="mf">4.</span><span class="p">,</span>   <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">]],</span>

     <span class="p">[[</span>  <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>   <span class="mf">9.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]],</span>

     <span class="p">[[</span> <span class="mf">13.</span><span class="p">,</span>  <span class="mf">14.</span><span class="p">,</span>   <span class="mf">15.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">16.</span><span class="p">,</span>  <span class="mf">17.</span><span class="p">,</span>   <span class="mf">18.</span><span class="p">]]]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="mi">1</span>
<span class="n">B1</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">],</span>
      <span class="p">[</span>  <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>   <span class="mf">9.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">13.</span><span class="p">,</span>  <span class="mf">14.</span><span class="p">,</span>  <span class="mf">15.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="mi">2</span>
<span class="n">B2</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">4.</span><span class="p">,</span>   <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">16.</span><span class="p">,</span>  <span class="mf">17.</span><span class="p">,</span>  <span class="mf">18.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">works</span> <span class="k">as</span> <span class="n">identity</span> <span class="n">operator</span> <span class="n">when</span> <span class="n">sequence_length</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span>
<span class="n">SequenceMask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">],</span>
                    <span class="p">[</span>  <span class="mf">4.</span><span class="p">,</span>   <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">]],</span>

                   <span class="p">[[</span>  <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>   <span class="mf">9.</span><span class="p">],</span>
                    <span class="p">[</span> <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]],</span>

                   <span class="p">[[</span> <span class="mf">13.</span><span class="p">,</span>  <span class="mf">14.</span><span class="p">,</span>   <span class="mf">15.</span><span class="p">],</span>
                    <span class="p">[</span> <span class="mf">16.</span><span class="p">,</span>  <span class="mf">17.</span><span class="p">,</span>   <span class="mf">18.</span><span class="p">]]]</span>

<span class="o">//</span> <span class="n">sequence_length</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="n">means</span> <span class="mi">1</span> <span class="n">of</span> <span class="n">each</span> <span class="n">batch</span> <span class="n">will</span> <span class="n">be</span> <span class="n">kept</span>
<span class="o">//</span> <span class="ow">and</span> <span class="n">other</span> <span class="n">rows</span> <span class="n">are</span> <span class="n">masked</span> <span class="k">with</span> <span class="n">default</span> <span class="n">mask</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">SequenceMask</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">use_sequence_length</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">=</span>
             <span class="p">[[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">],</span>
               <span class="p">[</span>  <span class="mf">4.</span><span class="p">,</span>   <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">]],</span>

              <span class="p">[[</span>  <span class="mf">0.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">],</span>
               <span class="p">[</span>  <span class="mf">0.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">]],</span>

              <span class="p">[[</span>  <span class="mf">0.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">],</span>
               <span class="p">[</span>  <span class="mf">0.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">]]]</span>

<span class="o">//</span> <span class="n">sequence_length</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="n">means</span> <span class="mi">2</span> <span class="n">of</span> <span class="n">batch</span> <span class="n">B1</span> <span class="ow">and</span> <span class="mi">3</span> <span class="n">of</span> <span class="n">batch</span> <span class="n">B2</span> <span class="n">will</span> <span class="n">be</span> <span class="n">kept</span>
<span class="o">//</span> <span class="ow">and</span> <span class="n">other</span> <span class="n">rows</span> <span class="n">are</span> <span class="n">masked</span> <span class="k">with</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">SequenceMask</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">use_sequence_length</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span>
             <span class="p">[[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">],</span>
               <span class="p">[</span>  <span class="mf">4.</span><span class="p">,</span>   <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">]],</span>

              <span class="p">[[</span>  <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>   <span class="mf">9.</span><span class="p">],</span>
               <span class="p">[</span>  <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]],</span>

              <span class="p">[[</span>   <span class="mf">1.</span><span class="p">,</span>   <span class="mf">1.</span><span class="p">,</span>   <span class="mf">1.</span><span class="p">],</span>
               <span class="p">[</span>  <span class="mf">16.</span><span class="p">,</span>  <span class="mf">17.</span><span class="p">,</span>  <span class="mf">18.</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/sequence_mask.cc:L186</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n>2</li>
<li><strong>sequence_length</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – vector of sequence lengths of the form [batch_size]</li>
<li><strong>use_sequence_length</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If set to true, this layer takes in an extra input parameter <cite>sequence_length</cite> to specify variable length sequence</li>
<li><strong>value</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – The value to be used as a mask.</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='0'</em>) – The sequence axis. Only values of 0 and 1 are currently supported.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.SequenceReverse">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">SequenceReverse</code><span class="sig-paren">(</span><em>data=None</em>, <em>sequence_length=None</em>, <em>use_sequence_length=_Null</em>, <em>axis=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.SequenceReverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverses the elements of each sequence.</p>
<p>This function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims]
and returns an array of the same shape.</p>
<p>Parameter <cite>sequence_length</cite> is used to handle variable-length sequences.
<cite>sequence_length</cite> should be an input array of positive ints of dimension [batch_size].
To use this parameter, set <cite>use_sequence_length</cite> to <cite>True</cite>,
otherwise each example in the batch is assumed to have the max sequence length.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">],</span>
      <span class="p">[</span>  <span class="mf">4.</span><span class="p">,</span>   <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">]],</span>

     <span class="p">[[</span>  <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>   <span class="mf">9.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]],</span>

     <span class="p">[[</span> <span class="mf">13.</span><span class="p">,</span>  <span class="mf">14.</span><span class="p">,</span>   <span class="mf">15.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">16.</span><span class="p">,</span>  <span class="mf">17.</span><span class="p">,</span>   <span class="mf">18.</span><span class="p">]]]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="mi">1</span>
<span class="n">B1</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">],</span>
      <span class="p">[</span>  <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>   <span class="mf">9.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">13.</span><span class="p">,</span>  <span class="mf">14.</span><span class="p">,</span>  <span class="mf">15.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="mi">2</span>
<span class="n">B2</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">4.</span><span class="p">,</span>   <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">16.</span><span class="p">,</span>  <span class="mf">17.</span><span class="p">,</span>  <span class="mf">18.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">returns</span> <span class="n">reverse</span> <span class="n">sequence</span> <span class="n">when</span> <span class="n">sequence_length</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span>
<span class="n">SequenceReverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">13.</span><span class="p">,</span>  <span class="mf">14.</span><span class="p">,</span>   <span class="mf">15.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">16.</span><span class="p">,</span>  <span class="mf">17.</span><span class="p">,</span>   <span class="mf">18.</span><span class="p">]],</span>

                      <span class="p">[[</span>  <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>   <span class="mf">9.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]],</span>

                      <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">],</span>
                       <span class="p">[</span>  <span class="mf">4.</span><span class="p">,</span>   <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">]]]</span>

<span class="o">//</span> <span class="n">sequence_length</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="n">means</span> <span class="mi">2</span> <span class="n">rows</span> <span class="n">of</span>
<span class="o">//</span> <span class="n">both</span> <span class="n">batch</span> <span class="n">B1</span> <span class="ow">and</span> <span class="n">B2</span> <span class="n">will</span> <span class="n">be</span> <span class="nb">reversed</span><span class="o">.</span>
<span class="n">SequenceReverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">use_sequence_length</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">=</span>
                  <span class="p">[[[</span>  <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>   <span class="mf">9.</span><span class="p">],</span>
                    <span class="p">[</span> <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]],</span>

                   <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">],</span>
                    <span class="p">[</span>  <span class="mf">4.</span><span class="p">,</span>   <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">]],</span>

                   <span class="p">[[</span> <span class="mf">13.</span><span class="p">,</span>  <span class="mf">14.</span><span class="p">,</span>   <span class="mf">15.</span><span class="p">],</span>
                    <span class="p">[</span> <span class="mf">16.</span><span class="p">,</span>  <span class="mf">17.</span><span class="p">,</span>   <span class="mf">18.</span><span class="p">]]]</span>

<span class="o">//</span> <span class="n">sequence_length</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="n">means</span> <span class="mi">2</span> <span class="n">of</span> <span class="n">batch</span> <span class="n">B2</span> <span class="ow">and</span> <span class="mi">3</span> <span class="n">of</span> <span class="n">batch</span> <span class="n">B3</span>
<span class="o">//</span> <span class="n">will</span> <span class="n">be</span> <span class="nb">reversed</span><span class="o">.</span>
<span class="n">SequenceReverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">use_sequence_length</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">=</span>
                 <span class="p">[[[</span>  <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">,</span>   <span class="mf">9.</span><span class="p">],</span>
                   <span class="p">[</span> <span class="mf">16.</span><span class="p">,</span>  <span class="mf">17.</span><span class="p">,</span>  <span class="mf">18.</span><span class="p">]],</span>

                  <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">],</span>
                   <span class="p">[</span> <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]],</span>

                  <span class="p">[[</span> <span class="mf">13.</span><span class="p">,</span>  <span class="mi">14</span><span class="p">,</span>   <span class="mf">15.</span><span class="p">],</span>
                   <span class="p">[</span>  <span class="mf">4.</span><span class="p">,</span>   <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/sequence_reverse.cc:L122</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – n-dimensional input array of the form [max_sequence_length, batch_size, other dims] where n>2</li>
<li><strong>sequence_length</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – vector of sequence lengths of the form [batch_size]</li>
<li><strong>use_sequence_length</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If set to true, this layer takes in an extra input parameter <cite>sequence_length</cite> to specify variable length sequence</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='0'</em>) – The sequence axis. Only 0 is currently supported.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.SliceChannel">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">SliceChannel</code><span class="sig-paren">(</span><em>data=None</em>, <em>num_outputs=_Null</em>, <em>axis=_Null</em>, <em>squeeze_axis=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.SliceChannel" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits an array along a particular axis into multiple sub-arrays.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">SliceChannel</span></code> is deprecated. Use <code class="docutils literal"><span class="pre">split</span></code> instead.</p>
</div>
<p><strong>Note</strong> that <cite>num_outputs</cite> should evenly divide the length of the axis
along which to split the array.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span>  <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">]</span>
       <span class="p">[</span> <span class="mf">2.</span><span class="p">]]</span>
      <span class="p">[[</span> <span class="mf">3.</span><span class="p">]</span>
       <span class="p">[</span> <span class="mf">4.</span><span class="p">]]</span>
      <span class="p">[[</span> <span class="mf">5.</span><span class="p">]</span>
       <span class="p">[</span> <span class="mf">6.</span><span class="p">]]]</span>
<span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="mi">2</span> <span class="n">arrays</span> <span class="k">with</span> <span class="n">shape</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">]]</span>
     <span class="p">[[</span> <span class="mf">3.</span><span class="p">]]</span>
     <span class="p">[[</span> <span class="mf">5.</span><span class="p">]]]</span>

    <span class="p">[[[</span> <span class="mf">2.</span><span class="p">]]</span>
     <span class="p">[[</span> <span class="mf">4.</span><span class="p">]]</span>
     <span class="p">[[</span> <span class="mf">6.</span><span class="p">]]]</span>

<span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">//</span> <span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="mi">3</span> <span class="n">arrays</span> <span class="k">with</span> <span class="n">shape</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">]</span>
      <span class="p">[</span> <span class="mf">2.</span><span class="p">]]]</span>

    <span class="p">[[[</span> <span class="mf">3.</span><span class="p">]</span>
      <span class="p">[</span> <span class="mf">4.</span><span class="p">]]]</span>

    <span class="p">[[[</span> <span class="mf">5.</span><span class="p">]</span>
      <span class="p">[</span> <span class="mf">6.</span><span class="p">]]]</span>

<span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><cite>squeeze_axis=1</cite> removes the axis with length 1 from the shapes of the output arrays.
<strong>Note</strong> that setting <cite>squeeze_axis</cite> to <code class="docutils literal"><span class="pre">1</span></code> removes axis with length 1 only
along the <cite>axis</cite> which it is split.
Also <cite>squeeze_axis</cite> can be set to true only if <code class="docutils literal"><span class="pre">input.shape[axis]</span> <span class="pre">==</span> <span class="pre">num_outputs</span></code>.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">squeeze_axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="mi">3</span> <span class="n">arrays</span> <span class="k">with</span> <span class="n">shape</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">]</span>
     <span class="p">[</span> <span class="mf">2.</span><span class="p">]]</span>

    <span class="p">[[</span> <span class="mf">3.</span><span class="p">]</span>
     <span class="p">[</span> <span class="mf">4.</span><span class="p">]]</span>

    <span class="p">[[</span> <span class="mf">5.</span><span class="p">]</span>
     <span class="p">[</span> <span class="mf">6.</span><span class="p">]]</span>
<span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="p">,</span><span class="mi">1</span> <span class="p">)</span>
</pre></div>
</div>
<p>Defined in src/operator/slice_channel.cc:L107</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>num_outputs</strong> (<em>int</em><em>, </em><em>required</em>) – Number of splits. Note that this should evenly divide the length of the <cite>axis</cite>.</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='1'</em>) – Axis along which to split.</li>
<li><strong>squeeze_axis</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If true, Removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <cite>squeeze_axis</cite> to <code class="docutils literal"><span class="pre">true</span></code> removes axis with length 1 only along the <cite>axis</cite> which it is split. Also <cite>squeeze_axis</cite> can be set to <code class="docutils literal"><span class="pre">true</span></code> only if <code class="docutils literal"><span class="pre">input.shape[axis]</span> <span class="pre">==</span> <span class="pre">num_outputs</span></code>.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.Softmax">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">Softmax</code><span class="sig-paren">(</span><em>data=None</em>, <em>label=None</em>, <em>grad_scale=_Null</em>, <em>ignore_label=_Null</em>, <em>multi_output=_Null</em>, <em>use_ignore=_Null</em>, <em>preserve_shape=_Null</em>, <em>normalization=_Null</em>, <em>out_grad=_Null</em>, <em>smooth_alpha=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.Softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the gradient of cross entropy loss with respect to softmax output.</p>
<ul>
<li><p class="first">This operator computes the gradient in two steps.
The cross entropy loss does not actually need to be computed.</p>
<ul class="simple">
<li>Applies softmax function on the input array.</li>
<li>Computes and returns the gradient of cross entropy loss w.r.t. the softmax output.</li>
</ul>
</li>
<li><p class="first">The softmax function, cross entropy loss and gradient is given by:</p>
<ul>
<li><p class="first">Softmax Function:</p>
<div class="math">
\[\text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}\]</div>
</li>
<li><p class="first">Cross Entropy Function:</p>
<div class="math">
\[\text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)\]</div>
</li>
<li><p class="first">The gradient of cross entropy loss w.r.t softmax output:</p>
<div class="math">
\[\text{gradient} = \text{output} - \text{label}\]</div>
</li>
</ul>
</li>
<li><p class="first">During forward propagation, the softmax function is computed for each instance in the input array.</p>
<p>For general <em>N</em>-D input arrays with shape <span class="math">\((d_1, d_2, ..., d_n)\)</span>. The size is
<span class="math">\(s=d_1 \cdot d_2 \cdot \cdot \cdot d_n\)</span>. We can use the parameters <cite>preserve_shape</cite>
and <cite>multi_output</cite> to specify the way to compute softmax:</p>
<ul class="simple">
<li>By default, <cite>preserve_shape</cite> is <code class="docutils literal"><span class="pre">false</span></code>. This operator will reshape the input array
into a 2-D array with shape <span class="math">\((d_1, \frac{s}{d_1})\)</span> and then compute the softmax function for
each row in the reshaped array, and afterwards reshape it back to the original shape
<span class="math">\((d_1, d_2, ..., d_n)\)</span>.</li>
<li>If <cite>preserve_shape</cite> is <code class="docutils literal"><span class="pre">true</span></code>, the softmax function will be computed along
the last axis (<cite>axis</cite> = <code class="docutils literal"><span class="pre">-1</span></code>).</li>
<li>If <cite>multi_output</cite> is <code class="docutils literal"><span class="pre">true</span></code>, the softmax function will be computed along
the second axis (<cite>axis</cite> = <code class="docutils literal"><span class="pre">1</span></code>).</li>
</ul>
</li>
<li><p class="first">During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.
The provided label can be a one-hot label array or a probability label array.</p>
<ul>
<li><p class="first">If the parameter <cite>use_ignore</cite> is <code class="docutils literal"><span class="pre">true</span></code>, <cite>ignore_label</cite> can specify input instances
with a particular label to be ignored during backward propagation. <strong>This has no effect when
softmax `output` has same shape as `label`</strong>.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="n">label</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">ignore_label</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">SoftmaxOutput</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="p">,</span>\
              <span class="n">multi_output</span><span class="o">=</span><span class="n">true</span><span class="p">,</span> <span class="n">use_ignore</span><span class="o">=</span><span class="n">true</span><span class="p">,</span>\
              <span class="n">ignore_label</span><span class="o">=</span><span class="n">ignore_label</span><span class="p">)</span>
<span class="c1">## forward softmax output</span>
<span class="p">[[</span> <span class="mf">0.0320586</span>   <span class="mf">0.08714432</span>  <span class="mf">0.23688284</span>  <span class="mf">0.64391428</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.25</span>        <span class="mf">0.25</span>        <span class="mf">0.25</span>        <span class="mf">0.25</span>      <span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.25</span>        <span class="mf">0.25</span>        <span class="mf">0.25</span>        <span class="mf">0.25</span>      <span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.25</span>        <span class="mf">0.25</span>        <span class="mf">0.25</span>        <span class="mf">0.25</span>      <span class="p">]]</span>
<span class="c1">## backward gradient output</span>
<span class="p">[[</span> <span class="mf">0.</span>    <span class="mf">0.</span>    <span class="mf">0.</span>    <span class="mf">0.</span>  <span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mf">0.75</span>  <span class="mf">0.25</span>  <span class="mf">0.25</span>  <span class="mf">0.25</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.25</span>  <span class="mf">0.25</span> <span class="o">-</span><span class="mf">0.75</span>  <span class="mf">0.25</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.25</span>  <span class="mf">0.25</span>  <span class="mf">0.25</span> <span class="o">-</span><span class="mf">0.75</span><span class="p">]]</span>
<span class="c1">## notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.</span>
</pre></div>
</div>
</li>
<li><p class="first">The parameter <cite>grad_scale</cite> can be used to rescale the gradient, which is often used to
give each loss function different weights.</p>
</li>
<li><p class="first">This operator also supports various ways to normalize the gradient by <cite>normalization</cite>,
The <cite>normalization</cite> is applied if softmax output has different shape than the labels.
The <cite>normalization</cite> mode can be set to the followings:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'null'</span></code>: do nothing.</li>
<li><code class="docutils literal"><span class="pre">'batch'</span></code>: divide the gradient by the batch size.</li>
<li><code class="docutils literal"><span class="pre">'valid'</span></code>: divide the gradient by the number of instances which are not ignored.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Defined in src/operator/softmax_output.cc:L230</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input array.</li>
<li><strong>label</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Ground truth label.</li>
<li><strong>grad_scale</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Scales the gradient by a float factor.</li>
<li><strong>ignore_label</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – The instances whose <cite>labels</cite> == <cite>ignore_label</cite> will be ignored during backward, if <cite>use_ignore</cite> is set to <code class="docutils literal"><span class="pre">true</span></code>).</li>
<li><strong>multi_output</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If set to <code class="docutils literal"><span class="pre">true</span></code>, the softmax function will be computed along axis <code class="docutils literal"><span class="pre">1</span></code>. This is applied when the shape of input array differs from the shape of label array.</li>
<li><strong>use_ignore</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If set to <code class="docutils literal"><span class="pre">true</span></code>, the <cite>ignore_label</cite> value will not contribute to the backward gradient.</li>
<li><strong>preserve_shape</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If set to <code class="docutils literal"><span class="pre">true</span></code>, the softmax function will be computed along the last axis (<code class="docutils literal"><span class="pre">-1</span></code>).</li>
<li><strong>normalization</strong> (<em>{'batch'</em><em>, </em><em>'null'</em><em>, </em><em>'valid'}</em><em>,</em><em>optional</em><em>, </em><em>default='null'</em>) – Normalizes the gradient.</li>
<li><strong>out_grad</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Multiplies gradient with output gradient element-wise.</li>
<li><strong>smooth_alpha</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Constant for computing a label smoothed version of cross-entropyfor the backwards pass.  This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other labels.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.SoftmaxActivation">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">SoftmaxActivation</code><span class="sig-paren">(</span><em>data=None</em>, <em>mode=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.SoftmaxActivation" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies softmax activation to input. This is intended for internal layers.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This operator has been deprecated, please use <cite>softmax</cite>.</p>
</div>
<p>If <cite>mode</cite> = <code class="docutils literal"><span class="pre">instance</span></code>, this operator will compute a softmax for each instance in the batch.
This is the default mode.</p>
<p>If <cite>mode</cite> = <code class="docutils literal"><span class="pre">channel</span></code>, this operator will compute a k-class softmax at each position
of each instance, where <cite>k</cite> = <code class="docutils literal"><span class="pre">num_channel</span></code>. This mode can only be used when the input array
has at least 3 dimensions.
This can be used for <cite>fully convolutional network</cite>, <cite>image segmentation</cite>, etc.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">input_array</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">],</span>
<span class="gp">>>> </span>                           <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-.</span><span class="mi">4</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]])</span>
<span class="gp">>>> </span><span class="n">softmax_act</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">SoftmaxActivation</span><span class="p">(</span><span class="n">input_array</span><span class="p">)</span>
<span class="gp">>>> </span><span class="nb">print</span> <span class="n">softmax_act</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">[[  1.78322066e-02   1.46375655e-03   5.38485940e-04   6.56010211e-03   9.73605454e-01]</span>
<span class="go"> [  6.56221947e-03   5.95310994e-04   9.73919690e-01   1.78379621e-02   1.08472735e-03]]</span>
</pre></div>
</div>
<p>Defined in src/operator/nn/softmax_activation.cc:L59</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>mode</strong> (<em>{'channel'</em><em>, </em><em>'instance'}</em><em>,</em><em>optional</em><em>, </em><em>default='instance'</em>) – Specifies how to compute the softmax. If set to <code class="docutils literal"><span class="pre">instance</span></code>, it computes softmax for each instance. If set to <code class="docutils literal"><span class="pre">channel</span></code>, It computes cross channel softmax for each position of each instance.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.SoftmaxOutput">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">SoftmaxOutput</code><span class="sig-paren">(</span><em>data=None</em>, <em>label=None</em>, <em>grad_scale=_Null</em>, <em>ignore_label=_Null</em>, <em>multi_output=_Null</em>, <em>use_ignore=_Null</em>, <em>preserve_shape=_Null</em>, <em>normalization=_Null</em>, <em>out_grad=_Null</em>, <em>smooth_alpha=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.SoftmaxOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the gradient of cross entropy loss with respect to softmax output.</p>
<ul>
<li><p class="first">This operator computes the gradient in two steps.
The cross entropy loss does not actually need to be computed.</p>
<ul class="simple">
<li>Applies softmax function on the input array.</li>
<li>Computes and returns the gradient of cross entropy loss w.r.t. the softmax output.</li>
</ul>
</li>
<li><p class="first">The softmax function, cross entropy loss and gradient is given by:</p>
<ul>
<li><p class="first">Softmax Function:</p>
<div class="math">
\[\text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}\]</div>
</li>
<li><p class="first">Cross Entropy Function:</p>
<div class="math">
\[\text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)\]</div>
</li>
<li><p class="first">The gradient of cross entropy loss w.r.t softmax output:</p>
<div class="math">
\[\text{gradient} = \text{output} - \text{label}\]</div>
</li>
</ul>
</li>
<li><p class="first">During forward propagation, the softmax function is computed for each instance in the input array.</p>
<p>For general <em>N</em>-D input arrays with shape <span class="math">\((d_1, d_2, ..., d_n)\)</span>. The size is
<span class="math">\(s=d_1 \cdot d_2 \cdot \cdot \cdot d_n\)</span>. We can use the parameters <cite>preserve_shape</cite>
and <cite>multi_output</cite> to specify the way to compute softmax:</p>
<ul class="simple">
<li>By default, <cite>preserve_shape</cite> is <code class="docutils literal"><span class="pre">false</span></code>. This operator will reshape the input array
into a 2-D array with shape <span class="math">\((d_1, \frac{s}{d_1})\)</span> and then compute the softmax function for
each row in the reshaped array, and afterwards reshape it back to the original shape
<span class="math">\((d_1, d_2, ..., d_n)\)</span>.</li>
<li>If <cite>preserve_shape</cite> is <code class="docutils literal"><span class="pre">true</span></code>, the softmax function will be computed along
the last axis (<cite>axis</cite> = <code class="docutils literal"><span class="pre">-1</span></code>).</li>
<li>If <cite>multi_output</cite> is <code class="docutils literal"><span class="pre">true</span></code>, the softmax function will be computed along
the second axis (<cite>axis</cite> = <code class="docutils literal"><span class="pre">1</span></code>).</li>
</ul>
</li>
<li><p class="first">During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.
The provided label can be a one-hot label array or a probability label array.</p>
<ul>
<li><p class="first">If the parameter <cite>use_ignore</cite> is <code class="docutils literal"><span class="pre">true</span></code>, <cite>ignore_label</cite> can specify input instances
with a particular label to be ignored during backward propagation. <strong>This has no effect when
softmax `output` has same shape as `label`</strong>.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="n">label</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">ignore_label</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">SoftmaxOutput</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="p">,</span>\
              <span class="n">multi_output</span><span class="o">=</span><span class="n">true</span><span class="p">,</span> <span class="n">use_ignore</span><span class="o">=</span><span class="n">true</span><span class="p">,</span>\
              <span class="n">ignore_label</span><span class="o">=</span><span class="n">ignore_label</span><span class="p">)</span>
<span class="c1">## forward softmax output</span>
<span class="p">[[</span> <span class="mf">0.0320586</span>   <span class="mf">0.08714432</span>  <span class="mf">0.23688284</span>  <span class="mf">0.64391428</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.25</span>        <span class="mf">0.25</span>        <span class="mf">0.25</span>        <span class="mf">0.25</span>      <span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.25</span>        <span class="mf">0.25</span>        <span class="mf">0.25</span>        <span class="mf">0.25</span>      <span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.25</span>        <span class="mf">0.25</span>        <span class="mf">0.25</span>        <span class="mf">0.25</span>      <span class="p">]]</span>
<span class="c1">## backward gradient output</span>
<span class="p">[[</span> <span class="mf">0.</span>    <span class="mf">0.</span>    <span class="mf">0.</span>    <span class="mf">0.</span>  <span class="p">]</span>
 <span class="p">[</span><span class="o">-</span><span class="mf">0.75</span>  <span class="mf">0.25</span>  <span class="mf">0.25</span>  <span class="mf">0.25</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.25</span>  <span class="mf">0.25</span> <span class="o">-</span><span class="mf">0.75</span>  <span class="mf">0.25</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.25</span>  <span class="mf">0.25</span>  <span class="mf">0.25</span> <span class="o">-</span><span class="mf">0.75</span><span class="p">]]</span>
<span class="c1">## notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.</span>
</pre></div>
</div>
</li>
<li><p class="first">The parameter <cite>grad_scale</cite> can be used to rescale the gradient, which is often used to
give each loss function different weights.</p>
</li>
<li><p class="first">This operator also supports various ways to normalize the gradient by <cite>normalization</cite>,
The <cite>normalization</cite> is applied if softmax output has different shape than the labels.
The <cite>normalization</cite> mode can be set to the followings:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'null'</span></code>: do nothing.</li>
<li><code class="docutils literal"><span class="pre">'batch'</span></code>: divide the gradient by the batch size.</li>
<li><code class="docutils literal"><span class="pre">'valid'</span></code>: divide the gradient by the number of instances which are not ignored.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Defined in src/operator/softmax_output.cc:L230</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input array.</li>
<li><strong>label</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Ground truth label.</li>
<li><strong>grad_scale</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Scales the gradient by a float factor.</li>
<li><strong>ignore_label</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – The instances whose <cite>labels</cite> == <cite>ignore_label</cite> will be ignored during backward, if <cite>use_ignore</cite> is set to <code class="docutils literal"><span class="pre">true</span></code>).</li>
<li><strong>multi_output</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If set to <code class="docutils literal"><span class="pre">true</span></code>, the softmax function will be computed along axis <code class="docutils literal"><span class="pre">1</span></code>. This is applied when the shape of input array differs from the shape of label array.</li>
<li><strong>use_ignore</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If set to <code class="docutils literal"><span class="pre">true</span></code>, the <cite>ignore_label</cite> value will not contribute to the backward gradient.</li>
<li><strong>preserve_shape</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If set to <code class="docutils literal"><span class="pre">true</span></code>, the softmax function will be computed along the last axis (<code class="docutils literal"><span class="pre">-1</span></code>).</li>
<li><strong>normalization</strong> (<em>{'batch'</em><em>, </em><em>'null'</em><em>, </em><em>'valid'}</em><em>,</em><em>optional</em><em>, </em><em>default='null'</em>) – Normalizes the gradient.</li>
<li><strong>out_grad</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Multiplies gradient with output gradient element-wise.</li>
<li><strong>smooth_alpha</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Constant for computing a label smoothed version of cross-entropyfor the backwards pass.  This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other labels.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.SpatialTransformer">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">SpatialTransformer</code><span class="sig-paren">(</span><em>data=None</em>, <em>loc=None</em>, <em>target_shape=_Null</em>, <em>transform_type=_Null</em>, <em>sampler_type=_Null</em>, <em>cudnn_off=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.SpatialTransformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a spatial transformer to input feature map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to the SpatialTransformerOp.</li>
<li><strong>loc</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – localisation net, the output dim should be 6 when transform_type is affine. You shold initialize the weight and bias with identity tranform.</li>
<li><strong>target_shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>0</em><em>,</em><em>0</em><em>]</em>) – output shape(h, w) of spatial transformer: (y, x)</li>
<li><strong>transform_type</strong> (<em>{'affine'}</em><em>, </em><em>required</em>) – transformation type</li>
<li><strong>sampler_type</strong> (<em>{'bilinear'}</em><em>, </em><em>required</em>) – sampling type</li>
<li><strong>cudnn_off</strong> (<em>boolean</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – whether to turn cudnn off</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.SwapAxis">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">SwapAxis</code><span class="sig-paren">(</span><em>data=None</em>, <em>dim1=_Null</em>, <em>dim2=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.SwapAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Interchanges two axes of an array.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span> <span class="n">x</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
 <span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mi">1</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mi">2</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mi">3</span><span class="p">]]</span>

 <span class="n">x</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span>
      <span class="p">[[</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]]</span>  <span class="o">//</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="n">array</span>

<span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span>
                     <span class="p">[[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/swapaxis.cc:L70</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input array.</li>
<li><strong>dim1</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – the first axis to be swapped.</li>
<li><strong>dim2</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – the second axis to be swapped.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.UpSampling">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">UpSampling</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.UpSampling" title="Permalink to this definition">¶</a></dt>
<dd><p>Upsamples the given input data.</p>
<p>Two algorithms (<code class="docutils literal"><span class="pre">sample_type</span></code>) are available for upsampling:</p>
<ul class="simple">
<li>Nearest Neighbor</li>
<li>Bilinear</li>
</ul>
<p><strong>Nearest Neighbor Upsampling</strong></p>
<p>Input data is expected to be NCHW.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[[[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]</span>
       <span class="p">[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]</span>
       <span class="p">[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]]]]</span>

<span class="n">UpSampling</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sample_type</span><span class="o">=</span><span class="s1">'nearest'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]</span>
                                                   <span class="p">[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]</span>
                                                   <span class="p">[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]</span>
                                                   <span class="p">[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]</span>
                                                   <span class="p">[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]</span>
                                                   <span class="p">[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]]]]</span>
</pre></div>
</div>
<p><strong>Bilinear Upsampling</strong></p>
<p>Uses <cite>deconvolution</cite> algorithm under the hood. You need provide both input data and the kernel.</p>
<p>Input data is expected to be NCHW.</p>
<p><cite>num_filter</cite> is expected to be same as the number of channels.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[[[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]</span>
       <span class="p">[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]</span>
       <span class="p">[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]]]]</span>

<span class="n">w</span> <span class="o">=</span> <span class="p">[[[[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]</span>
       <span class="p">[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]</span>
       <span class="p">[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]</span>
       <span class="p">[</span><span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span> <span class="mf">1.</span><span class="p">]]]]</span>

<span class="n">UpSampling</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sample_type</span><span class="o">=</span><span class="s1">'bilinear'</span><span class="p">,</span> <span class="n">num_filter</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[[</span><span class="mf">1.</span> <span class="mf">2.</span> <span class="mf">2.</span> <span class="mf">2.</span> <span class="mf">2.</span> <span class="mf">1.</span><span class="p">]</span>
                                                                     <span class="p">[</span><span class="mf">2.</span> <span class="mf">4.</span> <span class="mf">4.</span> <span class="mf">4.</span> <span class="mf">4.</span> <span class="mf">2.</span><span class="p">]</span>
                                                                     <span class="p">[</span><span class="mf">2.</span> <span class="mf">4.</span> <span class="mf">4.</span> <span class="mf">4.</span> <span class="mf">4.</span> <span class="mf">2.</span><span class="p">]</span>
                                                                     <span class="p">[</span><span class="mf">2.</span> <span class="mf">4.</span> <span class="mf">4.</span> <span class="mf">4.</span> <span class="mf">4.</span> <span class="mf">2.</span><span class="p">]</span>
                                                                     <span class="p">[</span><span class="mf">2.</span> <span class="mf">4.</span> <span class="mf">4.</span> <span class="mf">4.</span> <span class="mf">4.</span> <span class="mf">2.</span><span class="p">]</span>
                                                                     <span class="p">[</span><span class="mf">1.</span> <span class="mf">2.</span> <span class="mf">2.</span> <span class="mf">2.</span> <span class="mf">2.</span> <span class="mf">1.</span><span class="p">]]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/nn/upsampling.cc:L173</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>[</em><em>]</em>) – Array of tensors to upsample. For bilinear upsampling, there should be 2 inputs - 1 data and 1 weight.</li>
<li><strong>scale</strong> (<em>int</em><em>, </em><em>required</em>) – Up sampling scale</li>
<li><strong>num_filter</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='0'</em>) – Input filter. Only used by bilinear sample_type.Since bilinear upsampling uses deconvolution, num_filters is set to the number of channels.</li>
<li><strong>sample_type</strong> (<em>{'bilinear'</em><em>, </em><em>'nearest'}</em><em>, </em><em>required</em>) – upsampling method</li>
<li><strong>multi_input_mode</strong> (<em>{'concat'</em><em>, </em><em>'sum'}</em><em>,</em><em>optional</em><em>, </em><em>default='concat'</em>) – How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling.</li>
<li><strong>workspace</strong> (<em>long</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=512</em>) – Tmp workspace for deconvolution (MB)</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.abs">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">abs</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise absolute value of the input.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">abs</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">abs</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>abs(default) = default</li>
<li>abs(row_sparse) = row_sparse</li>
<li>abs(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L708</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.adam_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">adam_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>mean=None</em>, <em>var=None</em>, <em>lr=_Null</em>, <em>beta1=_Null</em>, <em>beta2=_Null</em>, <em>epsilon=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>lazy_update=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.adam_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update function for Adam optimizer. Adam is seen as a generalization
of AdaGrad.</p>
<p>Adam update consists of the following steps, where g represents gradient and m, v
are 1st and 2nd order moment estimates (mean and variance).</p>
<div class="math">
\[\begin{split}g_t = \nabla J(W_{t-1})\\
m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t\\
v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
W_t = W_{t-1} - \alpha \frac{ m_t }{ \sqrt{ v_t } + \epsilon }\end{split}\]</div>
<p>It updates the weights using:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">beta1</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta1</span><span class="p">)</span><span class="o">*</span><span class="n">grad</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">beta2</span><span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">grad</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">w</span> <span class="o">+=</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">m</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>
</pre></div>
</div>
<p>However, if grad’s storage type is <code class="docutils literal"><span class="pre">row_sparse</span></code>, <code class="docutils literal"><span class="pre">lazy_update</span></code> is True and the storage
type of weight is the same as those of m and v,
only the row slices whose indices appear in grad.indices are updated (for w, m and v):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">grad</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="n">m</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta1</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta1</span><span class="p">)</span><span class="o">*</span><span class="n">grad</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
    <span class="n">v</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta2</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">grad</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">w</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">m</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">row</span><span class="p">])</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>
</pre></div>
</div>
<p>Defined in src/operator/optimizer_op.cc:L686</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Gradient</li>
<li><strong>mean</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Moving mean</li>
<li><strong>var</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Moving variance</li>
<li><strong>lr</strong> (<em>float</em><em>, </em><em>required</em>) – Learning rate</li>
<li><strong>beta1</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.899999976</em>) – The decay rate for the 1st moment estimates.</li>
<li><strong>beta2</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.999000013</em>) – The decay rate for the 2nd moment estimates.</li>
<li><strong>epsilon</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=9.99999994e-09</em>) – A small constant for numerical stability.</li>
<li><strong>wd</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>lazy_update</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – If true, lazy updates are applied if gradient’s stype is row_sparse and all of w, m and v have the same stype</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.add_n">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">add_n</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.add_n" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds all input arguments element-wise.</p>
<div class="math">
\[add\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\]</div>
<p><code class="docutils literal"><span class="pre">add_n</span></code> is potentially more efficient than calling <code class="docutils literal"><span class="pre">add</span></code> by <cite>n</cite> times.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">add_n</span></code> output depends on storage types of inputs</p>
<ul class="simple">
<li>add_n(row_sparse, row_sparse, ..) = row_sparse</li>
<li>add_n(default, csr, default) = default</li>
<li>add_n(any input combinations longer than 4 (>4) with at least one default type) = default</li>
<li>otherwise, <code class="docutils literal"><span class="pre">add_n</span></code> falls all inputs back to default storage and generates default storage</li>
</ul>
<p>Defined in src/operator/tensor/elemwise_sum.cc:L155</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>[</em><em>]</em>) – Positional input arguments</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.all_finite">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">all_finite</code><span class="sig-paren">(</span><em>data=None</em>, <em>init_output=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.all_finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if all the float numbers in the array are finite (used for AMP)</p>
<p>Defined in src/operator/contrib/all_finite.cc:L101</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Array</li>
<li><strong>init_output</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Initialize output to 1.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.amp_cast">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">amp_cast</code><span class="sig-paren">(</span><em>data=None</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.amp_cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast function between low precision float/FP32 used by AMP.</p>
<p>It casts only between low precision float/FP32 and does not do anything for other types.</p>
<p>Defined in src/operator/tensor/amp_cast.cc:L37</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input.</li>
<li><strong>dtype</strong> (<em>{'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'</em><em>, </em><em>'int32'</em><em>, </em><em>'int64'</em><em>, </em><em>'int8'</em><em>, </em><em>'uint8'}</em><em>, </em><em>required</em>) – Output data type.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.amp_multicast">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">amp_multicast</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.amp_multicast" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast function used by AMP, that casts its inputs to the common widest type.</p>
<p>It casts only between low precision float/FP32 and does not do anything for other types.</p>
<p>Defined in src/operator/tensor/amp_cast.cc:L71</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>[</em><em>]</em>) – Weights</li>
<li><strong>num_outputs</strong> (<em>int</em><em>, </em><em>required</em>) – Number of input/output pairs to be casted to the widest type.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.arccos">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">arccos</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.arccos" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise inverse cosine of the input array.</p>
<p>The input should be in range <cite>[-1, 1]</cite>.
The output is in the closed interval <span class="math">\([0, \pi]\)</span></p>
<div class="math">
\[arccos([-1, -.707, 0, .707, 1]) = [\pi, 3\pi/4, \pi/2, \pi/4, 0]\]</div>
<p>The storage type of <code class="docutils literal"><span class="pre">arccos</span></code> output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L179</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.arccosh">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">arccosh</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.arccosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the element-wise inverse hyperbolic cosine of the input array, computed element-wise.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">arccosh</span></code> output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L320</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.arcsin">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">arcsin</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.arcsin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise inverse sine of the input array.</p>
<p>The input should be in the range <cite>[-1, 1]</cite>.
The output is in the closed interval of [<span class="math">\(-\pi/2\)</span>, <span class="math">\(\pi/2\)</span>].</p>
<div class="math">
\[arcsin([-1, -.707, 0, .707, 1]) = [-\pi/2, -\pi/4, 0, \pi/4, \pi/2]\]</div>
<p>The storage type of <code class="docutils literal"><span class="pre">arcsin</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>arcsin(default) = default</li>
<li>arcsin(row_sparse) = row_sparse</li>
<li>arcsin(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L160</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.arcsinh">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">arcsinh</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.arcsinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the element-wise inverse hyperbolic sine of the input array, computed element-wise.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">arcsinh</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>arcsinh(default) = default</li>
<li>arcsinh(row_sparse) = row_sparse</li>
<li>arcsinh(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L306</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.arctan">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">arctan</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.arctan" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise inverse tangent of the input array.</p>
<p>The output is in the closed interval <span class="math">\([-\pi/2, \pi/2]\)</span></p>
<div class="math">
\[arctan([-1, 0, 1]) = [-\pi/4, 0, \pi/4]\]</div>
<p>The storage type of <code class="docutils literal"><span class="pre">arctan</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>arctan(default) = default</li>
<li>arctan(row_sparse) = row_sparse</li>
<li>arctan(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L200</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.arctanh">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">arctanh</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.arctanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the element-wise inverse hyperbolic tangent of the input array, computed element-wise.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">arctanh</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>arctanh(default) = default</li>
<li>arctanh(row_sparse) = row_sparse</li>
<li>arctanh(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L337</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.argmax">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">argmax</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns indices of the maximum values along an axis.</p>
<p>In the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence
are returned.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">argmax</span> <span class="n">along</span> <span class="n">axis</span> <span class="mi">0</span>
<span class="n">argmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]</span>

<span class="o">//</span> <span class="n">argmax</span> <span class="n">along</span> <span class="n">axis</span> <span class="mi">1</span>
<span class="n">argmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]</span>

<span class="o">//</span> <span class="n">argmax</span> <span class="n">along</span> <span class="n">axis</span> <span class="mi">1</span> <span class="n">keeping</span> <span class="n">same</span> <span class="n">dims</span> <span class="k">as</span> <span class="n">an</span> <span class="nb">input</span> <span class="n">array</span>
<span class="n">argmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">],</span>
                                    <span class="p">[</span> <span class="mf">2.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L52</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>axis</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default='None'</em>) – The axis along which to perform the reduction. Negative values means indexing from right to left. <code class="docutils literal"><span class="pre">Requires</span> <span class="pre">axis</span> <span class="pre">to</span> <span class="pre">be</span> <span class="pre">set</span> <span class="pre">as</span> <span class="pre">int,</span> <span class="pre">because</span> <span class="pre">global</span> <span class="pre">reduction</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">supported</span> <span class="pre">yet.</span></code></li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If this is set to <cite>True</cite>, the reduced axis is left in the result as dimension with size one.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.argmax_channel">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">argmax_channel</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.argmax_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns argmax indices of each channel from the input array.</p>
<p>The result will be an NDArray of shape (num_channel,).</p>
<p>In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence
are returned.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]]</span>

<span class="n">argmax_channel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L97</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.argmin">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">argmin</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns indices of the minimum values along an axis.</p>
<p>In the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence
are returned.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">argmin</span> <span class="n">along</span> <span class="n">axis</span> <span class="mi">0</span>
<span class="n">argmin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]</span>

<span class="o">//</span> <span class="n">argmin</span> <span class="n">along</span> <span class="n">axis</span> <span class="mi">1</span>
<span class="n">argmin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]</span>

<span class="o">//</span> <span class="n">argmin</span> <span class="n">along</span> <span class="n">axis</span> <span class="mi">1</span> <span class="n">keeping</span> <span class="n">same</span> <span class="n">dims</span> <span class="k">as</span> <span class="n">an</span> <span class="nb">input</span> <span class="n">array</span>
<span class="n">argmin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
                                    <span class="p">[</span> <span class="mf">0.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L77</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>axis</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default='None'</em>) – The axis along which to perform the reduction. Negative values means indexing from right to left. <code class="docutils literal"><span class="pre">Requires</span> <span class="pre">axis</span> <span class="pre">to</span> <span class="pre">be</span> <span class="pre">set</span> <span class="pre">as</span> <span class="pre">int,</span> <span class="pre">because</span> <span class="pre">global</span> <span class="pre">reduction</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">supported</span> <span class="pre">yet.</span></code></li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If this is set to <cite>True</cite>, the reduced axis is left in the result as dimension with size one.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.argsort">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">argsort</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>is_ascend=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices that would sort an input array along the given axis.</p>
<p>This function performs sorting along the given axis and returns an array of indices having same shape
as an input array that index data in sorted order.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.3</span><span class="p">,</span>  <span class="mf">0.2</span><span class="p">,</span>  <span class="mf">0.4</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">0.1</span><span class="p">,</span>  <span class="mf">0.3</span><span class="p">,</span>  <span class="mf">0.2</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">sort</span> <span class="n">along</span> <span class="n">axis</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
              <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">sort</span> <span class="n">along</span> <span class="n">axis</span> <span class="mi">0</span>
<span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]</span>
                      <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">flatten</span> <span class="ow">and</span> <span class="n">then</span> <span class="n">sort</span>
<span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/ordering_op.cc:L177</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array</li>
<li><strong>axis</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default='-1'</em>) – Axis along which to sort the input tensor. If not given, the flattened array is used. Default is -1.</li>
<li><strong>is_ascend</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Whether to sort in ascending or descending order.</li>
<li><strong>dtype</strong> (<em>{'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'</em><em>, </em><em>'int32'</em><em>, </em><em>'uint8'}</em><em>,</em><em>optional</em><em>, </em><em>default='float32'</em>) – DType of the output indices. It is only valid when ret_typ is “indices” or “both”. An error will be raised if the selected data type cannot precisely represent the indices.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.batch_dot">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">batch_dot</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>transpose_a=_Null</em>, <em>transpose_b=_Null</em>, <em>forward_stype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.batch_dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Batchwise dot product.</p>
<p><code class="docutils literal"><span class="pre">batch_dot</span></code> is used to compute dot product of <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> when <code class="docutils literal"><span class="pre">x</span></code> and
<code class="docutils literal"><span class="pre">y</span></code> are data in batch, namely 3D arrays in shape of <cite>(batch_size, :, :)</cite>.</p>
<p>For example, given <code class="docutils literal"><span class="pre">x</span></code> with shape <cite>(batch_size, n, m)</cite> and <code class="docutils literal"><span class="pre">y</span></code> with shape
<cite>(batch_size, m, k)</cite>, the result array will have shape <cite>(batch_size, n, k)</cite>,
which is computed by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">batch_dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:])</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/dot.cc:L125</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The first input</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The second input</li>
<li><strong>transpose_a</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If true then transpose the first input before dot.</li>
<li><strong>transpose_b</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If true then transpose the second input before dot.</li>
<li><strong>forward_stype</strong> (<em>{None</em><em>, </em><em>'csr'</em><em>, </em><em>'default'</em><em>, </em><em>'row_sparse'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.batch_take">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">batch_take</code><span class="sig-paren">(</span><em>a=None</em>, <em>indices=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.batch_take" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes elements from a data batch.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>batch_take</cite> is deprecated. Use <cite>pick</cite> instead.</p>
</div>
<p>Given an input array of shape <code class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1)</span></code> and indices of shape <code class="docutils literal"><span class="pre">(i0,)</span></code>, the result will be
an output array of shape <code class="docutils literal"><span class="pre">(i0,)</span></code> with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
</pre></div>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">takes</span> <span class="n">elements</span> <span class="k">with</span> <span class="n">specified</span> <span class="n">indices</span>
<span class="n">batch_take</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.</span>  <span class="mf">4.</span>  <span class="mf">5.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/indexing_op.cc:L753</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array</li>
<li><strong>indices</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The index array</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_add">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_add</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise sum of the input arrays with broadcasting.</p>
<p><cite>broadcast_plus</cite> is an alias to the function <cite>broadcast_add</cite>.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]</span>

<span class="n">broadcast_plus</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Supported sparse operations:</p>
<blockquote>
<div>broadcast_add(csr, dense(1D)) = dense
broadcast_add(dense(1D), csr) = dense</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L58</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_axes">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_axes</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>size=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcasts the input array over particular axes.</p>
<p>Broadcasting is allowed on axes with size 1, such as from <cite>(2,1,3,1)</cite> to
<cite>(2,8,3,9)</cite>. Elements will be duplicated on the broadcasted axes.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">given</span> <span class="n">x</span> <span class="n">of</span> <span class="n">shape</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">2.</span><span class="p">]]]</span>

<span class="o">//</span> <span class="n">broadcast</span> <span class="n">x</span> <span class="n">on</span> <span class="n">on</span> <span class="n">axis</span> <span class="mi">2</span>
<span class="n">broadcast_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                                      <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]]</span>
<span class="o">//</span> <span class="n">broadcast</span> <span class="n">x</span> <span class="n">on</span> <span class="n">on</span> <span class="n">axes</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">2</span>
<span class="n">broadcast_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                                              <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]],</span>
                                             <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                                              <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L238</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – The axes to perform the broadcasting.</li>
<li><strong>size</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – Target sizes of the broadcasting axes.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_axis">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_axis</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>size=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcasts the input array over particular axes.</p>
<p>Broadcasting is allowed on axes with size 1, such as from <cite>(2,1,3,1)</cite> to
<cite>(2,8,3,9)</cite>. Elements will be duplicated on the broadcasted axes.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">given</span> <span class="n">x</span> <span class="n">of</span> <span class="n">shape</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">2.</span><span class="p">]]]</span>

<span class="o">//</span> <span class="n">broadcast</span> <span class="n">x</span> <span class="n">on</span> <span class="n">on</span> <span class="n">axis</span> <span class="mi">2</span>
<span class="n">broadcast_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                                      <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]]</span>
<span class="o">//</span> <span class="n">broadcast</span> <span class="n">x</span> <span class="n">on</span> <span class="n">on</span> <span class="n">axes</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">2</span>
<span class="n">broadcast_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                                              <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]],</span>
                                             <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                                              <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L238</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – The axes to perform the broadcasting.</li>
<li><strong>size</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – Target sizes of the broadcasting axes.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_div">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_div</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_div" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise division of the input arrays with broadcasting.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">6.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">6.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">3.</span><span class="p">]]</span>

<span class="n">broadcast_div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Supported sparse operations:</p>
<blockquote>
<div>broadcast_div(csr, dense(1D)) = csr</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L187</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_equal">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_equal</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>equal to</strong> (==) comparison operation with broadcasting.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                         <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L46</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_greater">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_greater</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_greater" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>greater than</strong> (>) comparison operation with broadcasting.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                           <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L82</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_greater_equal">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_greater_equal</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_greater_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>greater than or equal to</strong> (>=) comparison operation with broadcasting.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_greater_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                                 <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L100</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_hypot">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_hypot</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_hypot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the hypotenuse of a right angled triangle, given its “legs”
with broadcasting.</p>
<p>It is equivalent to doing <span class="math">\(sqrt(x_1^2 + x_2^2)\)</span>.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">4.</span><span class="p">]]</span>

<span class="n">broadcast_hypot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">],</span>
                         <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]]</span>

<span class="n">z</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">4.</span><span class="p">]]</span>

<span class="n">broadcast_hypot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
                         <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L156</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_lesser">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_lesser</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_lesser" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>lesser than</strong> (<) comparison operation with broadcasting.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_lesser</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L118</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_lesser_equal">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_lesser_equal</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_lesser_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>lesser than or equal to</strong> (<=) comparison operation with broadcasting.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_lesser_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                                <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L136</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_like">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_like</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>lhs_axes=_Null</em>, <em>rhs_axes=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcasts lhs to have the same shape as rhs.</p>
<p>Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
with arrays of different shapes efficiently without creating multiple copies of arrays.
Also see, <a class="reference external" href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">Broadcasting</a> for more explanation.</p>
<p>Broadcasting is allowed on axes with size 1, such as from <cite>(2,1,3,1)</cite> to
<cite>(2,8,3,9)</cite>. Elements will be duplicated on the broadcasted axes.</p>
<p>For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">broadcast_like</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
                                                <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">]])</span>

<span class="n">broadcast_like</span><span class="p">([</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">lhs_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">rhs_axes</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L315</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input.</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input.</li>
<li><strong>lhs_axes</strong> (<em>Shape</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Axes to perform broadcast on in the first input array</li>
<li><strong>rhs_axes</strong> (<em>Shape</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Axes to copy from the second input array</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_logical_and">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_logical_and</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_logical_and" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>logical and</strong> with broadcasting.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_logical_and</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                               <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L154</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_logical_or">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_logical_or</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_logical_or" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>logical or</strong> with broadcasting.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">0.</span><span class="p">]]</span>

<span class="n">broadcast_logical_or</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                              <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L172</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_logical_xor">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_logical_xor</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_logical_xor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>logical xor</strong> with broadcasting.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">0.</span><span class="p">]]</span>

<span class="n">broadcast_logical_xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                               <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L190</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_maximum">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_maximum</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise maximum of the input arrays with broadcasting.</p>
<p>This function compares two input arrays and returns a new array having the element-wise maxima.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_maximum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                           <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L80</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_minimum">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_minimum</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise minimum of the input arrays with broadcasting.</p>
<p>This function compares two input arrays and returns a new array having the element-wise minima.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_maximum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                           <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L115</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_minus">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_minus</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_minus" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise difference of the input arrays with broadcasting.</p>
<p><cite>broadcast_minus</cite> is an alias to the function <cite>broadcast_sub</cite>.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>

<span class="n">broadcast_minus</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                         <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Supported sparse operations:</p>
<blockquote>
<div>broadcast_sub/minus(csr, dense(1D)) = dense
broadcast_sub/minus(dense(1D), csr) = dense</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L106</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_mod">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_mod</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise modulo of the input arrays with broadcasting.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">8.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">8.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">3.</span><span class="p">]]</span>

<span class="n">broadcast_mod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L222</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_mul">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_mul</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise product of the input arrays with broadcasting.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Supported sparse operations:</p>
<blockquote>
<div>broadcast_mul(csr, dense(1D)) = csr</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L146</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_not_equal">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_not_equal</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_not_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>not equal to</strong> (!=) comparison operation with broadcasting.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_not_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                             <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_logic.cc:L64</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_plus">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_plus</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_plus" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise sum of the input arrays with broadcasting.</p>
<p><cite>broadcast_plus</cite> is an alias to the function <cite>broadcast_add</cite>.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]</span>

<span class="n">broadcast_plus</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Supported sparse operations:</p>
<blockquote>
<div>broadcast_add(csr, dense(1D)) = dense
broadcast_add(dense(1D), csr) = dense</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L58</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_power">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_power</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_power" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns result of first array elements raised to powers from second array, element-wise with broadcasting.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                         <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_extended.cc:L45</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_sub">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_sub</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise difference of the input arrays with broadcasting.</p>
<p><cite>broadcast_minus</cite> is an alias to the function <cite>broadcast_sub</cite>.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="n">broadcast_sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>

<span class="n">broadcast_minus</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                         <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Supported sparse operations:</p>
<blockquote>
<div>broadcast_sub/minus(csr, dense(1D)) = dense
broadcast_sub/minus(dense(1D), csr) = dense</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_binary_broadcast_op_basic.cc:L106</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input to the function</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input to the function</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.broadcast_to">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">broadcast_to</code><span class="sig-paren">(</span><em>data=None</em>, <em>shape=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.broadcast_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcasts the input array to a new shape.</p>
<p>Broadcasting is a mechanism that allows NDArrays to perform arithmetic operations
with arrays of different shapes efficiently without creating multiple copies of arrays.
Also see, <a class="reference external" href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">Broadcasting</a> for more explanation.</p>
<p>Broadcasting is allowed on axes with size 1, such as from <cite>(2,1,3,1)</cite> to
<cite>(2,8,3,9)</cite>. Elements will be duplicated on the broadcasted axes.</p>
<p>For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">broadcast_to</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
                                        <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">]])</span>
</pre></div>
</div>
<p>The dimension which you do not want to change can also be kept as <cite>0</cite> which means copy the original value.
So with <cite>shape=(2,0)</cite>, we will obtain the same result as in the above example.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L262</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – The shape of the desired array. We can set the dim to zero if it’s same as the original. E.g <cite>A = broadcast_to(B, shape=(10, 0, 0))</cite> has the same meaning as <cite>A = broadcast_axis(B, axis=0, size=10)</cite>.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.cast">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">cast</code><span class="sig-paren">(</span><em>data=None</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Casts all elements of the input to a new type.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">Cast</span></code> is deprecated. Use <code class="docutils literal"><span class="pre">cast</span></code> instead.</p>
</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cast</span><span class="p">([</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'int32'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">cast</span><span class="p">([</span><span class="mf">1e20</span><span class="p">,</span> <span class="mf">11.1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'float16'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">inf</span><span class="p">,</span> <span class="mf">11.09375</span><span class="p">]</span>
<span class="n">cast</span><span class="p">([</span><span class="mi">300</span><span class="p">,</span> <span class="mf">11.1</span><span class="p">,</span> <span class="mf">10.9</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'uint8'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">44</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">253</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L634</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input.</li>
<li><strong>dtype</strong> (<em>{'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'</em><em>, </em><em>'int32'</em><em>, </em><em>'int64'</em><em>, </em><em>'int8'</em><em>, </em><em>'uint8'}</em><em>, </em><em>required</em>) – Output data type.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.cast_storage">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">cast_storage</code><span class="sig-paren">(</span><em>data=None</em>, <em>stype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.cast_storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Casts tensor storage type to the new type.</p>
<p>When an NDArray with default storage type is cast to csr or row_sparse storage,
the result is compact, which means:</p>
<ul class="simple">
<li>for csr, zero values will not be retained</li>
<li>for row_sparse, row slices of all zeros will not be retained</li>
</ul>
<p>The storage type of <code class="docutils literal"><span class="pre">cast_storage</span></code> output depends on stype parameter:</p>
<ul class="simple">
<li>cast_storage(csr, ‘default’) = default</li>
<li>cast_storage(row_sparse, ‘default’) = default</li>
<li>cast_storage(default, ‘csr’) = csr</li>
<li>cast_storage(default, ‘row_sparse’) = row_sparse</li>
<li>cast_storage(csr, ‘csr’) = csr</li>
<li>cast_storage(row_sparse, ‘row_sparse’) = row_sparse</li>
</ul>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">dense</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
         <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
         <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
         <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>

<span class="c1"># cast to row_sparse storage type</span>
<span class="n">rsp</span> <span class="o">=</span> <span class="n">cast_storage</span><span class="p">(</span><span class="n">dense</span><span class="p">,</span> <span class="s1">'row_sparse'</span><span class="p">)</span>
<span class="n">rsp</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">rsp</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
              <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">]]</span>

<span class="c1"># cast to csr storage type</span>
<span class="n">csr</span> <span class="o">=</span> <span class="n">cast_storage</span><span class="p">(</span><span class="n">dense</span><span class="p">,</span> <span class="s1">'csr'</span><span class="p">)</span>
<span class="n">csr</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">csr</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">]</span>
<span class="n">csr</span><span class="o">.</span><span class="n">indptr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/cast_storage.cc:L71</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input.</li>
<li><strong>stype</strong> (<em>{'csr'</em><em>, </em><em>'default'</em><em>, </em><em>'row_sparse'}</em><em>, </em><em>required</em>) – Output storage type.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.cbrt">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">cbrt</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.cbrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise cube-root value of the input.</p>
<div class="math">
\[cbrt(x) = \sqrt[3]{x}\]</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cbrt</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">125</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">cbrt</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>cbrt(default) = default</li>
<li>cbrt(row_sparse) = row_sparse</li>
<li>cbrt(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L950</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.ceil">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">ceil</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise ceiling of the input.</p>
<p>The ceil of the scalar x is the smallest integer i, such that i >= x.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ceil</span><span class="p">([</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">]</span>
</pre></div>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">ceil</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>ceil(default) = default</li>
<li>ceil(row_sparse) = row_sparse</li>
<li>ceil(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L786</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.choose_element_0index">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">choose_element_0index</code><span class="sig-paren">(</span><em>data=None</em>, <em>index=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>mode=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.choose_element_0index" title="Permalink to this definition">¶</a></dt>
<dd><p>Picks elements from an input array according to the input indices along the given axis.</p>
<p>Given an input array of shape <code class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1)</span></code> and indices of shape <code class="docutils literal"><span class="pre">(i0,)</span></code>, the result will be
an output array of shape <code class="docutils literal"><span class="pre">(i0,)</span></code> with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
</pre></div>
</div>
<p>By default, if any index mentioned is too large, it is replaced by the index that addresses
the last element along an axis (the <cite>clip</cite> mode).</p>
<p>This function supports n-dimensional input and (n-1)-dimensional indices arrays.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">picks</span> <span class="n">elements</span> <span class="k">with</span> <span class="n">specified</span> <span class="n">indices</span> <span class="n">along</span> <span class="n">axis</span> <span class="mi">0</span>
<span class="n">pick</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]</span>

<span class="o">//</span> <span class="n">picks</span> <span class="n">elements</span> <span class="k">with</span> <span class="n">specified</span> <span class="n">indices</span> <span class="n">along</span> <span class="n">axis</span> <span class="mi">1</span>
<span class="n">pick</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">2.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">picks</span> <span class="n">elements</span> <span class="k">with</span> <span class="n">specified</span> <span class="n">indices</span> <span class="n">along</span> <span class="n">axis</span> <span class="mi">1</span> <span class="n">using</span> <span class="s1">'wrap'</span> <span class="n">mode</span>
<span class="o">//</span> <span class="n">to</span> <span class="n">place</span> <span class="n">indicies</span> <span class="n">that</span> <span class="n">would</span> <span class="n">normally</span> <span class="n">be</span> <span class="n">out</span> <span class="n">of</span> <span class="n">bounds</span>
<span class="n">pick</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'wrap'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">2.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">picks</span> <span class="n">elements</span> <span class="k">with</span> <span class="n">specified</span> <span class="n">indices</span> <span class="n">along</span> <span class="n">axis</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">dims</span> <span class="n">are</span> <span class="n">maintained</span>
<span class="n">pick</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">],</span>
                               <span class="p">[</span> <span class="mf">3.</span><span class="p">],</span>
                               <span class="p">[</span> <span class="mf">6.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L154</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array</li>
<li><strong>index</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The index array</li>
<li><strong>axis</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default='-1'</em>) – int or None. The axis to picking the elements. Negative values means indexing from right to left. If is <cite>None</cite>, the elements in the index w.r.t the flattened input will be picked.</li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If true, the axis where we pick the elements is left in the result as dimension with size one.</li>
<li><strong>mode</strong> (<em>{'clip'</em><em>, </em><em>'wrap'}</em><em>,</em><em>optional</em><em>, </em><em>default='clip'</em>) – Specify how out-of-bound indices behave. Default is “clip”. “clip” means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  “wrap” means to wrap around.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.clip">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">clip</code><span class="sig-paren">(</span><em>data=None</em>, <em>a_min=_Null</em>, <em>a_max=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Clips (limits) the values in an array.</p>
<p>Given an interval, values outside the interval are clipped to the interval edges.
Clipping <code class="docutils literal"><span class="pre">x</span></code> between <cite>a_min</cite> and <cite>a_x</cite> would be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">clip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a_min</span><span class="p">,</span> <span class="n">a_max</span><span class="p">)</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a_max</span><span class="p">),</span> <span class="n">a_min</span><span class="p">))</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>

<span class="n">clip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]</span>
</pre></div>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">clip</span></code> output depends on storage types of inputs and the a_min, a_max parameter values:</p>
<blockquote>
<div><ul class="simple">
<li>clip(default) = default</li>
<li>clip(row_sparse, a_min <= 0, a_max >= 0) = row_sparse</li>
<li>clip(csr, a_min <= 0, a_max >= 0) = csr</li>
<li>clip(row_sparse, a_min < 0, a_max < 0) = default</li>
<li>clip(row_sparse, a_min > 0, a_max > 0) = default</li>
<li>clip(csr, a_min < 0, a_max < 0) = csr</li>
<li>clip(csr, a_min > 0, a_max > 0) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/matrix_op.cc:L723</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input array.</li>
<li><strong>a_min</strong> (<em>float</em><em>, </em><em>required</em>) – Minimum value</li>
<li><strong>a_max</strong> (<em>float</em><em>, </em><em>required</em>) – Maximum value</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.concat">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">concat</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Joins input arrays along a given axis.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>Concat</cite> is deprecated. Use <cite>concat</cite> instead.</p>
</div>
<p>The dimensions of the input arrays should be the same except the axis along
which they will be concatenated.
The dimension of the output array along the concatenated axis will be equal
to the sum of the corresponding dimensions of the input arrays.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">concat</span></code> output depends on storage types of inputs</p>
<ul class="simple">
<li>concat(csr, csr, ..., csr, dim=0) = csr</li>
<li>otherwise, <code class="docutils literal"><span class="pre">concat</span></code> generates output with default storage</li>
</ul>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">]]</span>

<span class="n">concat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">6.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">7.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">8.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]</span>

<span class="n">Note</span> <span class="n">that</span> <span class="n">you</span> <span class="n">cannot</span> <span class="n">concat</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="n">along</span> <span class="n">dimension</span> <span class="mi">1</span> <span class="n">since</span> <span class="n">dimension</span>
<span class="mi">0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">the</span> <span class="n">same</span> <span class="k">for</span> <span class="nb">all</span> <span class="n">the</span> <span class="nb">input</span> <span class="n">arrays</span><span class="o">.</span>

<span class="n">concat</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/nn/concat.cc:L371</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>[</em><em>]</em>) – List of arrays to concatenate</li>
<li><strong>dim</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='1'</em>) – the dimension to be concated.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.cos">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">cos</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the element-wise cosine of the input array.</p>
<p>The input should be in radians (<span class="math">\(2\pi\)</span> rad equals 360 degrees).</p>
<div class="math">
\[cos([0, \pi/4, \pi/2]) = [1, 0.707, 0]\]</div>
<p>The storage type of <code class="docutils literal"><span class="pre">cos</span></code> output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L89</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.cosh">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">cosh</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.cosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the hyperbolic cosine  of the input array, computed element-wise.</p>
<div class="math">
\[cosh(x) = 0.5\times(exp(x) + exp(-x))\]</div>
<p>The storage type of <code class="docutils literal"><span class="pre">cosh</span></code> output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L272</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.crop">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">crop</code><span class="sig-paren">(</span><em>data=None</em>, <em>begin=_Null</em>, <em>end=_Null</em>, <em>step=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Slices a region of the array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">crop</span></code> is deprecated. Use <code class="docutils literal"><span class="pre">slice</span></code> instead.</p>
</div>
<p>This function returns a sliced array between the indices given
by <cite>begin</cite> and <cite>end</cite> with the corresponding <cite>step</cite>.</p>
<p>For an input array of <code class="docutils literal"><span class="pre">shape=(d_0,</span> <span class="pre">d_1,</span> <span class="pre">...,</span> <span class="pre">d_n-1)</span></code>,
slice operation with <code class="docutils literal"><span class="pre">begin=(b_0,</span> <span class="pre">b_1...b_m-1)</span></code>,
<code class="docutils literal"><span class="pre">end=(e_0,</span> <span class="pre">e_1,</span> <span class="pre">...,</span> <span class="pre">e_m-1)</span></code>, and <code class="docutils literal"><span class="pre">step=(s_0,</span> <span class="pre">s_1,</span> <span class="pre">...,</span> <span class="pre">s_m-1)</span></code>,
where m <= n, results in an array with the shape
<code class="docutils literal"><span class="pre">(|e_0-b_0|/|s_0|,</span> <span class="pre">...,</span> <span class="pre">|e_m-1-b_m-1|/|s_m-1|,</span> <span class="pre">d_m,</span> <span class="pre">...,</span> <span class="pre">d_n-1)</span></code>.</p>
<p>The resulting array’s <em>k</em>-th dimension contains elements
from the <em>k</em>-th dimension of the input array starting
from index <code class="docutils literal"><span class="pre">b_k</span></code> (inclusive) with step <code class="docutils literal"><span class="pre">s_k</span></code>
until reaching <code class="docutils literal"><span class="pre">e_k</span></code> (exclusive).</p>
<p>If the <em>k</em>-th elements are <cite>None</cite> in the sequence of <cite>begin</cite>, <cite>end</cite>,
and <cite>step</cite>, the following rule will be used to set default values.
If <cite>s_k</cite> is <cite>None</cite>, set <cite>s_k=1</cite>. If <cite>s_k > 0</cite>, set <cite>b_k=0</cite>, <cite>e_k=d_k</cite>;
else, set <cite>b_k=d_k-1</cite>, <cite>e_k=-1</cite>.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">slice</span></code> output depends on storage types of inputs</p>
<ul class="simple">
<li>slice(csr) = csr</li>
<li>otherwise, <code class="docutils literal"><span class="pre">slice</span></code> generates output with default storage</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When input data storage type is csr, it only supports
step=(), or step=(None,), or step=(1,) to generate a csr output.
For other step parameter values, it falls back to slicing
a dense tensor.</p>
</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">,</span>   <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">,</span>   <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">9.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]]</span>

<span class="nb">slice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                                   <span class="p">[</span> <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]</span>
<span class="nb">slice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">step</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">9.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">],</span>
                                                          <span class="p">[</span><span class="mf">5.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">],</span>
                                                          <span class="p">[</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L506</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Source input</li>
<li><strong>begin</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>required</em>) – starting indices for the slice operation, supports negative indices.</li>
<li><strong>end</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>required</em>) – ending indices for the slice operation, supports negative indices.</li>
<li><strong>step</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – step for the slice operation, supports negative values.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.ctc_loss">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">ctc_loss</code><span class="sig-paren">(</span><em>data=None</em>, <em>label=None</em>, <em>data_lengths=None</em>, <em>label_lengths=None</em>, <em>use_data_lengths=_Null</em>, <em>use_label_lengths=_Null</em>, <em>blank_label=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.ctc_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Connectionist Temporal Classification Loss.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The existing alias <code class="docutils literal"><span class="pre">contrib_CTCLoss</span></code> is deprecated.</p>
</div>
<p>The shapes of the inputs and outputs:</p>
<ul class="simple">
<li><strong>data</strong>: <cite>(sequence_length, batch_size, alphabet_size)</cite></li>
<li><strong>label</strong>: <cite>(batch_size, label_sequence_length)</cite></li>
<li><strong>out</strong>: <cite>(batch_size)</cite></li>
</ul>
<p>The <cite>data</cite> tensor consists of sequences of activation vectors (without applying softmax),
with i-th channel in the last dimension corresponding to i-th label
for i between 0 and alphabet_size-1 (i.e always 0-indexed).
Alphabet size should include one additional value reserved for blank label.
When <cite>blank_label</cite> is <code class="docutils literal"><span class="pre">"first"</span></code>, the <code class="docutils literal"><span class="pre">0</span></code>-th channel is be reserved for
activation of blank label, or otherwise if it is “last”, <code class="docutils literal"><span class="pre">(alphabet_size-1)</span></code>-th channel should be
reserved for blank label.</p>
<p><code class="docutils literal"><span class="pre">label</span></code> is an index matrix of integers. When <cite>blank_label</cite> is <code class="docutils literal"><span class="pre">"first"</span></code>,
the value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,
when <cite>blank_label</cite> is <code class="docutils literal"><span class="pre">"last"</span></code>, the value <cite>(alphabet_size-1)</cite> is reserved for blank label.</p>
<p>If a sequence of labels is shorter than <em>label_sequence_length</em>, use the special
padding value at the end of the sequence to conform it to the correct
length. The padding value is <cite>0</cite> when <cite>blank_label</cite> is <code class="docutils literal"><span class="pre">"first"</span></code>, and <cite>-1</cite> otherwise.</p>
<p>For example, suppose the vocabulary is <cite>[a, b, c]</cite>, and in one batch we have three sequences
‘ba’, ‘cbb’, and ‘abac’. When <cite>blank_label</cite> is <code class="docutils literal"><span class="pre">"first"</span></code>, we can index the labels as
<cite>{‘a’: 1, ‘b’: 2, ‘c’: 3}</cite>, and we reserve the 0-th channel for blank label in data tensor.
The resulting <cite>label</cite> tensor should be padded to be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
</pre></div>
</div>
<p>When <cite>blank_label</cite> is <code class="docutils literal"><span class="pre">"last"</span></code>, we can index the labels as
<cite>{‘a’: 0, ‘b’: 1, ‘c’: 2}</cite>, and we reserve the channel index 3 for blank label in data tensor.
The resulting <cite>label</cite> tensor should be padded to be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">out</span></code> is a list of CTC loss values, one per example in the batch.</p>
<p>See <em>Connectionist Temporal Classification: Labelling Unsegmented
Sequence Data with Recurrent Neural Networks</em>, A. Graves <em>et al</em>. for more
information on the definition and the algorithm.</p>
<p>Defined in src/operator/nn/ctc_loss.cc:L100</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input ndarray</li>
<li><strong>label</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Ground-truth labels for the loss.</li>
<li><strong>data_lengths</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Lengths of data for each of the samples. Only required when use_data_lengths is true.</li>
<li><strong>label_lengths</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Lengths of labels for each of the samples. Only required when use_label_lengths is true.</li>
<li><strong>use_data_lengths</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether the data lenghts are decided by <cite>data_lengths</cite>. If false, the lengths are equal to the max sequence length.</li>
<li><strong>use_label_lengths</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether the label lenghts are decided by <cite>label_lengths</cite>, or derived from <cite>padding_mask</cite>. If false, the lengths are derived from the first occurrence of the value of <cite>padding_mask</cite>. The value of <cite>padding_mask</cite> is <code class="docutils literal"><span class="pre">0</span></code> when first CTC label is reserved for blank, and <code class="docutils literal"><span class="pre">-1</span></code> when last label is reserved for blank. See <cite>blank_label</cite>.</li>
<li><strong>blank_label</strong> (<em>{'first'</em><em>, </em><em>'last'}</em><em>,</em><em>optional</em><em>, </em><em>default='first'</em>) – Set the label that is reserved for blank label.If “first”, 0-th label is reserved, and label values for tokens in the vocabulary are between <code class="docutils literal"><span class="pre">1</span></code> and <code class="docutils literal"><span class="pre">alphabet_size-1</span></code>, and the padding mask is <code class="docutils literal"><span class="pre">-1</span></code>. If “last”, last label value <code class="docutils literal"><span class="pre">alphabet_size-1</span></code> is reserved for blank label instead, and label values for tokens in the vocabulary are between <code class="docutils literal"><span class="pre">0</span></code> and <code class="docutils literal"><span class="pre">alphabet_size-2</span></code>, and the padding mask is <code class="docutils literal"><span class="pre">0</span></code>.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.degrees">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">degrees</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.degrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts each element of the input array from radians to degrees.</p>
<div class="math">
\[degrees([0, \pi/2, \pi, 3\pi/2, 2\pi]) = [0, 90, 180, 270, 360]\]</div>
<p>The storage type of <code class="docutils literal"><span class="pre">degrees</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>degrees(default) = default</li>
<li>degrees(row_sparse) = row_sparse</li>
<li>degrees(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L219</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.depth_to_space">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">depth_to_space</code><span class="sig-paren">(</span><em>data=None</em>, <em>block_size=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.depth_to_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Rearranges(permutes) data from depth into blocks of spatial data.
Similar to ONNX DepthToSpace operator:
<a class="reference external" href="https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace">https://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace</a>.
The output is a new tensor where the values from depth dimension are moved in spatial blocks
to height and width dimension. The reverse of this operation is <code class="docutils literal"><span class="pre">space_to_depth</span></code>.</p>
<div class="math">
\[\begin{split}\begin{gather*}
x \prime = reshape(x, [N, block\_size, block\_size, C / (block\_size ^ 2), H * block\_size, W * block\_size]) \\
x \prime \prime = transpose(x \prime, [0, 3, 4, 1, 5, 2]) \\
y = reshape(x \prime \prime, [N, C / (block\_size ^ 2), H * block\_size, W * block\_size])
\end{gather*}\end{split}\]</div>
<p>where <span class="math">\(x\)</span> is an input tensor with default layout as <span class="math">\([N, C, H, W]\)</span>: [batch, channels, height, width]
and <span class="math">\(y\)</span> is the output tensor of layout <span class="math">\([N, C / (block\_size ^ 2), H * block\_size, W * block\_size]\)</span></p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span>
      <span class="p">[[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]],</span>
      <span class="p">[[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">]],</span>
      <span class="p">[[</span><span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">]]]]</span>

<span class="n">depth_to_space</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">23</span><span class="p">]]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L1050</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input ndarray</li>
<li><strong>block_size</strong> (<em>int</em><em>, </em><em>required</em>) – Blocks of [block_size. block_size] are moved</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.diag">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">diag</code><span class="sig-paren">(</span><em>data=None</em>, <em>k=_Null</em>, <em>axis1=_Null</em>, <em>axis2=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts a diagonal or constructs a diagonal array.</p>
<p><code class="docutils literal"><span class="pre">diag</span></code>‘s behavior depends on the input array dimensions:</p>
<ul>
<li><p class="first">1-D arrays: constructs a 2-D array with the input as its diagonal, all other elements are zero.</p>
</li>
<li><p class="first">N-D arrays: extracts the diagonals of the sub-arrays with axes specified by <code class="docutils literal"><span class="pre">axis1</span></code> and <code class="docutils literal"><span class="pre">axis2</span></code>.
The output shape would be decided by removing the axes numbered <code class="docutils literal"><span class="pre">axis1</span></code> and <code class="docutils literal"><span class="pre">axis2</span></code> from the
input shape and appending to the result a new axis with the size of the diagonals in question.</p>
<p>For example, when the input shape is <cite>(2, 3, 4, 5)</cite>, <code class="docutils literal"><span class="pre">axis1</span></code> and <code class="docutils literal"><span class="pre">axis2</span></code> are 0 and 2
respectively and <code class="docutils literal"><span class="pre">k</span></code> is 0, the resulting shape would be <cite>(3, 5, 2)</cite>.</p>
</li>
</ul>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]</span>

<span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>

<span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>

<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>

<span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

<span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                 <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                 <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

<span class="n">x</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>

     <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]]</span>

<span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
           <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">4</span><span class="p">]]</span>

<span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
                               <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/diag_op.cc:L87</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input ndarray</li>
<li><strong>k</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='0'</em>) – Diagonal in question. The default is 0. Use k>0 for diagonals above the main diagonal, and k<0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1</li>
<li><strong>axis1</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='0'</em>) – The first axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</li>
<li><strong>axis2</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='1'</em>) – The second axis of the sub-arrays of interest. Ignored when the input is a 1-D array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.dot">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">dot</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>transpose_a=_Null</em>, <em>transpose_b=_Null</em>, <em>forward_stype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product of two arrays.</p>
<p><code class="docutils literal"><span class="pre">dot</span></code>‘s behavior depends on the input array dimensions:</p>
<ul>
<li><p class="first">1-D arrays: inner product of vectors</p>
</li>
<li><p class="first">2-D arrays: matrix multiplication</p>
</li>
<li><p class="first">N-D arrays: a sum product over the last axis of the first input and the first
axis of the second input</p>
<p>For example, given 3-D <code class="docutils literal"><span class="pre">x</span></code> with shape <cite>(n,m,k)</cite> and <code class="docutils literal"><span class="pre">y</span></code> with shape <cite>(k,r,s)</cite>, the
result array will have shape <cite>(n,m,r,s)</cite>. It is computed by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span><span class="o">*</span><span class="n">y</span><span class="p">[:,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">])</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="n">y</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
</li>
</ul>
<p>The storage type of <code class="docutils literal"><span class="pre">dot</span></code> output depends on storage types of inputs, transpose option and
forward_stype option for output storage type. Implemented sparse operations include:</p>
<ul class="simple">
<li>dot(default, default, transpose_a=True/False, transpose_b=True/False) = default</li>
<li>dot(csr, default, transpose_a=True) = default</li>
<li>dot(csr, default, transpose_a=True) = row_sparse</li>
<li>dot(csr, default) = default</li>
<li>dot(csr, row_sparse) = default</li>
<li>dot(default, csr) = csr (CPU only)</li>
<li>dot(default, csr, forward_stype=’default’) = default</li>
<li>dot(default, csr, transpose_b=True, forward_stype=’default’) = default</li>
</ul>
<p>If the combination of input storage types and forward_stype does not match any of the
above patterns, <code class="docutils literal"><span class="pre">dot</span></code> will fallback and generate output with default storage.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the storage type of the lhs is “csr”, the storage type of gradient w.r.t rhs will be
“row_sparse”. Only a subset of optimizers support sparse gradients, including SGD, AdaGrad
and Adam. Note that by default lazy updates is turned on, which may perform differently
from standard updates. For more details, please check the Optimization API at:
<a class="reference external" href="/api/python/optimization/optimization.html">/api/python/optimization/optimization.html</a></p>
</div>
<p>Defined in src/operator/tensor/dot.cc:L77</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The first input</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The second input</li>
<li><strong>transpose_a</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If true then transpose the first input before dot.</li>
<li><strong>transpose_b</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If true then transpose the second input before dot.</li>
<li><strong>forward_stype</strong> (<em>{None</em><em>, </em><em>'csr'</em><em>, </em><em>'default'</em><em>, </em><em>'row_sparse'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.elemwise_add">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">elemwise_add</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.elemwise_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds arguments element-wise.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">elemwise_add</span></code> output depends on storage types of inputs</p>
<blockquote>
<div><ul class="simple">
<li>elemwise_add(row_sparse, row_sparse) = row_sparse</li>
<li>elemwise_add(csr, csr) = csr</li>
<li>elemwise_add(default, csr) = default</li>
<li>elemwise_add(csr, default) = default</li>
<li>elemwise_add(default, rsp) = default</li>
<li>elemwise_add(rsp, default) = default</li>
<li>otherwise, <code class="docutils literal"><span class="pre">elemwise_add</span></code> generates output with default storage</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – first input</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – second input</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">3.1</span><span class="p">,</span> <span class="mf">4.1</span><span class="p">])</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">elemwise_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 2.0999999 ,  4.0999999 ,  6.0999999 ,  8.10000038], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.elemwise_div">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">elemwise_div</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.elemwise_div" title="Permalink to this definition">¶</a></dt>
<dd><p>Divides arguments element-wise.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">elemwise_div</span></code> output is always dense</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – first input</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – second input</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.elemwise_mul">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">elemwise_mul</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.elemwise_mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplies arguments element-wise.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">elemwise_mul</span></code> output depends on storage types of inputs</p>
<blockquote>
<div><ul class="simple">
<li>elemwise_mul(default, default) = default</li>
<li>elemwise_mul(row_sparse, row_sparse) = row_sparse</li>
<li>elemwise_mul(default, row_sparse) = row_sparse</li>
<li>elemwise_mul(row_sparse, default) = row_sparse</li>
<li>elemwise_mul(csr, csr) = csr</li>
<li>otherwise, <code class="docutils literal"><span class="pre">elemwise_mul</span></code> generates output with default storage</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – first input</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – second input</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.elemwise_sub">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">elemwise_sub</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.elemwise_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts arguments element-wise.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">elemwise_sub</span></code> output depends on storage types of inputs</p>
<blockquote>
<div><ul class="simple">
<li>elemwise_sub(row_sparse, row_sparse) = row_sparse</li>
<li>elemwise_sub(csr, csr) = csr</li>
<li>elemwise_sub(default, csr) = default</li>
<li>elemwise_sub(csr, default) = default</li>
<li>elemwise_sub(default, rsp) = default</li>
<li>elemwise_sub(rsp, default) = default</li>
<li>otherwise, <code class="docutils literal"><span class="pre">elemwise_sub</span></code> generates output with default storage</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – first input</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – second input</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.erf">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">erf</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.erf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise gauss error function of the input.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">erf</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8427</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L964</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.erfinv">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">erfinv</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.erfinv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise inverse gauss error function of the input.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">erfinv</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.4769</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L985</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.exp">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">exp</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise exponential value of the input.</p>
<div class="math">
\[exp(x) = e^x \approx 2.718^x\]</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">exp</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.71828175</span><span class="p">,</span> <span class="mf">7.38905621</span><span class="p">]</span>
</pre></div>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">exp</span></code> output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L1044</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.expand_dims">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">expand_dims</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.expand_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts a new axis of size 1 into the array shape</p>
<p>For example, given <code class="docutils literal"><span class="pre">x</span></code> with shape <code class="docutils literal"><span class="pre">(2,3,4)</span></code>, then <code class="docutils literal"><span class="pre">expand_dims(x,</span> <span class="pre">axis=1)</span></code>
will return a new array with shape <code class="docutils literal"><span class="pre">(2,1,3,4)</span></code>.</p>
<p>Defined in src/operator/tensor/matrix_op.cc:L416</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Source input</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>required</em>) – Position where new axis is to be inserted. Suppose that the input <cite>NDArray</cite>‘s dimension is <cite>ndim</cite>, the range of the inserted axis is <cite>[-ndim, ndim]</cite></li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.expm1">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">expm1</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.expm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code> computed element-wise on the input.</p>
<p>This function provides greater precision than <code class="docutils literal"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code> for small values of <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">expm1</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>expm1(default) = default</li>
<li>expm1(row_sparse) = row_sparse</li>
<li>expm1(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L1189</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.fill_element_0index">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">fill_element_0index</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>mhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.fill_element_0index" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function assume rhs uses 0-based index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Left operand to the function.</li>
<li><strong>mhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Middle operand to the function.</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Right operand to the function.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.fix">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">fix</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.fix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise rounded value to the nearest integer towards zero of the input.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fix</span><span class="p">([</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]</span>
</pre></div>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">fix</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>fix(default) = default</li>
<li>fix(row_sparse) = row_sparse</li>
<li>fix(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L843</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.flatten">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">flatten</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Flattens the input array into a 2-D array by collapsing the higher dimensions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>Flatten</cite> is deprecated. Use <cite>flatten</cite> instead.</p>
</div>
<p>For an input array with shape <code class="docutils literal"><span class="pre">(d1,</span> <span class="pre">d2,</span> <span class="pre">...,</span> <span class="pre">dk)</span></code>, <cite>flatten</cite> operation reshapes
the input array into an output array of shape <code class="docutils literal"><span class="pre">(d1,</span> <span class="pre">d2*...*dk)</span></code>.</p>
<p>Note that the bahavior of this function is different from numpy.ndarray.flatten,
which behaves similar to mxnet.ndarray.reshape((-1,)).</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="p">],</span>
<span class="p">[</span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="p">]],</span>

<span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">],</span>
   <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L291</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.flip">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">flip</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverses the order of elements along given axis while preserving array shape.</p>
<p>Note: reverse and flip are equivalent. We use reverse in the following examples.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">]]</span>

<span class="n">reverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>

<span class="n">reverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">9.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L898</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data array</li>
<li><strong>axis</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>required</em>) – The axis which to reverse elements.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.floor">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">floor</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise floor of the input.</p>
<p>The floor of the scalar x is the largest integer i, such that i <= x.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">floor</span><span class="p">([</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]</span>
</pre></div>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">floor</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>floor(default) = default</li>
<li>floor(row_sparse) = row_sparse</li>
<li>floor(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L805</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.ftml_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">ftml_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>d=None</em>, <em>v=None</em>, <em>z=None</em>, <em>lr=_Null</em>, <em>beta1=_Null</em>, <em>beta2=_Null</em>, <em>epsilon=_Null</em>, <em>t=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_grad=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.ftml_update" title="Permalink to this definition">¶</a></dt>
<dd><p>The FTML optimizer described in
<em>FTML - Follow the Moving Leader in Deep Learning</em>,
available at <a class="reference external" href="http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf">http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf</a>.</p>
<div class="math">
\[\begin{split}g_t = \nabla J(W_{t-1})\\
v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\
d_t = \frac{ 1 - \beta_1^t }{ \eta_t } (\sqrt{ \frac{ v_t }{ 1 - \beta_2^t } } + \epsilon)
\sigma_t = d_t - \beta_1 d_{t-1}
z_t = \beta_1 z_{ t-1 } + (1 - \beta_1^t) g_t - \sigma_t W_{t-1}
W_t = - \frac{ z_t }{ d_t }\end{split}\]</div>
<p>Defined in src/operator/optimizer_op.cc:L638</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Gradient</li>
<li><strong>d</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Internal state <code class="docutils literal"><span class="pre">d_t</span></code></li>
<li><strong>v</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Internal state <code class="docutils literal"><span class="pre">v_t</span></code></li>
<li><strong>z</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Internal state <code class="docutils literal"><span class="pre">z_t</span></code></li>
<li><strong>lr</strong> (<em>float</em><em>, </em><em>required</em>) – Learning rate.</li>
<li><strong>beta1</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.600000024</em>) – Generally close to 0.5.</li>
<li><strong>beta2</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.999000013</em>) – Generally close to 1.</li>
<li><strong>epsilon</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=9.9999999392252903e-09</em>) – Epsilon to prevent div 0.</li>
<li><strong>t</strong> (<em>int</em><em>, </em><em>required</em>) – Number of update.</li>
<li><strong>wd</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.ftrl_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">ftrl_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>z=None</em>, <em>n=None</em>, <em>lr=_Null</em>, <em>lamda1=_Null</em>, <em>beta=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.ftrl_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update function for Ftrl optimizer.
Referenced from <em>Ad Click Prediction: a View from the Trenches</em>, available at
<a class="reference external" href="http://dl.acm.org/citation.cfm?id=2488200">http://dl.acm.org/citation.cfm?id=2488200</a>.</p>
<p>It updates the weights using:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">rescaled_grad</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">grad</span> <span class="o">*</span> <span class="n">rescale_grad</span><span class="p">,</span> <span class="n">clip_gradient</span><span class="p">)</span>
<span class="n">z</span> <span class="o">+=</span> <span class="n">rescaled_grad</span> <span class="o">-</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">rescaled_grad</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">learning_rate</span>
<span class="n">n</span> <span class="o">+=</span> <span class="n">rescaled_grad</span><span class="o">**</span><span class="mi">2</span>
<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="n">lamda1</span> <span class="o">-</span> <span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">beta</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">/</span> <span class="n">learning_rate</span> <span class="o">+</span> <span class="n">wd</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">></span> <span class="n">lamda1</span><span class="p">)</span>
</pre></div>
</div>
<p>If w, z and n are all of <code class="docutils literal"><span class="pre">row_sparse</span></code> storage type,
only the row slices whose indices appear in grad.indices are updated (for w, z and n):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">grad</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="n">rescaled_grad</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">grad</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">*</span> <span class="n">rescale_grad</span><span class="p">,</span> <span class="n">clip_gradient</span><span class="p">)</span>
    <span class="n">z</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rescaled_grad</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">+</span> <span class="n">rescaled_grad</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">row</span><span class="p">]))</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">/</span> <span class="n">learning_rate</span>
    <span class="n">n</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rescaled_grad</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">w</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">row</span><span class="p">])</span> <span class="o">*</span> <span class="n">lamda1</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="n">row</span><span class="p">])</span> <span class="o">/</span> <span class="p">((</span><span class="n">beta</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">row</span><span class="p">]))</span> <span class="o">/</span> <span class="n">learning_rate</span> <span class="o">+</span> <span class="n">wd</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">row</span><span class="p">])</span> <span class="o">></span> <span class="n">lamda1</span><span class="p">)</span>
</pre></div>
</div>
<p>Defined in src/operator/optimizer_op.cc:L874</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Gradient</li>
<li><strong>z</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – z</li>
<li><strong>n</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Square of grad</li>
<li><strong>lr</strong> (<em>float</em><em>, </em><em>required</em>) – Learning rate</li>
<li><strong>lamda1</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.00999999978</em>) – The L1 regularization coefficient.</li>
<li><strong>beta</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Per-Coordinate Learning Rate beta.</li>
<li><strong>wd</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.gamma">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">gamma</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the gamma function (extension of the factorial function to the reals), computed element-wise on the input array.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">gamma</span></code> output is always dense</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.gammaln">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">gammaln</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.gammaln" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise log of the absolute value of the gamma function of the input.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">gammaln</span></code> output is always dense</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.gather_nd">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">gather_nd</code><span class="sig-paren">(</span><em>data=None</em>, <em>indices=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.gather_nd" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather elements or slices from <cite>data</cite> and store to a tensor whose
shape is defined by <cite>indices</cite>.</p>
<p>Given <cite>data</cite> with shape <cite>(X_0, X_1, ..., X_{N-1})</cite> and indices with shape
<cite>(M, Y_0, ..., Y_{K-1})</cite>, the output will have shape <cite>(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})</cite>,
where <cite>M <= N</cite>. If <cite>M == N</cite>, output shape will simply be <cite>(Y_0, ..., Y_{K-1})</cite>.</p>
<p>The elements in output is defined as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">output</span><span class="p">[</span><span class="n">y_0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">y_</span><span class="p">{</span><span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="n">x_M</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">x_</span><span class="p">{</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">}]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">y_</span><span class="p">{</span><span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">}],</span>
                                                    <span class="o">...</span><span class="p">,</span>
                                                    <span class="n">indices</span><span class="p">[</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y_0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">y_</span><span class="p">{</span><span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">}],</span>
                                                    <span class="n">x_M</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">x_</span><span class="p">{</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">}]</span>
</pre></div>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="n">indices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="n">gather_nd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="n">data</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]]</span>
<span class="n">indices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="n">gather_nd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – data</li>
<li><strong>indices</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – indices</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.hard_sigmoid">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">hard_sigmoid</code><span class="sig-paren">(</span><em>data=None</em>, <em>alpha=_Null</em>, <em>beta=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.hard_sigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes hard sigmoid of x element-wise.</p>
<div class="math">
\[y = max(0, min(1, alpha * x + beta))\]</div>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L133</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>alpha</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.200000003</em>) – Slope of hard sigmoid</li>
<li><strong>beta</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.5</em>) – Bias of hard sigmoid.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.identity">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">identity</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the input.</p>
<p>From:src/operator/tensor/elemwise_unary_op_basic.cc:218</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.khatri_rao">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">khatri_rao</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.khatri_rao" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Khatri-Rao product of the input matrices.</p>
<p>Given a collection of <span class="math">\(n\)</span> input matrices,</p>
<div class="math">
\[A_1 \in \mathbb{R}^{M_1 \times M}, \ldots, A_n \in \mathbb{R}^{M_n \times N},\]</div>
<p>the (column-wise) Khatri-Rao product is defined as the matrix,</p>
<div class="math">
\[X = A_1 \otimes \cdots \otimes A_n \in \mathbb{R}^{(M_1 \cdots M_n) \times N},\]</div>
<p>where the <span class="math">\(k\)</span> th column is equal to the column-wise outer product
<span class="math">\({A_1}_k \otimes \cdots \otimes {A_n}_k\)</span> where <span class="math">\({A_i}_k\)</span> is the kth
column of the ith matrix.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">A</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">>>> </span>                 <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">>>> </span><span class="n">B</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">>>> </span>                 <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">>>> </span>                 <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">>>> </span><span class="n">C</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">khatri_rao</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">>>> </span><span class="nb">print</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
<span class="go">[[  1.  -4.]</span>
<span class="go"> [  2.  -5.]</span>
<span class="go"> [  3.  -6.]</span>
<span class="go"> [  2. -12.]</span>
<span class="go"> [  4. -15.]</span>
<span class="go"> [  6. -18.]]</span>
</pre></div>
</div>
<p>Defined in src/operator/contrib/krprod.cc:L108</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>[</em><em>]</em>) – Positional input matrices</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.linalg_extractdiag">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">linalg_extractdiag</code><span class="sig-paren">(</span><em>A=None</em>, <em>offset=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.linalg_extractdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the diagonal entries of a square matrix.
Input is a tensor <em>A</em> of dimension <em>n >= 2</em>.</p>
<p>If <em>n=2</em>, then <em>A</em> represents a single square matrix which diagonal elements get extracted as a 1-dimensional tensor.</p>
<p>If <em>n>2</em>, then <em>A</em> represents a batch of square matrices on the trailing two dimensions. The extracted diagonals are returned as an <em>n-1</em>-dimensional tensor.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator supports float32 and float64 data types only.</p>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Single</span> <span class="n">matrix</span> <span class="n">diagonal</span> <span class="n">extraction</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]]</span>

<span class="n">extractdiag</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]</span>

<span class="n">extractdiag</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="n">matrix</span> <span class="n">diagonal</span> <span class="n">extraction</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]],</span>
     <span class="p">[[</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">7.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">]]]</span>

<span class="n">extractdiag</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">],</span>
                  <span class="p">[</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L495</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of square matrices</li>
<li><strong>offset</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='0'</em>) – Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.linalg_extracttrian">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">linalg_extracttrian</code><span class="sig-paren">(</span><em>A=None</em>, <em>offset=_Null</em>, <em>lower=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.linalg_extracttrian" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts a triangular sub-matrix from a square matrix.
Input is a tensor <em>A</em> of dimension <em>n >= 2</em>.</p>
<p>If <em>n=2</em>, then <em>A</em> represents a single square matrix from which a triangular sub-matrix is extracted as a 1-dimensional tensor.</p>
<p>If <em>n>2</em>, then <em>A</em> represents a batch of square matrices on the trailing two dimensions. The extracted triangular sub-matrices are returned as an <em>n-1</em>-dimensional tensor.</p>
<p>The <em>offset</em> and <em>lower</em> parameters determine the triangle to be extracted:</p>
<ul class="simple">
<li>When <em>offset = 0</em> either the lower or upper triangle with respect to the main diagonal is extracted depending on the value of parameter <em>lower</em>.</li>
<li>When <em>offset = k > 0</em> the upper triangle with respect to the k-th diagonal above the main diagonal is extracted.</li>
<li>When <em>offset = k < 0</em> the lower triangle with respect to the k-th diagonal below the main diagonal is extracted.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator supports float32 and float64 data types only.</p>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Single</span> <span class="n">triagonal</span> <span class="n">extraction</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]]</span>

<span class="n">extracttrian</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]</span>
<span class="n">extracttrian</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]</span>
<span class="n">extracttrian</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">]</span>
<span class="n">extracttrian</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mf">3.0</span><span class="p">]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="n">triagonal</span> <span class="n">extraction</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]],</span>
     <span class="p">[[</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">7.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">]]]</span>

<span class="n">extracttrian</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">],</span>
                   <span class="p">[</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L605</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of square matrices</li>
<li><strong>offset</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='0'</em>) – Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</li>
<li><strong>lower</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.linalg_gelqf">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">linalg_gelqf</code><span class="sig-paren">(</span><em>A=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.linalg_gelqf" title="Permalink to this definition">¶</a></dt>
<dd><p>LQ factorization for general matrix.
Input is a tensor <em>A</em> of dimension <em>n >= 2</em>.</p>
<p>If <em>n=2</em>, we compute the LQ factorization (LAPACK <em>gelqf</em>, followed by <em>orglq</em>). <em>A</em>
must have shape <em>(x, y)</em> with <em>x <= y</em>, and must have full rank <em>=x</em>. The LQ
factorization consists of <em>L</em> with shape <em>(x, x)</em> and <em>Q</em> with shape <em>(x, y)</em>, so
that:</p>
<blockquote>
<div><em>A</em> = <em>L</em> * <em>Q</em></div></blockquote>
<p>Here, <em>L</em> is lower triangular (upper triangle equal to zero) with nonzero diagonal,
and <em>Q</em> is row-orthonormal, meaning that</p>
<blockquote>
<div><em>Q</em> * <em>Q</em><sup>T</sup></div></blockquote>
<p>is equal to the identity matrix of shape <em>(x, x)</em>.</p>
<p>If <em>n>2</em>, <em>gelqf</em> is performed separately on the trailing two dimensions for all
inputs (batch mode).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator supports float32 and float64 data types only.</p>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Single</span> <span class="n">LQ</span> <span class="n">factorization</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">]]</span>
<span class="n">Q</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">gelqf</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mf">0.26726124</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.53452248</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.80178373</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">0.87287156</span><span class="p">,</span> <span class="mf">0.21821789</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.43643578</span><span class="p">]]</span>
<span class="n">L</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mf">3.74165739</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span><span class="o">-</span><span class="mf">8.55235974</span><span class="p">,</span> <span class="mf">1.96396101</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="n">LQ</span> <span class="n">factorization</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">]],</span>
     <span class="p">[[</span><span class="mf">7.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="mf">9.</span><span class="p">],</span> <span class="p">[</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">,</span> <span class="mf">12.</span><span class="p">]]]</span>
<span class="n">Q</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">gelqf</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="p">[[[</span><span class="o">-</span><span class="mf">0.26726124</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.53452248</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.80178373</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.87287156</span><span class="p">,</span> <span class="mf">0.21821789</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.43643578</span><span class="p">]],</span>
     <span class="p">[[</span><span class="o">-</span><span class="mf">0.50257071</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.57436653</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.64616234</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.7620735</span><span class="p">,</span> <span class="mf">0.05862104</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.64483142</span><span class="p">]]]</span>
<span class="n">L</span> <span class="o">=</span> <span class="p">[[[</span><span class="o">-</span><span class="mf">3.74165739</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
      <span class="p">[</span><span class="o">-</span><span class="mf">8.55235974</span><span class="p">,</span> <span class="mf">1.96396101</span><span class="p">]],</span>
     <span class="p">[[</span><span class="o">-</span><span class="mf">13.92838828</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
      <span class="p">[</span><span class="o">-</span><span class="mf">19.09768702</span><span class="p">,</span> <span class="mf">0.52758934</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L798</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of input matrices to be factorized</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.linalg_gemm">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">linalg_gemm</code><span class="sig-paren">(</span><em>A=None</em>, <em>B=None</em>, <em>C=None</em>, <em>transpose_a=_Null</em>, <em>transpose_b=_Null</em>, <em>alpha=_Null</em>, <em>beta=_Null</em>, <em>axis=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.linalg_gemm" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs general matrix multiplication and accumulation.
Input are tensors <em>A</em>, <em>B</em>, <em>C</em>, each of dimension <em>n >= 2</em> and having the same shape
on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, the BLAS3 function <em>gemm</em> is performed:</p>
<blockquote>
<div><em>out</em> = <em>alpha</em> * <em>op</em>(<em>A</em>) * <em>op</em>(<em>B</em>) + <em>beta</em> * <em>C</em></div></blockquote>
<p>Here, <em>alpha</em> and <em>beta</em> are scalar parameters, and <em>op()</em> is either the identity or
matrix transposition (depending on <em>transpose_a</em>, <em>transpose_b</em>).</p>
<p>If <em>n>2</em>, <em>gemm</em> is performed separately for a batch of matrices. The column indices of the matrices
are given by the last dimensions of the tensors, the row indices by the axis specified with the <em>axis</em>
parameter. By default, the trailing two dimensions will be used for matrix encoding.</p>
<p>For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
calls. For example let <em>A</em>, <em>B</em>, <em>C</em> be 5 dimensional tensors. Then gemm(<em>A</em>, <em>B</em>, <em>C</em>, axis=1) is equivalent
to the following without the overhead of the additional swapaxis operations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A1</span> <span class="o">=</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dim1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim2</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">B1</span> <span class="o">=</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">dim1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim2</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">dim1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim2</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">gemm</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">B1</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">swapaxis</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">dim1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim2</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator supports float32 and float64 data types only.</p>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Single</span> <span class="n">matrix</span> <span class="n">multiply</span><span class="o">-</span><span class="n">add</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]</span>
<span class="n">B</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]</span>
<span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]</span>
<span class="n">gemm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">transpose_b</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">10.0</span><span class="p">)</span>
        <span class="o">=</span> <span class="p">[[</span><span class="mf">14.0</span><span class="p">,</span> <span class="mf">14.0</span><span class="p">,</span> <span class="mf">14.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">14.0</span><span class="p">,</span> <span class="mf">14.0</span><span class="p">,</span> <span class="mf">14.0</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="n">matrix</span> <span class="n">multiply</span><span class="o">-</span><span class="n">add</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]]]</span>
<span class="n">B</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]]]</span>
<span class="n">C</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">10.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">0.01</span><span class="p">]]]</span>
<span class="n">gemm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">transpose_b</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">2.0</span> <span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">10.0</span><span class="p">)</span>
        <span class="o">=</span> <span class="p">[[[</span><span class="mf">104.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">0.14</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L89</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of input matrices</li>
<li><strong>B</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of input matrices</li>
<li><strong>C</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of input matrices</li>
<li><strong>transpose_a</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Multiply with transposed of first input (A).</li>
<li><strong>transpose_b</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Multiply with transposed of second input (B).</li>
<li><strong>alpha</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Scalar factor multiplied with A*B.</li>
<li><strong>beta</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Scalar factor multiplied with C.</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='-2'</em>) – Axis corresponding to the matrix rows.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.linalg_gemm2">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">linalg_gemm2</code><span class="sig-paren">(</span><em>A=None</em>, <em>B=None</em>, <em>transpose_a=_Null</em>, <em>transpose_b=_Null</em>, <em>alpha=_Null</em>, <em>axis=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.linalg_gemm2" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs general matrix multiplication.
Input are tensors <em>A</em>, <em>B</em>, each of dimension <em>n >= 2</em> and having the same shape
on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, the BLAS3 function <em>gemm</em> is performed:</p>
<blockquote>
<div><em>out</em> = <em>alpha</em> * <em>op</em>(<em>A</em>) * <em>op</em>(<em>B</em>)</div></blockquote>
<p>Here <em>alpha</em> is a scalar parameter and <em>op()</em> is either the identity or the matrix
transposition (depending on <em>transpose_a</em>, <em>transpose_b</em>).</p>
<p>If <em>n>2</em>, <em>gemm</em> is performed separately for a batch of matrices. The column indices of the matrices
are given by the last dimensions of the tensors, the row indices by the axis specified with the <em>axis</em>
parameter. By default, the trailing two dimensions will be used for matrix encoding.</p>
<p>For a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes
calls. For example let <em>A</em>, <em>B</em> be 5 dimensional tensors. Then gemm(<em>A</em>, <em>B</em>, axis=1) is equivalent to
the following without the overhead of the additional swapaxis operations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A1</span> <span class="o">=</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dim1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim2</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">B1</span> <span class="o">=</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">dim1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim2</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">gemm2</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">B1</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">swapaxis</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">dim1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim2</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>When the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE
and MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use
pseudo-float16 precision (float32 math with float16 I/O) precision in order to use
Tensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator supports float32 and float64 data types only.</p>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Single</span> <span class="n">matrix</span> <span class="n">multiply</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]</span>
<span class="n">B</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]</span>
<span class="n">gemm2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">transpose_b</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
         <span class="o">=</span> <span class="p">[[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="n">matrix</span> <span class="n">multiply</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]]]</span>
<span class="n">B</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]]]</span>
<span class="n">gemm2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">transpose_b</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="o">=</span> <span class="p">[[[</span><span class="mf">4.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">0.04</span> <span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L163</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of input matrices</li>
<li><strong>B</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of input matrices</li>
<li><strong>transpose_a</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Multiply with transposed of first input (A).</li>
<li><strong>transpose_b</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Multiply with transposed of second input (B).</li>
<li><strong>alpha</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Scalar factor multiplied with A*B.</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='-2'</em>) – Axis corresponding to the matrix row indices.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.linalg_inverse">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">linalg_inverse</code><span class="sig-paren">(</span><em>A=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.linalg_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inverse of a matrix.
Input is a tensor <em>A</em> of dimension <em>n >= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> is a square matrix. We compute:</p>
<blockquote>
<div><em>out</em> = <em>A</em><sup>-1</sup></div></blockquote>
<p>If <em>n>2</em>, <em>inverse</em> is performed separately on the trailing two dimensions
for all inputs (batch mode).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator supports float32 and float64 data types only.</p>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Single</span> <span class="n">matrix</span> <span class="n">inversion</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]]</span>
<span class="n">inverse</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="n">matrix</span> <span class="n">inversion</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]],</span>
     <span class="p">[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">]]]</span>
<span class="n">inverse</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span><span class="o">-</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">]],</span>
              <span class="p">[[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L917</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of square matrix</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.linalg_makediag">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">linalg_makediag</code><span class="sig-paren">(</span><em>A=None</em>, <em>offset=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.linalg_makediag" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a square matrix with the input as diagonal.
Input is a tensor <em>A</em> of dimension <em>n >= 1</em>.</p>
<p>If <em>n=1</em>, then <em>A</em> represents the diagonal entries of a single square matrix. This matrix will be returned as a 2-dimensional tensor.
If <em>n>1</em>, then <em>A</em> represents a batch of diagonals of square matrices. The batch of diagonal matrices will be returned as an <em>n+1</em>-dimensional tensor.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator supports float32 and float64 data types only.</p>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Single</span> <span class="n">diagonal</span> <span class="n">matrix</span> <span class="n">construction</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]</span>

<span class="n">makediag</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>    <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                  <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]]</span>

<span class="n">makediag</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                  <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
                  <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="n">diagonal</span> <span class="n">matrix</span> <span class="n">construction</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]]</span>

<span class="n">makediag</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]],</span>
               <span class="p">[[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L547</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of diagonal entries</li>
<li><strong>offset</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='0'</em>) – Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.linalg_maketrian">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">linalg_maketrian</code><span class="sig-paren">(</span><em>A=None</em>, <em>offset=_Null</em>, <em>lower=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.linalg_maketrian" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a square matrix with the input representing a specific triangular sub-matrix.
This is basically the inverse of <em>linalg.extracttrian</em>. Input is a tensor <em>A</em> of dimension <em>n >= 1</em>.</p>
<p>If <em>n=1</em>, then <em>A</em> represents the entries of a triangular matrix which is lower triangular if <em>offset<0</em> or <em>offset=0</em>, <em>lower=true</em>. The resulting matrix is derived by first constructing the square
matrix with the entries outside the triangle set to zero and then adding <em>offset</em>-times an additional
diagonal with zero entries to the square matrix.</p>
<p>If <em>n>1</em>, then <em>A</em> represents a batch of triangular sub-matrices. The batch of corresponding square matrices is returned as an <em>n+1</em>-dimensional tensor.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator supports float32 and float64 data types only.</p>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Single</span>  <span class="n">matrix</span> <span class="n">construction</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>

<span class="n">maketrian</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>              <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                             <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]]</span>

<span class="n">maketrian</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="n">false</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
                             <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]]</span>

<span class="n">maketrian</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>    <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
                             <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span>
                             <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]]</span>
<span class="n">maketrian</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">offset</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>   <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                             <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                             <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="n">matrix</span> <span class="n">construction</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span>
     <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">]]</span>

<span class="n">maketrian</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>           <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                           <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]],</span>
                          <span class="p">[[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                           <span class="p">[</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">]]]</span>

<span class="n">maketrian</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
                           <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span>
                           <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]],</span>
                          <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">],</span>
                           <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">],</span>
                           <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L673</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of triangular matrices stored as vectors</li>
<li><strong>offset</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='0'</em>) – Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal.</li>
<li><strong>lower</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.linalg_potrf">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">linalg_potrf</code><span class="sig-paren">(</span><em>A=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.linalg_potrf" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs Cholesky factorization of a symmetric positive-definite matrix.
Input is a tensor <em>A</em> of dimension <em>n >= 2</em>.</p>
<p>If <em>n=2</em>, the Cholesky factor <em>B</em> of the symmetric, positive definite matrix <em>A</em> is
computed. <em>B</em> is triangular (entries of upper or lower triangle are all zero), has
positive diagonal entries, and:</p>
<blockquote>
<div><em>A</em> = <em>B</em> * <em>B</em><sup>T</sup>  if <em>lower</em> = <em>true</em>
<em>A</em> = <em>B</em><sup>T</sup> * <em>B</em>  if <em>lower</em> = <em>false</em></div></blockquote>
<p>If <em>n>2</em>, <em>potrf</em> is performed separately on the trailing two dimensions for all inputs
(batch mode).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator supports float32 and float64 data types only.</p>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Single</span> <span class="n">matrix</span> <span class="n">factorization</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.25</span><span class="p">]]</span>
<span class="n">potrf</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="n">matrix</span> <span class="n">factorization</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.25</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">16.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">17.0</span><span class="p">]]]</span>
<span class="n">potrf</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L214</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of input matrices to be decomposed</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.linalg_potri">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">linalg_potri</code><span class="sig-paren">(</span><em>A=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.linalg_potri" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs matrix inversion from a Cholesky factorization.
Input is a tensor <em>A</em> of dimension <em>n >= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> is a triangular matrix (entries of upper or lower triangle are all zero)
with positive diagonal. We compute:</p>
<blockquote>
<div><em>out</em> = <em>A</em><sup>-T</sup> * <em>A</em><sup>-1</sup> if <em>lower</em> = <em>true</em>
<em>out</em> = <em>A</em><sup>-1</sup> * <em>A</em><sup>-T</sup> if <em>lower</em> = <em>false</em></div></blockquote>
<p>In other words, if <em>A</em> is the Cholesky factor of a symmetric positive definite matrix
<em>B</em> (obtained by <em>potrf</em>), then</p>
<blockquote>
<div><em>out</em> = <em>B</em><sup>-1</sup></div></blockquote>
<p>If <em>n>2</em>, <em>potri</em> is performed separately on the trailing two dimensions for all inputs
(batch mode).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator supports float32 and float64 data types only.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Use this operator only if you are certain you need the inverse of <em>B</em>, and
cannot use the Cholesky factor <em>A</em> (<em>potrf</em>), together with backsubstitution
(<em>trsm</em>). The latter is numerically much safer, and also cheaper.</p>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Single</span> <span class="n">matrix</span> <span class="n">inverse</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]]</span>
<span class="n">potri</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.26563</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0625</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.0625</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="n">matrix</span> <span class="n">inverse</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]]]</span>
<span class="n">potri</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">0.26563</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0625</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.0625</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">]],</span>
            <span class="p">[[</span><span class="mf">0.06641</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.01562</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.01562</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0625</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L275</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of lower triangular matrices</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.linalg_sumlogdiag">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">linalg_sumlogdiag</code><span class="sig-paren">(</span><em>A=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.linalg_sumlogdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the sum of the logarithms of the diagonal elements of a square matrix.
Input is a tensor <em>A</em> of dimension <em>n >= 2</em>.</p>
<p>If <em>n=2</em>, <em>A</em> must be square with positive diagonal entries. We sum the natural
logarithms of the diagonal elements, the result has shape (1,).</p>
<p>If <em>n>2</em>, <em>sumlogdiag</em> is performed separately on the trailing two dimensions for all
inputs (batch mode).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator supports float32 and float64 data types only.</p>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Single</span> <span class="n">matrix</span> <span class="n">reduction</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">]]</span>
<span class="n">sumlogdiag</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.9459</span><span class="p">]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="n">matrix</span> <span class="n">reduction</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">17.0</span><span class="p">]]]</span>
<span class="n">sumlogdiag</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.9459</span><span class="p">,</span> <span class="mf">3.9318</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L445</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of square matrices</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.linalg_syrk">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">linalg_syrk</code><span class="sig-paren">(</span><em>A=None</em>, <em>transpose=_Null</em>, <em>alpha=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.linalg_syrk" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplication of matrix with its transpose.
Input is a tensor <em>A</em> of dimension <em>n >= 2</em>.</p>
<p>If <em>n=2</em>, the operator performs the BLAS3 function <em>syrk</em>:</p>
<blockquote>
<div><em>out</em> = <em>alpha</em> * <em>A</em> * <em>A</em><sup>T</sup></div></blockquote>
<p>if <em>transpose=False</em>, or</p>
<blockquote>
<div><em>out</em> = <em>alpha</em> * <em>A</em><sup>T</sup> * <em>A</em></div></blockquote>
<p>if <em>transpose=True</em>.</p>
<p>If <em>n>2</em>, <em>syrk</em> is performed separately on the trailing two dimensions for all
inputs (batch mode).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator supports float32 and float64 data types only.</p>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Single</span> <span class="n">matrix</span> <span class="n">multiply</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">]]</span>
<span class="n">syrk</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
         <span class="o">=</span> <span class="p">[[</span><span class="mf">14.</span><span class="p">,</span> <span class="mf">32.</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">32.</span><span class="p">,</span> <span class="mf">77.</span><span class="p">]]</span>
<span class="n">syrk</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
         <span class="o">=</span> <span class="p">[[</span><span class="mf">17.</span><span class="p">,</span> <span class="mf">22.</span><span class="p">,</span> <span class="mf">27.</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">22.</span><span class="p">,</span> <span class="mf">29.</span><span class="p">,</span> <span class="mf">36.</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">27.</span><span class="p">,</span> <span class="mf">36.</span><span class="p">,</span> <span class="mf">45.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="n">matrix</span> <span class="n">multiply</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]]]</span>
<span class="n">syrk</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">4.</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">0.04</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L730</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of input matrices</li>
<li><strong>transpose</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Use transpose of input matrix.</li>
<li><strong>alpha</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Scalar factor to be applied to the result.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.linalg_trmm">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">linalg_trmm</code><span class="sig-paren">(</span><em>A=None</em>, <em>B=None</em>, <em>transpose=_Null</em>, <em>rightside=_Null</em>, <em>lower=_Null</em>, <em>alpha=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.linalg_trmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs multiplication with a lower triangular matrix.
Input are tensors <em>A</em>, <em>B</em>, each of dimension <em>n >= 2</em> and having the same shape
on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, <em>A</em> must be triangular. The operator performs the BLAS3 function
<em>trmm</em>:</p>
<blockquote>
<div><em>out</em> = <em>alpha</em> * <em>op</em>(<em>A</em>) * <em>B</em></div></blockquote>
<p>if <em>rightside=False</em>, or</p>
<blockquote>
<div><em>out</em> = <em>alpha</em> * <em>B</em> * <em>op</em>(<em>A</em>)</div></blockquote>
<p>if <em>rightside=True</em>. Here, <em>alpha</em> is a scalar parameter, and <em>op()</em> is either the
identity or the matrix transposition (depending on <em>transpose</em>).</p>
<p>If <em>n>2</em>, <em>trmm</em> is performed separately on the trailing two dimensions for all inputs
(batch mode).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator supports float32 and float64 data types only.</p>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Single</span> <span class="n">triangular</span> <span class="n">matrix</span> <span class="n">multiply</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]</span>
<span class="n">B</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]</span>
<span class="n">trmm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="n">triangular</span> <span class="n">matrix</span> <span class="n">multiply</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]]</span>
<span class="n">B</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]]]</span>
<span class="n">trmm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]],</span>
                         <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L333</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of lower triangular matrices</li>
<li><strong>B</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of matrices</li>
<li><strong>transpose</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Use transposed of the triangular matrix</li>
<li><strong>rightside</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Multiply triangular matrix from the right to non-triangular one.</li>
<li><strong>lower</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – True if the triangular matrix is lower triangular, false if it is upper triangular.</li>
<li><strong>alpha</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Scalar factor to be applied to the result.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.linalg_trsm">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">linalg_trsm</code><span class="sig-paren">(</span><em>A=None</em>, <em>B=None</em>, <em>transpose=_Null</em>, <em>rightside=_Null</em>, <em>lower=_Null</em>, <em>alpha=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.linalg_trsm" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves matrix equation involving a lower triangular matrix.
Input are tensors <em>A</em>, <em>B</em>, each of dimension <em>n >= 2</em> and having the same shape
on the leading <em>n-2</em> dimensions.</p>
<p>If <em>n=2</em>, <em>A</em> must be triangular. The operator performs the BLAS3 function
<em>trsm</em>, solving for <em>out</em> in:</p>
<blockquote>
<div><em>op</em>(<em>A</em>) * <em>out</em> = <em>alpha</em> * <em>B</em></div></blockquote>
<p>if <em>rightside=False</em>, or</p>
<blockquote>
<div><em>out</em> * <em>op</em>(<em>A</em>) = <em>alpha</em> * <em>B</em></div></blockquote>
<p>if <em>rightside=True</em>. Here, <em>alpha</em> is a scalar parameter, and <em>op()</em> is either the
identity or the matrix transposition (depending on <em>transpose</em>).</p>
<p>If <em>n>2</em>, <em>trsm</em> is performed separately on the trailing two dimensions for all inputs
(batch mode).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The operator supports float32 and float64 data types only.</p>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Single</span> <span class="n">matrix</span> <span class="n">solve</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]</span>
<span class="n">B</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]]</span>
<span class="n">trsm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Batch</span> <span class="n">matrix</span> <span class="n">solve</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]]]</span>
<span class="n">B</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]],</span>
     <span class="p">[[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">8.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">]]]</span>
<span class="n">trsm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span>
                         <span class="p">[[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/la_op.cc:L396</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of lower triangular matrices</li>
<li><strong>B</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Tensor of matrices</li>
<li><strong>transpose</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Use transposed of the triangular matrix</li>
<li><strong>rightside</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Multiply triangular matrix from the right to non-triangular one.</li>
<li><strong>lower</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – True if the triangular matrix is lower triangular, false if it is upper triangular.</li>
<li><strong>alpha</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Scalar factor to be applied to the result.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.log">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">log</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise Natural logarithmic value of the input.</p>
<p>The natural logarithm is logarithm in base <em>e</em>, so that <code class="docutils literal"><span class="pre">log(exp(x))</span> <span class="pre">=</span> <span class="pre">x</span></code></p>
<p>The storage type of <code class="docutils literal"><span class="pre">log</span></code> output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L1057</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.log10">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">log10</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.log10" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise Base-10 logarithmic value of the input.</p>
<p><code class="docutils literal"><span class="pre">10**log10(x)</span> <span class="pre">=</span> <span class="pre">x</span></code></p>
<p>The storage type of <code class="docutils literal"><span class="pre">log10</span></code> output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L1074</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.log1p">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">log1p</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.log1p" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise <code class="docutils literal"><span class="pre">log(1</span> <span class="pre">+</span> <span class="pre">x)</span></code> value of the input.</p>
<p>This function is more accurate than <code class="docutils literal"><span class="pre">log(1</span> <span class="pre">+</span> <span class="pre">x)</span></code>  for small <code class="docutils literal"><span class="pre">x</span></code> so that
<span class="math">\(1+x\approx 1\)</span></p>
<p>The storage type of <code class="docutils literal"><span class="pre">log1p</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>log1p(default) = default</li>
<li>log1p(row_sparse) = row_sparse</li>
<li>log1p(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L1171</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.log2">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">log2</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.log2" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise Base-2 logarithmic value of the input.</p>
<p><code class="docutils literal"><span class="pre">2**log2(x)</span> <span class="pre">=</span> <span class="pre">x</span></code></p>
<p>The storage type of <code class="docutils literal"><span class="pre">log2</span></code> output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L1086</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.log_softmax">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">log_softmax</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>temperature=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.log_softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the log softmax of the input.
This is equivalent to computing softmax followed by log.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([-1.41702998, -0.41702995, -2.31702995], dtype=float32)</span>

<span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">],[</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span> <span class="p">)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[-0.34115392, -0.69314718, -1.24115396],</span>
<span class="go">       [-1.24115396, -0.69314718, -0.34115392]], dtype=float32)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='-1'</em>) – The axis along which to compute softmax.</li>
<li><strong>temperature</strong> (<em>double</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Temperature parameter in softmax</li>
<li><strong>dtype</strong> (<em>{None</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to the same as input’s dtype if not defined (dtype=None).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.logical_not">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">logical_not</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.logical_not" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of logical NOT (!) function</p>
<p class="rubric">Example</p>
<p>logical_not([-2., 0., 1.]) = [0., 1., 0.]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.make_loss">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">make_loss</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.make_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Make your own loss function in network construction.</p>
<p>This operator accepts a customized loss function symbol as a terminal loss and
the symbol should be an operator with no backward dependency.
The output of this function is the gradient of loss with respect to the input data.</p>
<p>For example, if you are a making a cross entropy loss function. Assume <code class="docutils literal"><span class="pre">out</span></code> is the
predicted output and <code class="docutils literal"><span class="pre">label</span></code> is the true label, then the cross entropy can be defined as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cross_entropy</span> <span class="o">=</span> <span class="n">label</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">label</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">out</span><span class="p">)</span>
<span class="n">loss</span> <span class="o">=</span> <span class="n">make_loss</span><span class="p">(</span><span class="n">cross_entropy</span><span class="p">)</span>
</pre></div>
</div>
<p>We will need to use <code class="docutils literal"><span class="pre">make_loss</span></code> when we are creating our own loss function or we want to
combine multiple loss functions. Also we may want to stop some variables’ gradients
from backpropagation. See more detail in <code class="docutils literal"><span class="pre">BlockGrad</span></code> or <code class="docutils literal"><span class="pre">stop_gradient</span></code>.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">make_loss</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>make_loss(default) = default</li>
<li>make_loss(row_sparse) = row_sparse</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L332</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.max">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">max</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the max of array elements over given axes.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L191</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – <p>The axis or axes along which to perform the reduction.</p>
<blockquote>
<div>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</div></blockquote>
</li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.max_axis">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">max_axis</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.max_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the max of array elements over given axes.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L191</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – <p>The axis or axes along which to perform the reduction.</p>
<blockquote>
<div>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</div></blockquote>
</li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.mean">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">mean</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the mean of array elements over given axes.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L132</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – <p>The axis or axes along which to perform the reduction.</p>
<blockquote>
<div>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</div></blockquote>
</li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.min">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">min</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the min of array elements over given axes.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L205</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – <p>The axis or axes along which to perform the reduction.</p>
<blockquote>
<div>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</div></blockquote>
</li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.min_axis">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">min_axis</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.min_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the min of array elements over given axes.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L205</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – <p>The axis or axes along which to perform the reduction.</p>
<blockquote>
<div>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</div></blockquote>
</li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.moments">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">moments</code><span class="sig-paren">(</span><em>data=None</em>, <em>axes=_Null</em>, <em>keepdims=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.moments" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the mean and variance of <cite>data</cite>.</p>
<p>The mean and variance are calculated by aggregating the contents of data across axes.
If x is 1-D and axes = [0] this is just the mean and variance of a vector.</p>
<p class="rubric">Example</p>
<p>x = [[1, 2, 3], [4, 5, 6]]
mean, var = moments(data=x, axes=[0])
mean = [2.5, 3.5, 4.5]
var = [2.25, 2.25, 2.25]
mean, var = moments(data=x, axes=[1])
mean = [2.0, 5.0]
var = [0.66666667, 0.66666667]
mean, var = moments(data=x, axis=[0, 1])
mean = [3.5]
var = [2.9166667]</p>
<p>Defined in src/operator/nn/moments.cc:L54</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input ndarray</li>
<li><strong>axes</strong> (<em>Shape</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Array of ints. Axes along which to compute mean and variance.</li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – produce moments with the same dimensionality as the input.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.mp_nag_mom_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">mp_nag_mom_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>mom=None</em>, <em>weight32=None</em>, <em>lr=_Null</em>, <em>momentum=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.mp_nag_mom_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update function for multi-precision Nesterov Accelerated Gradient( NAG) optimizer.</p>
<p>Defined in src/operator/optimizer_op.cc:L743</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Gradient</li>
<li><strong>mom</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Momentum</li>
<li><strong>weight32</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight32</li>
<li><strong>lr</strong> (<em>float</em><em>, </em><em>required</em>) – Learning rate</li>
<li><strong>momentum</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – The decay rate of momentum estimates at each epoch.</li>
<li><strong>wd</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.mp_sgd_mom_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">mp_sgd_mom_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>mom=None</em>, <em>weight32=None</em>, <em>lr=_Null</em>, <em>momentum=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>lazy_update=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.mp_sgd_mom_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Updater function for multi-precision sgd optimizer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Gradient</li>
<li><strong>mom</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Momentum</li>
<li><strong>weight32</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight32</li>
<li><strong>lr</strong> (<em>float</em><em>, </em><em>required</em>) – Learning rate</li>
<li><strong>momentum</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – The decay rate of momentum estimates at each epoch.</li>
<li><strong>wd</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>lazy_update</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – If true, lazy updates are applied if gradient’s stype is row_sparse and both weight and momentum have the same stype</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.mp_sgd_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">mp_sgd_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>weight32=None</em>, <em>lr=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>lazy_update=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.mp_sgd_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Updater function for multi-precision sgd optimizer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – gradient</li>
<li><strong>weight32</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight32</li>
<li><strong>lr</strong> (<em>float</em><em>, </em><em>required</em>) – Learning rate</li>
<li><strong>wd</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>lazy_update</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – If true, lazy updates are applied if gradient’s stype is row_sparse.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.multi_all_finite">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">multi_all_finite</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.multi_all_finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if all the float numbers in all the arrays are finite (used for AMP)</p>
<p>Defined in src/operator/contrib/all_finite.cc:L133</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>[</em><em>]</em>) – Arrays</li>
<li><strong>num_arrays</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='1'</em>) – Number of arrays.</li>
<li><strong>init_output</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Initialize output to 1.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.multi_mp_sgd_mom_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">multi_mp_sgd_mom_update</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.multi_mp_sgd_mom_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.</p>
<p>Momentum update has better convergence rates on neural networks. Mathematically it looks
like below:</p>
<div class="math">
\[\begin{split}v_1 = \alpha * \nabla J(W_0)\\
v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
W_t = W_{t-1} + v_t\end{split}\]</div>
<p>It updates the weights using:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">momentum</span> <span class="o">*</span> <span class="n">v</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">gradient</span>
<span class="n">weight</span> <span class="o">+=</span> <span class="n">v</span>
</pre></div>
</div>
<p>Where the parameter <code class="docutils literal"><span class="pre">momentum</span></code> is the decay rate of momentum estimates at each epoch.</p>
<p>Defined in src/operator/optimizer_op.cc:L470</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>[</em><em>]</em>) – Weights</li>
<li><strong>lrs</strong> (<em>tuple of <float></em><em>, </em><em>required</em>) – Learning rates.</li>
<li><strong>wds</strong> (<em>tuple of <float></em><em>, </em><em>required</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>momentum</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – The decay rate of momentum estimates at each epoch.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>num_weights</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='1'</em>) – Number of updated weights.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.multi_mp_sgd_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">multi_mp_sgd_update</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.multi_mp_sgd_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.</p>
<p>It updates the weights using:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="p">(</span><span class="n">gradient</span> <span class="o">+</span> <span class="n">wd</span> <span class="o">*</span> <span class="n">weight</span><span class="p">)</span>
</pre></div>
</div>
<p>Defined in src/operator/optimizer_op.cc:L415</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>[</em><em>]</em>) – Weights</li>
<li><strong>lrs</strong> (<em>tuple of <float></em><em>, </em><em>required</em>) – Learning rates.</li>
<li><strong>wds</strong> (<em>tuple of <float></em><em>, </em><em>required</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>num_weights</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='1'</em>) – Number of updated weights.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.multi_sgd_mom_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">multi_sgd_mom_update</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.multi_sgd_mom_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.</p>
<p>Momentum update has better convergence rates on neural networks. Mathematically it looks
like below:</p>
<div class="math">
\[\begin{split}v_1 = \alpha * \nabla J(W_0)\\
v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
W_t = W_{t-1} + v_t\end{split}\]</div>
<p>It updates the weights using:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">momentum</span> <span class="o">*</span> <span class="n">v</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">gradient</span>
<span class="n">weight</span> <span class="o">+=</span> <span class="n">v</span>
</pre></div>
</div>
<p>Where the parameter <code class="docutils literal"><span class="pre">momentum</span></code> is the decay rate of momentum estimates at each epoch.</p>
<p>Defined in src/operator/optimizer_op.cc:L372</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>[</em><em>]</em>) – Weights, gradients and momentum</li>
<li><strong>lrs</strong> (<em>tuple of <float></em><em>, </em><em>required</em>) – Learning rates.</li>
<li><strong>wds</strong> (<em>tuple of <float></em><em>, </em><em>required</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>momentum</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – The decay rate of momentum estimates at each epoch.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>num_weights</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='1'</em>) – Number of updated weights.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.multi_sgd_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">multi_sgd_update</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.multi_sgd_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update function for Stochastic Gradient Descent (SDG) optimizer.</p>
<p>It updates the weights using:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="p">(</span><span class="n">gradient</span> <span class="o">+</span> <span class="n">wd</span> <span class="o">*</span> <span class="n">weight</span><span class="p">)</span>
</pre></div>
</div>
<p>Defined in src/operator/optimizer_op.cc:L327</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>[</em><em>]</em>) – Weights</li>
<li><strong>lrs</strong> (<em>tuple of <float></em><em>, </em><em>required</em>) – Learning rates.</li>
<li><strong>wds</strong> (<em>tuple of <float></em><em>, </em><em>required</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>num_weights</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='1'</em>) – Number of updated weights.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.nag_mom_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">nag_mom_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>mom=None</em>, <em>lr=_Null</em>, <em>momentum=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.nag_mom_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update function for Nesterov Accelerated Gradient( NAG) optimizer.
It updates the weights using the following formula,</p>
<div class="math">
\[\begin{split}v_t = \gamma v_{t-1} + \eta * \nabla J(W_{t-1} - \gamma v_{t-1})\\
W_t = W_{t-1} - v_t\end{split}\]</div>
<p>Where
<span class="math">\(\eta\)</span> is the learning rate of the optimizer
<span class="math">\(\gamma\)</span> is the decay rate of the momentum estimate
<span class="math">\(\v_t\)</span> is the update vector at time step <cite>t</cite>
<span class="math">\(\W_t\)</span> is the weight vector at time step <cite>t</cite></p>
<p>Defined in src/operator/optimizer_op.cc:L724</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Gradient</li>
<li><strong>mom</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Momentum</li>
<li><strong>lr</strong> (<em>float</em><em>, </em><em>required</em>) – Learning rate</li>
<li><strong>momentum</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – The decay rate of momentum estimates at each epoch.</li>
<li><strong>wd</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.nanprod">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">nanprod</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.nanprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the product of array elements over given axes treating Not a Numbers (<code class="docutils literal"><span class="pre">NaN</span></code>) as one.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L177</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – <p>The axis or axes along which to perform the reduction.</p>
<blockquote>
<div>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</div></blockquote>
</li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.nansum">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">nansum</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.nansum" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the sum of array elements over given axes treating Not a Numbers (<code class="docutils literal"><span class="pre">NaN</span></code>) as zero.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L162</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – <p>The axis or axes along which to perform the reduction.</p>
<blockquote>
<div>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</div></blockquote>
</li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.negative">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">negative</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.negative" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerical negative of the argument, element-wise.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">negative</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>negative(default) = default</li>
<li>negative(row_sparse) = row_sparse</li>
<li>negative(csr) = csr</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.norm">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">norm</code><span class="sig-paren">(</span><em>data=None</em>, <em>ord=_Null</em>, <em>axis=_Null</em>, <em>out_dtype=_Null</em>, <em>keepdims=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the norm on an NDArray.</p>
<p>This operator computes the norm on an NDArray with the specified axis, depending
on the value of the ord parameter. By default, it computes the L2 norm on the entire
array. Currently only ord=2 supports sparse ndarrays.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span>
     <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]]</span>

<span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">3.1622777</span> <span class="mf">4.472136</span> <span class="p">]</span>
                          <span class="p">[</span><span class="mf">5.3851647</span> <span class="mf">6.3245554</span><span class="p">]]</span>

<span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">],</span>
                          <span class="p">[</span><span class="mf">7.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">]]</span>

<span class="n">rsp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast_storage</span><span class="p">(</span><span class="s1">'row_sparse'</span><span class="p">)</span>

<span class="n">norm</span><span class="p">(</span><span class="n">rsp</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mf">5.47722578</span><span class="p">]</span>

<span class="n">csr</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cast_storage</span><span class="p">(</span><span class="s1">'csr'</span><span class="p">)</span>

<span class="n">norm</span><span class="p">(</span><span class="n">csr</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mf">5.47722578</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L350</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>ord</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='2'</em>) – Order of the norm. Currently ord=1 and ord=2 is supported.</li>
<li><strong>axis</strong> (<em>Shape</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – <dl class="docutils">
<dt>The axis or axes along which to perform the reduction.</dt>
<dd>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.
If <cite>axis</cite> is int, a reduction is performed on a particular axis.
If <cite>axis</cite> is a 2-tuple, it specifies the axes that hold 2-D matrices,
and the matrix norms of these matrices are computed.</dd>
</dl>
</li>
<li><strong>out_dtype</strong> (<em>{None</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'</em><em>, </em><em>'int32'</em><em>, </em><em>'int64'</em><em>, </em><em>'int8'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – The data type of the output.</li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If this is set to <cite>True</cite>, the reduced axis is left in the result as dimension with size one.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.normal">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">normal</code><span class="sig-paren">(</span><em>loc=_Null</em>, <em>scale=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a normal (Gaussian) distribution.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The existing alias <code class="docutils literal"><span class="pre">normal</span></code> is deprecated.</p>
</div>
<p>Samples are distributed according to a normal distribution parametrized by <em>loc</em> (mean) and <em>scale</em>
(standard deviation).</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.89171135</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.16881478</span><span class="p">],</span>
                                       <span class="p">[</span><span class="o">-</span><span class="mf">1.23474145</span><span class="p">,</span>  <span class="mf">1.55807114</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L113</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>loc</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Mean of the distribution.</li>
<li><strong>scale</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Standard deviation of the distribution.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string</em><em>, </em><em>optional</em><em>, </em><em>default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.one_hot">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">one_hot</code><span class="sig-paren">(</span><em>indices=None</em>, <em>depth=_Null</em>, <em>on_value=_Null</em>, <em>off_value=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.one_hot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a one-hot array.</p>
<p>The locations represented by <cite>indices</cite> take value <cite>on_value</cite>, while all
other locations take value <cite>off_value</cite>.</p>
<p><cite>one_hot</cite> operation with <cite>indices</cite> of shape <code class="docutils literal"><span class="pre">(i0,</span> <span class="pre">i1)</span></code> and <cite>depth</cite>  of <code class="docutils literal"><span class="pre">d</span></code> would result
in an output array of shape <code class="docutils literal"><span class="pre">(i0,</span> <span class="pre">i1,</span> <span class="pre">d)</span></code> with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">off_value</span>
<span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">on_value</span>
</pre></div>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">one_hot</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span>  <span class="mf">1.</span>  <span class="mf">0.</span><span class="p">]</span>
                         <span class="p">[</span> <span class="mf">1.</span>  <span class="mf">0.</span>  <span class="mf">0.</span><span class="p">]</span>
                         <span class="p">[</span> <span class="mf">0.</span>  <span class="mf">0.</span>  <span class="mf">1.</span><span class="p">]</span>
                         <span class="p">[</span> <span class="mf">1.</span>  <span class="mf">0.</span>  <span class="mf">0.</span><span class="p">]]</span>

<span class="n">one_hot</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="n">on_value</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">off_value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="s1">'int32'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span> <span class="mi">8</span> <span class="mi">1</span><span class="p">]</span>
                          <span class="p">[</span><span class="mi">8</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">]</span>
                          <span class="p">[</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">8</span><span class="p">]</span>
                          <span class="p">[</span><span class="mi">8</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">]]</span>

<span class="n">one_hot</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">0.</span>  <span class="mf">1.</span>  <span class="mf">0.</span><span class="p">]</span>
                                    <span class="p">[</span> <span class="mf">1.</span>  <span class="mf">0.</span>  <span class="mf">0.</span><span class="p">]]</span>

                                   <span class="p">[[</span> <span class="mf">0.</span>  <span class="mf">1.</span>  <span class="mf">0.</span><span class="p">]</span>
                                    <span class="p">[</span> <span class="mf">1.</span>  <span class="mf">0.</span>  <span class="mf">0.</span><span class="p">]]</span>

                                   <span class="p">[[</span> <span class="mf">0.</span>  <span class="mf">0.</span>  <span class="mf">1.</span><span class="p">]</span>
                                    <span class="p">[</span> <span class="mf">1.</span>  <span class="mf">0.</span>  <span class="mf">0.</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/indexing_op.cc:L799</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>indices</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – array of locations where to set on_value</li>
<li><strong>depth</strong> (<em>int</em><em>, </em><em>required</em>) – Depth of the one hot dimension.</li>
<li><strong>on_value</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – The value assigned to the locations represented by indices.</li>
<li><strong>off_value</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – The value assigned to the locations not represented by indices.</li>
<li><strong>dtype</strong> (<em>{'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'</em><em>, </em><em>'int32'</em><em>, </em><em>'int64'</em><em>, </em><em>'int8'</em><em>, </em><em>'uint8'}</em><em>,</em><em>optional</em><em>, </em><em>default='float32'</em>) – DType of the output</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.ones_like">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">ones_like</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.ones_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of ones with the same shape and type
as the input array.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>

<span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.pad">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">pad</code><span class="sig-paren">(</span><em>data=None</em>, <em>mode=_Null</em>, <em>pad_width=_Null</em>, <em>constant_value=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Pads an input array with a constant or edge values of the array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>Pad</cite> is deprecated. Use <cite>pad</cite> instead.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Current implementation only supports 4D and 5D input arrays with padding applied
only on axes 1, 2 and 3. Expects axes 4 and 5 in <cite>pad_width</cite> to be zero.</p>
</div>
<p>This operation pads an input array with either a <cite>constant_value</cite> or edge values
along each axis of the input array. The amount of padding is specified by <cite>pad_width</cite>.</p>
<p><cite>pad_width</cite> is a tuple of integer padding widths for each axis of the format
<code class="docutils literal"><span class="pre">(before_1,</span> <span class="pre">after_1,</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">before_N,</span> <span class="pre">after_N)</span></code>. The <cite>pad_width</cite> should be of length <code class="docutils literal"><span class="pre">2*N</span></code>
where <code class="docutils literal"><span class="pre">N</span></code> is the number of dimensions of the array.</p>
<p>For dimension <code class="docutils literal"><span class="pre">N</span></code> of the input array, <code class="docutils literal"><span class="pre">before_N</span></code> and <code class="docutils literal"><span class="pre">after_N</span></code> indicates how many values
to add before and after the elements of the array along dimension <code class="docutils literal"><span class="pre">N</span></code>.
The widths of the higher two dimensions <code class="docutils literal"><span class="pre">before_1</span></code>, <code class="docutils literal"><span class="pre">after_1</span></code>, <code class="docutils literal"><span class="pre">before_2</span></code>,
<code class="docutils literal"><span class="pre">after_2</span></code> must be 0.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[[[</span>  <span class="mf">1.</span>   <span class="mf">2.</span>   <span class="mf">3.</span><span class="p">]</span>
       <span class="p">[</span>  <span class="mf">4.</span>   <span class="mf">5.</span>   <span class="mf">6.</span><span class="p">]]</span>

      <span class="p">[[</span>  <span class="mf">7.</span>   <span class="mf">8.</span>   <span class="mf">9.</span><span class="p">]</span>
       <span class="p">[</span> <span class="mf">10.</span>  <span class="mf">11.</span>  <span class="mf">12.</span><span class="p">]]]</span>


     <span class="p">[[[</span> <span class="mf">11.</span>  <span class="mf">12.</span>  <span class="mf">13.</span><span class="p">]</span>
       <span class="p">[</span> <span class="mf">14.</span>  <span class="mf">15.</span>  <span class="mf">16.</span><span class="p">]]</span>

      <span class="p">[[</span> <span class="mf">17.</span>  <span class="mf">18.</span>  <span class="mf">19.</span><span class="p">]</span>
       <span class="p">[</span> <span class="mf">20.</span>  <span class="mf">21.</span>  <span class="mf">22.</span><span class="p">]]]]</span>

<span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">"edge"</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span>

      <span class="p">[[[[</span>  <span class="mf">1.</span>   <span class="mf">1.</span>   <span class="mf">2.</span>   <span class="mf">3.</span>   <span class="mf">3.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">1.</span>   <span class="mf">1.</span>   <span class="mf">2.</span>   <span class="mf">3.</span>   <span class="mf">3.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">4.</span>   <span class="mf">4.</span>   <span class="mf">5.</span>   <span class="mf">6.</span>   <span class="mf">6.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">4.</span>   <span class="mf">4.</span>   <span class="mf">5.</span>   <span class="mf">6.</span>   <span class="mf">6.</span><span class="p">]]</span>

        <span class="p">[[</span>  <span class="mf">7.</span>   <span class="mf">7.</span>   <span class="mf">8.</span>   <span class="mf">9.</span>   <span class="mf">9.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">7.</span>   <span class="mf">7.</span>   <span class="mf">8.</span>   <span class="mf">9.</span>   <span class="mf">9.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">10.</span>  <span class="mf">10.</span>  <span class="mf">11.</span>  <span class="mf">12.</span>  <span class="mf">12.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">10.</span>  <span class="mf">10.</span>  <span class="mf">11.</span>  <span class="mf">12.</span>  <span class="mf">12.</span><span class="p">]]]</span>


       <span class="p">[[[</span> <span class="mf">11.</span>  <span class="mf">11.</span>  <span class="mf">12.</span>  <span class="mf">13.</span>  <span class="mf">13.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">11.</span>  <span class="mf">11.</span>  <span class="mf">12.</span>  <span class="mf">13.</span>  <span class="mf">13.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">14.</span>  <span class="mf">14.</span>  <span class="mf">15.</span>  <span class="mf">16.</span>  <span class="mf">16.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">14.</span>  <span class="mf">14.</span>  <span class="mf">15.</span>  <span class="mf">16.</span>  <span class="mf">16.</span><span class="p">]]</span>

        <span class="p">[[</span> <span class="mf">17.</span>  <span class="mf">17.</span>  <span class="mf">18.</span>  <span class="mf">19.</span>  <span class="mf">19.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">17.</span>  <span class="mf">17.</span>  <span class="mf">18.</span>  <span class="mf">19.</span>  <span class="mf">19.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">20.</span>  <span class="mf">20.</span>  <span class="mf">21.</span>  <span class="mf">22.</span>  <span class="mf">22.</span><span class="p">]</span>
         <span class="p">[</span> <span class="mf">20.</span>  <span class="mf">20.</span>  <span class="mf">21.</span>  <span class="mf">22.</span>  <span class="mf">22.</span><span class="p">]]]]</span>

<span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">"constant"</span><span class="p">,</span> <span class="n">constant_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span>

      <span class="p">[[[[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>   <span class="mf">1.</span>   <span class="mf">2.</span>   <span class="mf">3.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>   <span class="mf">4.</span>   <span class="mf">5.</span>   <span class="mf">6.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]]</span>

        <span class="p">[[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>   <span class="mf">7.</span>   <span class="mf">8.</span>   <span class="mf">9.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>  <span class="mf">10.</span>  <span class="mf">11.</span>  <span class="mf">12.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]]]</span>


       <span class="p">[[[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>  <span class="mf">11.</span>  <span class="mf">12.</span>  <span class="mf">13.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>  <span class="mf">14.</span>  <span class="mf">15.</span>  <span class="mf">16.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]]</span>

        <span class="p">[[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>  <span class="mf">17.</span>  <span class="mf">18.</span>  <span class="mf">19.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>  <span class="mf">20.</span>  <span class="mf">21.</span>  <span class="mf">22.</span>   <span class="mf">0.</span><span class="p">]</span>
         <span class="p">[</span>  <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span>   <span class="mf">0.</span><span class="p">]]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/pad.cc:L766</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – An n-dimensional input array.</li>
<li><strong>mode</strong> (<em>{'constant'</em><em>, </em><em>'edge'</em><em>, </em><em>'reflect'}</em><em>, </em><em>required</em>) – Padding type to use. “constant” pads with <cite>constant_value</cite> “edge” pads using the edge values of the input array “reflect” pads by reflecting values with respect to the edges.</li>
<li><strong>pad_width</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>required</em>) – Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format <code class="docutils literal"><span class="pre">(before_1,</span> <span class="pre">after_1,</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">before_N,</span> <span class="pre">after_N)</span></code>. It should be of length <code class="docutils literal"><span class="pre">2*N</span></code> where <code class="docutils literal"><span class="pre">N</span></code> is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened.</li>
<li><strong>constant_value</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – The value used for padding when <cite>mode</cite> is “constant”.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.pick">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">pick</code><span class="sig-paren">(</span><em>data=None</em>, <em>index=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>mode=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.pick" title="Permalink to this definition">¶</a></dt>
<dd><p>Picks elements from an input array according to the input indices along the given axis.</p>
<p>Given an input array of shape <code class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1)</span></code> and indices of shape <code class="docutils literal"><span class="pre">(i0,)</span></code>, the result will be
an output array of shape <code class="docutils literal"><span class="pre">(i0,)</span></code> with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
</pre></div>
</div>
<p>By default, if any index mentioned is too large, it is replaced by the index that addresses
the last element along an axis (the <cite>clip</cite> mode).</p>
<p>This function supports n-dimensional input and (n-1)-dimensional indices arrays.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">picks</span> <span class="n">elements</span> <span class="k">with</span> <span class="n">specified</span> <span class="n">indices</span> <span class="n">along</span> <span class="n">axis</span> <span class="mi">0</span>
<span class="n">pick</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]</span>

<span class="o">//</span> <span class="n">picks</span> <span class="n">elements</span> <span class="k">with</span> <span class="n">specified</span> <span class="n">indices</span> <span class="n">along</span> <span class="n">axis</span> <span class="mi">1</span>
<span class="n">pick</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">2.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">picks</span> <span class="n">elements</span> <span class="k">with</span> <span class="n">specified</span> <span class="n">indices</span> <span class="n">along</span> <span class="n">axis</span> <span class="mi">1</span> <span class="n">using</span> <span class="s1">'wrap'</span> <span class="n">mode</span>
<span class="o">//</span> <span class="n">to</span> <span class="n">place</span> <span class="n">indicies</span> <span class="n">that</span> <span class="n">would</span> <span class="n">normally</span> <span class="n">be</span> <span class="n">out</span> <span class="n">of</span> <span class="n">bounds</span>
<span class="n">pick</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'wrap'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">2.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">picks</span> <span class="n">elements</span> <span class="k">with</span> <span class="n">specified</span> <span class="n">indices</span> <span class="n">along</span> <span class="n">axis</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">dims</span> <span class="n">are</span> <span class="n">maintained</span>
<span class="n">pick</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">],</span>
                               <span class="p">[</span> <span class="mf">3.</span><span class="p">],</span>
                               <span class="p">[</span> <span class="mf">6.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_index.cc:L154</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array</li>
<li><strong>index</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The index array</li>
<li><strong>axis</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default='-1'</em>) – int or None. The axis to picking the elements. Negative values means indexing from right to left. If is <cite>None</cite>, the elements in the index w.r.t the flattened input will be picked.</li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If true, the axis where we pick the elements is left in the result as dimension with size one.</li>
<li><strong>mode</strong> (<em>{'clip'</em><em>, </em><em>'wrap'}</em><em>,</em><em>optional</em><em>, </em><em>default='clip'</em>) – Specify how out-of-bound indices behave. Default is “clip”. “clip” means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  “wrap” means to wrap around.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.prod">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">prod</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the product of array elements over given axes.</p>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L147</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – <p>The axis or axes along which to perform the reduction.</p>
<blockquote>
<div>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</div></blockquote>
</li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.radians">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">radians</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.radians" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts each element of the input array from degrees to radians.</p>
<div class="math">
\[radians([0, 90, 180, 270, 360]) = [0, \pi/2, \pi, 3\pi/2, 2\pi]\]</div>
<p>The storage type of <code class="docutils literal"><span class="pre">radians</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>radians(default) = default</li>
<li>radians(row_sparse) = row_sparse</li>
<li>radians(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L238</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.random_exponential">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">random_exponential</code><span class="sig-paren">(</span><em>lam=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.random_exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from an exponential distribution.</p>
<p>Samples are distributed according to an exponential distribution parametrized by <em>lambda</em> (rate).</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">exponential</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.0097189</span> <span class="p">,</span>  <span class="mf">0.08999364</span><span class="p">],</span>
                                   <span class="p">[</span> <span class="mf">0.04146638</span><span class="p">,</span>  <span class="mf">0.31715935</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L137</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lam</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Lambda parameter (rate) of the exponential distribution.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string</em><em>, </em><em>optional</em><em>, </em><em>default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.random_gamma">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">random_gamma</code><span class="sig-paren">(</span><em>alpha=_Null</em>, <em>beta=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.random_gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a gamma distribution.</p>
<p>Samples are distributed according to a gamma distribution parametrized by <em>alpha</em> (shape) and <em>beta</em> (scale).</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gamma</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">7.10486984</span><span class="p">,</span>  <span class="mf">3.37695289</span><span class="p">],</span>
                                         <span class="p">[</span> <span class="mf">3.91697288</span><span class="p">,</span>  <span class="mf">3.65933681</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L125</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>alpha</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Alpha parameter (shape) of the gamma distribution.</li>
<li><strong>beta</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Beta parameter (scale) of the gamma distribution.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string</em><em>, </em><em>optional</em><em>, </em><em>default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.random_generalized_negative_binomial">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">random_generalized_negative_binomial</code><span class="sig-paren">(</span><em>mu=_Null</em>, <em>alpha=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.random_generalized_negative_binomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a generalized negative binomial distribution.</p>
<p>Samples are distributed according to a generalized negative binomial distribution parametrized by
<em>mu</em> (mean) and <em>alpha</em> (dispersion). <em>alpha</em> is defined as <em>1/k</em> where <em>k</em> is the failure limit of the
number of unsuccessful experiments (generalized to real numbers).
Samples will always be returned as a floating point data type.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">generalized_negative_binomial</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                                                                 <span class="p">[</span> <span class="mf">6.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L179</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mu</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Mean of the negative binomial distribution.</li>
<li><strong>alpha</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Alpha (dispersion) parameter of the negative binomial distribution.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string</em><em>, </em><em>optional</em><em>, </em><em>default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.random_negative_binomial">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">random_negative_binomial</code><span class="sig-paren">(</span><em>k=_Null</em>, <em>p=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.random_negative_binomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a negative binomial distribution.</p>
<p>Samples are distributed according to a negative binomial distribution parametrized by
<em>k</em> (limit of unsuccessful experiments) and <em>p</em> (failure probability in each experiment).
Samples will always be returned as a floating point data type.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">negative_binomial</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">],</span>
                                              <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L164</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>k</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='1'</em>) – Limit of unsuccessful experiments.</li>
<li><strong>p</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Failure probability in each experiment.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string</em><em>, </em><em>optional</em><em>, </em><em>default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.random_normal">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">random_normal</code><span class="sig-paren">(</span><em>loc=_Null</em>, <em>scale=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.random_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a normal (Gaussian) distribution.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The existing alias <code class="docutils literal"><span class="pre">normal</span></code> is deprecated.</p>
</div>
<p>Samples are distributed according to a normal distribution parametrized by <em>loc</em> (mean) and <em>scale</em>
(standard deviation).</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.89171135</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.16881478</span><span class="p">],</span>
                                       <span class="p">[</span><span class="o">-</span><span class="mf">1.23474145</span><span class="p">,</span>  <span class="mf">1.55807114</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L113</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>loc</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Mean of the distribution.</li>
<li><strong>scale</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Standard deviation of the distribution.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string</em><em>, </em><em>optional</em><em>, </em><em>default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.random_poisson">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">random_poisson</code><span class="sig-paren">(</span><em>lam=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.random_poisson" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a Poisson distribution.</p>
<p>Samples are distributed according to a Poisson distribution parametrized by <em>lambda</em> (rate).
Samples will always be returned as a floating point data type.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">poisson</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                               <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L150</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lam</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Lambda parameter (rate) of the Poisson distribution.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string</em><em>, </em><em>optional</em><em>, </em><em>default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.random_randint">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">random_randint</code><span class="sig-paren">(</span><em>low=_Null</em>, <em>high=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.random_randint" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a discrete uniform distribution.</p>
<p>Samples are uniformly distributed over the half-open interval <em>[low, high)</em>
(includes <em>low</em>, but excludes <em>high</em>).</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">],</span>
                                       <span class="p">[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L193</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>low</strong> (<em>, </em><em>required</em>) – Lower bound of the distribution.</li>
<li><strong>high</strong> (<em>, </em><em>required</em>) – Upper bound of the distribution.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string</em><em>, </em><em>optional</em><em>, </em><em>default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'int32'</em><em>, </em><em>'int64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to int32 if not defined (dtype=None).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.random_uniform">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">random_uniform</code><span class="sig-paren">(</span><em>low=_Null</em>, <em>high=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.random_uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a uniform distribution.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The existing alias <code class="docutils literal"><span class="pre">uniform</span></code> is deprecated.</p>
</div>
<p>Samples are uniformly distributed over the half-open interval <em>[low, high)</em>
(includes <em>low</em>, but excludes <em>high</em>).</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.60276335</span><span class="p">,</span>  <span class="mf">0.85794562</span><span class="p">],</span>
                                       <span class="p">[</span> <span class="mf">0.54488319</span><span class="p">,</span>  <span class="mf">0.84725171</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L96</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>low</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Lower bound of the distribution.</li>
<li><strong>high</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Upper bound of the distribution.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string</em><em>, </em><em>optional</em><em>, </em><em>default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.ravel_multi_index">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">ravel_multi_index</code><span class="sig-paren">(</span><em>data=None</em>, <em>shape=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.ravel_multi_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix. The leading dimension may be left unspecified by using -1 as placeholder.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">ravel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span> <span class="o">=</span> <span class="p">[</span><span class="mi">22</span><span class="p">,</span><span class="mi">41</span><span class="p">,</span><span class="mi">37</span><span class="p">]</span>
<span class="n">ravel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span> <span class="o">=</span> <span class="p">[</span><span class="mi">22</span><span class="p">,</span><span class="mi">41</span><span class="p">,</span><span class="mi">37</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/ravel.cc:L42</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Batch of multi-indices</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape of the array into which the multi-indices apply.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.rcbrt">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">rcbrt</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.rcbrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise inverse cube-root value of the input.</p>
<div class="math">
\[rcbrt(x) = 1/\sqrt[3]{x}\]</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">rcbrt</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">125</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L1004</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.reciprocal">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">reciprocal</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.reciprocal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the reciprocal of the argument, element-wise.</p>
<p>Calculates 1/x.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">reciprocal</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">1.6.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.33333334</span><span class="p">,</span> <span class="mf">0.625</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L686</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.relu">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">relu</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.relu" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes rectified linear activation.</p>
<div class="math">
\[max(features, 0)\]</div>
<p>The storage type of <code class="docutils literal"><span class="pre">relu</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>relu(default) = default</li>
<li>relu(row_sparse) = row_sparse</li>
<li>relu(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L85</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.repeat">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">repeat</code><span class="sig-paren">(</span><em>data=None</em>, <em>repeats=_Null</em>, <em>axis=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeats elements of an array.</p>
<p>By default, <code class="docutils literal"><span class="pre">repeat</span></code> flattens the input array into 1-D and then repeats the
elements:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
     <span class="p">[</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>

<span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]</span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal"><span class="pre">axis</span></code> specifies the axis along which to perform repeat:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                                <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>

<span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                                <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                                <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                                <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>

<span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">repeats</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                                 <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L796</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data array</li>
<li><strong>repeats</strong> (<em>int</em><em>, </em><em>required</em>) – The number of repetitions for each element.</li>
<li><strong>axis</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default='None'</em>) – The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input array, and return a flat output array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.reshape">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">reshape</code><span class="sig-paren">(</span><em>data=None</em>, <em>shape=_Null</em>, <em>reverse=_Null</em>, <em>target_shape=_Null</em>, <em>keep_highest=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshapes the input array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">Reshape</span></code> is deprecated, use <code class="docutils literal"><span class="pre">reshape</span></code></p>
</div>
<p>Given an array and a shape, this function returns a copy of the array in the new shape.
The shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
</pre></div>
</div>
<p>Some dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">0</span></code>  copy this dimension from the input to the output shape.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-1</span></code> infers the dimension of the output shape by using the remainder of the input dimensions
keeping the size of the new array same as that of the input array.
At most one dimension of shape can be -1.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">24</span><span class="p">,)</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-2</span></code> copy all/remainder of the input dimensions to the output shape.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-3</span></code> use the product of two consecutive dimensions of the input shape as the output dimension.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">12</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">-4</span></code> split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="o">-</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>If the argument <cite>reverse</cite> is set to 1, then the special values are inferred from right to left.</p>
<blockquote>
<div><p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">without</span> <span class="n">reverse</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="k">for</span> <span class="nb">input</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">output</span> <span class="n">shape</span> <span class="n">would</span> <span class="n">be</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="o">-</span> <span class="k">with</span> <span class="n">reverse</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output</span> <span class="n">shape</span> <span class="n">will</span> <span class="n">be</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
</div></blockquote>
<p>Defined in src/operator/tensor/matrix_op.cc:L202</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data to reshape.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – The target shape</li>
<li><strong>reverse</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If true then the special values are inferred from right to left</li>
<li><strong>target_shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – (Deprecated! Use <code class="docutils literal"><span class="pre">shape</span></code> instead.) Target new shape. One and only one dim can be 0, in which case it will be inferred from the rest of dims</li>
<li><strong>keep_highest</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – (Deprecated! Use <code class="docutils literal"><span class="pre">shape</span></code> instead.) Whether keep the highest dim unchanged.If set to true, then the first dim in target_shape is ignored,and always fixed as input</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.reshape_like">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">reshape_like</code><span class="sig-paren">(</span><em>lhs=None</em>, <em>rhs=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.reshape_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape some or all dimensions of <cite>lhs</cite> to have the same shape as some or all dimensions of <cite>rhs</cite>.</p>
<p>Returns a <strong>view</strong> of the <cite>lhs</cite> array with a new shape without altering any data.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="n">reshape_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]]</span>
</pre></div>
</div>
<p>More precise control over how dimensions are inherited is achieved by specifying slices over the <cite>lhs</cite> and <cite>rhs</cite> array dimensions. Only the sliced <cite>lhs</cite> dimensions are reshaped to the <cite>rhs</cite> sliced dimensions, with the non-sliced <cite>lhs</cite> dimensions staying the same.</p>
<blockquote>
<div><p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">lhs</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="n">rhs</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lhs_begin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lhs_end</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rhs_begin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rhs_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="o">-</span> <span class="n">lhs</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">rhs</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">lhs_begin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lhs_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">rhs_begin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rhs_end</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Negative indices are supported, and <cite>None</cite> can be used for either <cite>lhs_end</cite> or <cite>rhs_end</cite> to indicate the end of the range.</p>
<blockquote>
<div><p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">lhs</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="n">rhs</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">lhs_begin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">lhs_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rhs_begin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rhs_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L485</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – First input.</li>
<li><strong>rhs</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Second input.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.reverse">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">reverse</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverses the order of elements along given axis while preserving array shape.</p>
<p>Note: reverse and flip are equivalent. We use reverse in the following examples.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">]]</span>

<span class="n">reverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">9.</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>

<span class="n">reverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">9.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L898</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data array</li>
<li><strong>axis</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>required</em>) – The axis which to reverse elements.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.rint">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">rint</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.rint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise rounded value to the nearest integer of the input.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>For input <code class="docutils literal"><span class="pre">n.5</span></code> <code class="docutils literal"><span class="pre">rint</span></code> returns <code class="docutils literal"><span class="pre">n</span></code> while <code class="docutils literal"><span class="pre">round</span></code> returns <code class="docutils literal"><span class="pre">n+1</span></code>.</li>
<li>For input <code class="docutils literal"><span class="pre">-n.5</span></code> both <code class="docutils literal"><span class="pre">rint</span></code> and <code class="docutils literal"><span class="pre">round</span></code> returns <code class="docutils literal"><span class="pre">-n-1</span></code>.</li>
</ul>
</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">rint</span><span class="p">([</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]</span>
</pre></div>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">rint</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>rint(default) = default</li>
<li>rint(row_sparse) = row_sparse</li>
<li>rint(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L767</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.rmsprop_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">rmsprop_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>n=None</em>, <em>lr=_Null</em>, <em>gamma1=_Null</em>, <em>epsilon=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>clip_weights=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.rmsprop_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update function for <cite>RMSProp</cite> optimizer.</p>
<p><cite>RMSprop</cite> is a variant of stochastic gradient descent where the gradients are
divided by a cache which grows with the sum of squares of recent gradients?</p>
<p><cite>RMSProp</cite> is similar to <cite>AdaGrad</cite>, a popular variant of <cite>SGD</cite> which adaptively
tunes the learning rate of each parameter. <cite>AdaGrad</cite> lowers the learning rate for
each parameter monotonically over the course of training.
While this is analytically motivated for convex optimizations, it may not be ideal
for non-convex problems. <cite>RMSProp</cite> deals with this heuristically by allowing the
learning rates to rebound as the denominator decays over time.</p>
<p>Define the Root Mean Square (RMS) error criterion of the gradient as
<span class="math">\(RMS[g]_t = \sqrt{E[g^2]_t + \epsilon}\)</span>, where <span class="math">\(g\)</span> represents
gradient and <span class="math">\(E[g^2]_t\)</span> is the decaying average over past squared gradient.</p>
<p>The <span class="math">\(E[g^2]_t\)</span> is given by:</p>
<div class="math">
\[E[g^2]_t = \gamma * E[g^2]_{t-1} + (1-\gamma) * g_t^2\]</div>
<p>The update step is</p>
<div class="math">
\[\theta_{t+1} = \theta_t - \frac{\eta}{RMS[g]_t} g_t\]</div>
<p>The RMSProp code follows the version in
<a class="reference external" href="http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf">http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf</a>
Tieleman &amp; Hinton, 2012.</p>
<p>Hinton suggests the momentum term <span class="math">\(\gamma\)</span> to be 0.9 and the learning rate
<span class="math">\(\eta\)</span> to be 0.001.</p>
<p>Defined in src/operator/optimizer_op.cc:L795</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Gradient</li>
<li><strong>n</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – n</li>
<li><strong>lr</strong> (<em>float</em><em>, </em><em>required</em>) – Learning rate</li>
<li><strong>gamma1</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.949999988</em>) – The decay rate of momentum estimates.</li>
<li><strong>epsilon</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=9.99999994e-09</em>) – A small constant for numerical stability.</li>
<li><strong>wd</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>clip_weights</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip weights to the range of [-clip_weights, clip_weights] If clip_weights <= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.rmspropalex_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">rmspropalex_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>n=None</em>, <em>g=None</em>, <em>delta=None</em>, <em>lr=_Null</em>, <em>gamma1=_Null</em>, <em>gamma2=_Null</em>, <em>epsilon=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>clip_weights=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.rmspropalex_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update function for RMSPropAlex optimizer.</p>
<p><cite>RMSPropAlex</cite> is non-centered version of <cite>RMSProp</cite>.</p>
<p>Define <span class="math">\(E[g^2]_t\)</span> is the decaying average over past squared gradient and
<span class="math">\(E[g]_t\)</span> is the decaying average over past gradient.</p>
<div class="math">
\[\begin{split}E[g^2]_t = \gamma_1 * E[g^2]_{t-1} + (1 - \gamma_1) * g_t^2\\
E[g]_t = \gamma_1 * E[g]_{t-1} + (1 - \gamma_1) * g_t\\
\Delta_t = \gamma_2 * \Delta_{t-1} - \frac{\eta}{\sqrt{E[g^2]_t - E[g]_t^2 + \epsilon}} g_t\\\end{split}\]</div>
<p>The update step is</p>
<div class="math">
\[\theta_{t+1} = \theta_t + \Delta_t\]</div>
<p>The RMSPropAlex code follows the version in
<a class="reference external" href="http://arxiv.org/pdf/1308.0850v5.pdf">http://arxiv.org/pdf/1308.0850v5.pdf</a> Eq(38) - Eq(45) by Alex Graves, 2013.</p>
<p>Graves suggests the momentum term <span class="math">\(\gamma_1\)</span> to be 0.95, <span class="math">\(\gamma_2\)</span>
to be 0.9 and the learning rate <span class="math">\(\eta\)</span> to be 0.0001.</p>
<p>Defined in src/operator/optimizer_op.cc:L834</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Gradient</li>
<li><strong>n</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – n</li>
<li><strong>g</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – g</li>
<li><strong>delta</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – delta</li>
<li><strong>lr</strong> (<em>float</em><em>, </em><em>required</em>) – Learning rate</li>
<li><strong>gamma1</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.949999988</em>) – Decay rate.</li>
<li><strong>gamma2</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0.899999976</em>) – Decay rate.</li>
<li><strong>epsilon</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=9.99999994e-09</em>) – A small constant for numerical stability.</li>
<li><strong>wd</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>clip_weights</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip weights to the range of [-clip_weights, clip_weights] If clip_weights <= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.round">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">round</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise rounded value to the nearest integer of the input.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">round</span><span class="p">([</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]</span>
</pre></div>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">round</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>round(default) = default</li>
<li>round(row_sparse) = row_sparse</li>
<li>round(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L746</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.rsqrt">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">rsqrt</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.rsqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise inverse square-root value of the input.</p>
<div class="math">
\[rsqrt(x) = 1/\sqrt{x}\]</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">rsqrt</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">16</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.33333334</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">]</span>
</pre></div>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">rsqrt</span></code> output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L927</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sample_exponential">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sample_exponential</code><span class="sig-paren">(</span><em>lam=None</em>, <em>shape=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sample_exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple
exponential distributions with parameters lambda (rate).</p>
<p>The parameters of the distributions are provided as an input array.
Let <em>[s]</em> be the shape of the input array, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em>
be the shape specified as the parameter of the operator, and <em>m</em> be the dimension
of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input array, <em>output[i]</em>
will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input value at index <em>i</em>. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input array.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">lam</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">8.5</span> <span class="p">]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">single</span> <span class="n">sample</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_exponential</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.51837951</span><span class="p">,</span>  <span class="mf">0.09994757</span><span class="p">]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">containing</span> <span class="n">two</span> <span class="n">samples</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_exponential</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.51837951</span><span class="p">,</span>  <span class="mf">0.19866663</span><span class="p">],</span>
                                      <span class="p">[</span> <span class="mf">0.09994757</span><span class="p">,</span>  <span class="mf">0.50447971</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/multisample_op.cc:L284</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lam</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Lambda (rate) parameters of the distributions.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sample_gamma">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sample_gamma</code><span class="sig-paren">(</span><em>alpha=None</em>, <em>beta=None</em>, <em>shape=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sample_gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple
gamma distributions with parameters <em>alpha</em> (shape) and <em>beta</em> (scale).</p>
<p>The parameters of the distributions are provided as input arrays.
Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em>
be the shape specified as the parameter of the operator, and <em>m</em> be the dimension
of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em>
will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index <em>i</em>. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">alpha</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.5</span> <span class="p">]</span>
<span class="n">beta</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.7</span> <span class="p">]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">single</span> <span class="n">sample</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_gamma</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">2.25797319</span><span class="p">]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">containing</span> <span class="n">two</span> <span class="n">samples</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_gamma</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span>        <span class="p">,</span>  <span class="mf">0.</span>        <span class="p">],</span>
                                        <span class="p">[</span> <span class="mf">2.25797319</span><span class="p">,</span>  <span class="mf">1.70734084</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/multisample_op.cc:L282</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>alpha</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Alpha (shape) parameters of the distributions.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>beta</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Beta (scale) parameters of the distributions.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sample_generalized_negative_binomial">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sample_generalized_negative_binomial</code><span class="sig-paren">(</span><em>mu=None</em>, <em>alpha=None</em>, <em>shape=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sample_generalized_negative_binomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple
generalized negative binomial distributions with parameters <em>mu</em> (mean) and <em>alpha</em> (dispersion).</p>
<p>The parameters of the distributions are provided as input arrays.
Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em>
be the shape specified as the parameter of the operator, and <em>m</em> be the dimension
of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em>
will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index <em>i</em>. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mu</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.5</span> <span class="p">]</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.1</span> <span class="p">]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">single</span> <span class="n">sample</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_generalized_negative_binomial</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">containing</span> <span class="n">two</span> <span class="n">samples</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_generalized_negative_binomial</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
                                                              <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/multisample_op.cc:L293</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mu</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Means of the distributions.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>alpha</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Alpha (dispersion) parameters of the distributions.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sample_multinomial">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sample_multinomial</code><span class="sig-paren">(</span><em>data=None</em>, <em>shape=_Null</em>, <em>get_prob=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sample_multinomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple multinomial distributions.</p>
<p><em>data</em> is an <em>n</em> dimensional array whose last dimension has length <em>k</em>, where
<em>k</em> is the number of possible outcomes of each multinomial distribution. This
operator will draw <em>shape</em> samples from each distribution. If shape is empty
one sample will be drawn from each distribution.</p>
<p>If <em>get_prob</em> is true, a second array containing log likelihood of the drawn
samples will also be returned. This is usually used for reinforcement learning
where you can provide reward as head gradient for this array to estimate
gradient.</p>
<p>Note that the input distribution must be normalized, i.e. <em>data</em> must sum to
1 along its last axis.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">probs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">single</span> <span class="n">sample</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_multinomial</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">containing</span> <span class="n">two</span> <span class="n">samples</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_multinomial</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">requests</span> <span class="n">log</span> <span class="n">likelihood</span>
<span class="n">sample_multinomial</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">get_prob</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Distribution probabilities. Must sum to one on the last axis.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>get_prob</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to also return the log probability of sampled result. This is usually used for differentiating through stochastic variables, e.g. in reinforcement learning.</li>
<li><strong>dtype</strong> (<em>{'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'</em><em>, </em><em>'int32'</em><em>, </em><em>'uint8'}</em><em>,</em><em>optional</em><em>, </em><em>default='int32'</em>) – DType of the output in case this can’t be inferred.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sample_negative_binomial">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sample_negative_binomial</code><span class="sig-paren">(</span><em>k=None</em>, <em>p=None</em>, <em>shape=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sample_negative_binomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple
negative binomial distributions with parameters <em>k</em> (failure limit) and <em>p</em> (failure probability).</p>
<p>The parameters of the distributions are provided as input arrays.
Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em>
be the shape specified as the parameter of the operator, and <em>m</em> be the dimension
of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em>
will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index <em>i</em>. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">49</span> <span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.4</span> <span class="p">,</span> <span class="mf">0.77</span> <span class="p">]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">single</span> <span class="n">sample</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_negative_binomial</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">15.</span><span class="p">,</span>  <span class="mf">16.</span><span class="p">]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">containing</span> <span class="n">two</span> <span class="n">samples</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_negative_binomial</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">15.</span><span class="p">,</span>  <span class="mf">50.</span><span class="p">],</span>
                                             <span class="p">[</span> <span class="mf">16.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/multisample_op.cc:L289</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>k</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Limits of unsuccessful experiments.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>p</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Failure probabilities in each experiment.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sample_normal">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sample_normal</code><span class="sig-paren">(</span><em>mu=None</em>, <em>sigma=None</em>, <em>shape=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sample_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple
normal distributions with parameters <em>mu</em> (mean) and <em>sigma</em> (standard deviation).</p>
<p>The parameters of the distributions are provided as input arrays.
Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em>
be the shape specified as the parameter of the operator, and <em>m</em> be the dimension
of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em>
will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index <em>i</em>. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mu</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.5</span> <span class="p">]</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.7</span> <span class="p">]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">single</span> <span class="n">sample</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_normal</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.56410581</span><span class="p">,</span>  <span class="mf">0.95934606</span><span class="p">]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">containing</span> <span class="n">two</span> <span class="n">samples</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_normal</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mf">0.56410581</span><span class="p">,</span>  <span class="mf">0.2928229</span> <span class="p">],</span>
                                       <span class="p">[</span> <span class="mf">0.95934606</span><span class="p">,</span>  <span class="mf">4.48287058</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/multisample_op.cc:L279</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mu</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Means of the distributions.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>sigma</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Standard deviations of the distributions.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sample_poisson">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sample_poisson</code><span class="sig-paren">(</span><em>lam=None</em>, <em>shape=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sample_poisson" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple
Poisson distributions with parameters lambda (rate).</p>
<p>The parameters of the distributions are provided as an input array.
Let <em>[s]</em> be the shape of the input array, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em>
be the shape specified as the parameter of the operator, and <em>m</em> be the dimension
of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input array, <em>output[i]</em>
will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input value at index <em>i</em>. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input array.</p>
<p>Samples will always be returned as a floating point data type.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">lam</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">8.5</span> <span class="p">]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">single</span> <span class="n">sample</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_poisson</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">13.</span><span class="p">]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">containing</span> <span class="n">two</span> <span class="n">samples</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_poisson</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">0.</span><span class="p">,</span>   <span class="mf">4.</span><span class="p">],</span>
                                  <span class="p">[</span> <span class="mf">13.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/multisample_op.cc:L286</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lam</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Lambda (rate) parameters of the distributions.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sample_uniform">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sample_uniform</code><span class="sig-paren">(</span><em>low=None</em>, <em>high=None</em>, <em>shape=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sample_uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Concurrent sampling from multiple
uniform distributions on the intervals given by <em>[low,high)</em>.</p>
<p>The parameters of the distributions are provided as input arrays.
Let <em>[s]</em> be the shape of the input arrays, <em>n</em> be the dimension of <em>[s]</em>, <em>[t]</em>
be the shape specified as the parameter of the operator, and <em>m</em> be the dimension
of <em>[t]</em>. Then the output will be a <em>(n+m)</em>-dimensional array with shape <em>[s]x[t]</em>.</p>
<p>For any valid <em>n</em>-dimensional index <em>i</em> with respect to the input arrays, <em>output[i]</em>
will be an <em>m</em>-dimensional array that holds randomly drawn samples from the distribution
which is parameterized by the input values at index <em>i</em>. If the shape parameter of the
operator is not set, then one sample will be drawn per distribution and the output array
has the same shape as the input arrays.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">low</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.5</span> <span class="p">]</span>
<span class="n">high</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.7</span> <span class="p">]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">single</span> <span class="n">sample</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_uniform</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.40451524</span><span class="p">,</span>  <span class="mf">3.18687344</span><span class="p">]</span>

<span class="o">//</span> <span class="n">Draw</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">containing</span> <span class="n">two</span> <span class="n">samples</span> <span class="k">for</span> <span class="n">each</span> <span class="n">distribution</span>
<span class="n">sample_uniform</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.40451524</span><span class="p">,</span>  <span class="mf">0.18017688</span><span class="p">],</span>
                                        <span class="p">[</span> <span class="mf">3.18687344</span><span class="p">,</span>  <span class="mf">3.68352246</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/multisample_op.cc:L277</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>low</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Lower bounds of the distributions.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape to be sampled from each random distribution.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>high</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Upper bounds of the distributions.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.scatter_nd">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">scatter_nd</code><span class="sig-paren">(</span><em>data=None</em>, <em>indices=None</em>, <em>shape=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.scatter_nd" title="Permalink to this definition">¶</a></dt>
<dd><p>Scatters data into a new tensor according to indices.</p>
<p>Given <cite>data</cite> with shape <cite>(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})</cite> and indices with shape
<cite>(M, Y_0, ..., Y_{K-1})</cite>, the output will have shape <cite>(X_0, X_1, ..., X_{N-1})</cite>,
where <cite>M <= N</cite>. If <cite>M == N</cite>, data shape should simply be <cite>(Y_0, ..., Y_{K-1})</cite>.</p>
<p>The elements in output is defined as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">output</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">y_</span><span class="p">{</span><span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">}],</span>
       <span class="o">...</span><span class="p">,</span>
       <span class="n">indices</span><span class="p">[</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y_0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">y_</span><span class="p">{</span><span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">}],</span>
       <span class="n">x_M</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">x_</span><span class="p">{</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">}]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">y_0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">y_</span><span class="p">{</span><span class="n">K</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="n">x_M</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">x_</span><span class="p">{</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">}]</span>
</pre></div>
</div>
<p>all other entries in output are 0.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If the indices have duplicates, the result will be non-deterministic and
the gradient of <cite>scatter_nd</cite> will not be correct!!</p>
</div>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">indices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">scatter_nd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>

<span class="n">data</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]]</span>
<span class="n">indices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">scatter_nd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>

                                     <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                                      <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]],</span>

                                    <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>

                                     <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
                                      <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]]]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – data</li>
<li><strong>indices</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – indices</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>required</em>) – Shape of output.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sgd_mom_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sgd_mom_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>mom=None</em>, <em>lr=_Null</em>, <em>momentum=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>lazy_update=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sgd_mom_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Momentum update function for Stochastic Gradient Descent (SGD) optimizer.</p>
<p>Momentum update has better convergence rates on neural networks. Mathematically it looks
like below:</p>
<div class="math">
\[\begin{split}v_1 = \alpha * \nabla J(W_0)\\
v_t = \gamma v_{t-1} - \alpha * \nabla J(W_{t-1})\\
W_t = W_{t-1} + v_t\end{split}\]</div>
<p>It updates the weights using:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">momentum</span> <span class="o">*</span> <span class="n">v</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">gradient</span>
<span class="n">weight</span> <span class="o">+=</span> <span class="n">v</span>
</pre></div>
</div>
<p>Where the parameter <code class="docutils literal"><span class="pre">momentum</span></code> is the decay rate of momentum estimates at each epoch.</p>
<p>However, if grad’s storage type is <code class="docutils literal"><span class="pre">row_sparse</span></code>, <code class="docutils literal"><span class="pre">lazy_update</span></code> is True and weight’s storage
type is the same as momentum’s storage type,
only the row slices whose indices appear in grad.indices are updated (for both weight and momentum):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">gradient</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="n">v</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">momentum</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">gradient</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
    <span class="n">weight</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/optimizer_op.cc:L563</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Gradient</li>
<li><strong>mom</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Momentum</li>
<li><strong>lr</strong> (<em>float</em><em>, </em><em>required</em>) – Learning rate</li>
<li><strong>momentum</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – The decay rate of momentum estimates at each epoch.</li>
<li><strong>wd</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>lazy_update</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – If true, lazy updates are applied if gradient’s stype is row_sparse and both weight and momentum have the same stype</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sgd_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sgd_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>lr=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>lazy_update=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sgd_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update function for Stochastic Gradient Descent (SGD) optimizer.</p>
<p>It updates the weights using:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="p">(</span><span class="n">gradient</span> <span class="o">+</span> <span class="n">wd</span> <span class="o">*</span> <span class="n">weight</span><span class="p">)</span>
</pre></div>
</div>
<p>However, if gradient is of <code class="docutils literal"><span class="pre">row_sparse</span></code> storage type and <code class="docutils literal"><span class="pre">lazy_update</span></code> is True,
only the row slices whose indices appear in grad.indices are updated:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">gradient</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="n">weight</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="p">(</span><span class="n">gradient</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">+</span> <span class="n">wd</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">row</span><span class="p">])</span>
</pre></div>
</div>
<p>Defined in src/operator/optimizer_op.cc:L522</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Gradient</li>
<li><strong>lr</strong> (<em>float</em><em>, </em><em>required</em>) – Learning rate</li>
<li><strong>wd</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>lazy_update</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – If true, lazy updates are applied if gradient’s stype is row_sparse.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.shape_array">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">shape_array</code><span class="sig-paren">(</span><em>data=None</em>, <em>lhs_begin=_Null</em>, <em>lhs_end=_Null</em>, <em>rhs_begin=_Null</em>, <em>rhs_end=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.shape_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 1D int64 array containing the shape of data.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">shape_array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]])</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L544</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input Array.</li>
<li><strong>lhs_begin</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default='None'</em>) – Defaults to 0. The beginning index along which the lhs dimensions are to be reshaped. Supports negative indices.</li>
<li><strong>lhs_end</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default='None'</em>) – Defaults to None. The ending index along which the lhs dimensions are to be used for reshaping. Supports negative indices.</li>
<li><strong>rhs_begin</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default='None'</em>) – Defaults to 0. The beginning index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</li>
<li><strong>rhs_end</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default='None'</em>) – Defaults to None. The ending index along which the rhs dimensions are to be used for reshaping. Supports negative indices.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.shuffle">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">shuffle</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.shuffle" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly shuffle the elements.</p>
<p>This shuffles the array along the first axis.
The order of the elements in each subarray does not change.
For example, if a 2D array is given, the order of the rows randomly changes,
but the order of the elements in each row does not change.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Data to be shuffled.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sigmoid">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sigmoid</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes sigmoid of x element-wise.</p>
<div class="math">
\[y = 1 / (1 + exp(-x))\]</div>
<p>The storage type of <code class="docutils literal"><span class="pre">sigmoid</span></code> output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L119</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sign">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sign</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise sign of the input.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">sign</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">sign</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>sign(default) = default</li>
<li>sign(row_sparse) = row_sparse</li>
<li>sign(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L727</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.signsgd_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">signsgd_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>lr=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.signsgd_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update function for SignSGD optimizer.</p>
<div class="math">
\[\begin{split}g_t = \nabla J(W_{t-1})\\
W_t = W_{t-1} - \eta_t \text{sign}(g_t)\end{split}\]</div>
<p>It updates the weights using:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">-</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">sign</span><span class="p">(</span><span class="n">gradient</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>sparse ndarray not supported for this optimizer yet.</li>
</ul>
</div>
<p>Defined in src/operator/optimizer_op.cc:L61</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Gradient</li>
<li><strong>lr</strong> (<em>float</em><em>, </em><em>required</em>) – Learning rate</li>
<li><strong>wd</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.signum_update">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">signum_update</code><span class="sig-paren">(</span><em>weight=None</em>, <em>grad=None</em>, <em>mom=None</em>, <em>lr=_Null</em>, <em>momentum=_Null</em>, <em>wd=_Null</em>, <em>rescale_grad=_Null</em>, <em>clip_gradient=_Null</em>, <em>wd_lh=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.signum_update" title="Permalink to this definition">¶</a></dt>
<dd><p>SIGN momentUM (Signum) optimizer.</p>
<div class="math">
\[\begin{split}g_t = \nabla J(W_{t-1})\\
m_t = \beta m_{t-1} + (1 - \beta) g_t\\
W_t = W_{t-1} - \eta_t \text{sign}(m_t)\end{split}\]</div>
<dl class="docutils">
<dt>It updates the weights using::</dt>
<dd>state = momentum * state + (1-momentum) * gradient
weight = weight - learning_rate * sign(state)</dd>
</dl>
<p>Where the parameter <code class="docutils literal"><span class="pre">momentum</span></code> is the decay rate of momentum estimates at each epoch.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>sparse ndarray not supported for this optimizer yet.</li>
</ul>
</div>
<p>Defined in src/operator/optimizer_op.cc:L90</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weight</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Weight</li>
<li><strong>grad</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Gradient</li>
<li><strong>mom</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Momentum</li>
<li><strong>lr</strong> (<em>float</em><em>, </em><em>required</em>) – Learning rate</li>
<li><strong>momentum</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – The decay rate of momentum estimates at each epoch.</li>
<li><strong>wd</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight.</li>
<li><strong>rescale_grad</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Rescale gradient to grad = rescale_grad*grad.</li>
<li><strong>clip_gradient</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient).</li>
<li><strong>wd_lh</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – The amount of weight decay that does not go into gradient/momentum calculationsotherwise do weight decay algorithmically only.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sin">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sin</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the element-wise sine of the input array.</p>
<p>The input should be in radians (<span class="math">\(2\pi\)</span> rad equals 360 degrees).</p>
<div class="math">
\[sin([0, \pi/4, \pi/2]) = [0, 0.707, 1]\]</div>
<p>The storage type of <code class="docutils literal"><span class="pre">sin</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>sin(default) = default</li>
<li>sin(row_sparse) = row_sparse</li>
<li>sin(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L46</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sinh">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sinh</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the hyperbolic sine of the input array, computed element-wise.</p>
<div class="math">
\[sinh(x) = 0.5\times(exp(x) - exp(-x))\]</div>
<p>The storage type of <code class="docutils literal"><span class="pre">sinh</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>sinh(default) = default</li>
<li>sinh(row_sparse) = row_sparse</li>
<li>sinh(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L257</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.size_array">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">size_array</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.size_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 1D int64 array containing the size of data.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">size_array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]])</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L596</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input Array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.slice">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">slice</code><span class="sig-paren">(</span><em>data=None</em>, <em>begin=_Null</em>, <em>end=_Null</em>, <em>step=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Slices a region of the array.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">crop</span></code> is deprecated. Use <code class="docutils literal"><span class="pre">slice</span></code> instead.</p>
</div>
<p>This function returns a sliced array between the indices given
by <cite>begin</cite> and <cite>end</cite> with the corresponding <cite>step</cite>.</p>
<p>For an input array of <code class="docutils literal"><span class="pre">shape=(d_0,</span> <span class="pre">d_1,</span> <span class="pre">...,</span> <span class="pre">d_n-1)</span></code>,
slice operation with <code class="docutils literal"><span class="pre">begin=(b_0,</span> <span class="pre">b_1...b_m-1)</span></code>,
<code class="docutils literal"><span class="pre">end=(e_0,</span> <span class="pre">e_1,</span> <span class="pre">...,</span> <span class="pre">e_m-1)</span></code>, and <code class="docutils literal"><span class="pre">step=(s_0,</span> <span class="pre">s_1,</span> <span class="pre">...,</span> <span class="pre">s_m-1)</span></code>,
where m <= n, results in an array with the shape
<code class="docutils literal"><span class="pre">(|e_0-b_0|/|s_0|,</span> <span class="pre">...,</span> <span class="pre">|e_m-1-b_m-1|/|s_m-1|,</span> <span class="pre">d_m,</span> <span class="pre">...,</span> <span class="pre">d_n-1)</span></code>.</p>
<p>The resulting array’s <em>k</em>-th dimension contains elements
from the <em>k</em>-th dimension of the input array starting
from index <code class="docutils literal"><span class="pre">b_k</span></code> (inclusive) with step <code class="docutils literal"><span class="pre">s_k</span></code>
until reaching <code class="docutils literal"><span class="pre">e_k</span></code> (exclusive).</p>
<p>If the <em>k</em>-th elements are <cite>None</cite> in the sequence of <cite>begin</cite>, <cite>end</cite>,
and <cite>step</cite>, the following rule will be used to set default values.
If <cite>s_k</cite> is <cite>None</cite>, set <cite>s_k=1</cite>. If <cite>s_k > 0</cite>, set <cite>b_k=0</cite>, <cite>e_k=d_k</cite>;
else, set <cite>b_k=d_k-1</cite>, <cite>e_k=-1</cite>.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">slice</span></code> output depends on storage types of inputs</p>
<ul class="simple">
<li>slice(csr) = csr</li>
<li>otherwise, <code class="docutils literal"><span class="pre">slice</span></code> generates output with default storage</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When input data storage type is csr, it only supports
step=(), or step=(None,), or step=(1,) to generate a csr output.
For other step parameter values, it falls back to slicing
a dense tensor.</p>
</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">,</span>   <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">,</span>   <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">9.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]]</span>

<span class="nb">slice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                                   <span class="p">[</span> <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]</span>
<span class="nb">slice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">step</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">9.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">],</span>
                                                          <span class="p">[</span><span class="mf">5.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">],</span>
                                                          <span class="p">[</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L506</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Source input</li>
<li><strong>begin</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>required</em>) – starting indices for the slice operation, supports negative indices.</li>
<li><strong>end</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>required</em>) – ending indices for the slice operation, supports negative indices.</li>
<li><strong>step</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – step for the slice operation, supports negative values.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.slice_axis">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">slice_axis</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>begin=_Null</em>, <em>end=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.slice_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Slices along a given axis.</p>
<p>Returns an array slice along a given <cite>axis</cite> starting from the <cite>begin</cite> index
to the <cite>end</cite> index.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">,</span>   <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">,</span>   <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">9.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]]</span>

<span class="n">slice_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">,</span>   <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">],</span>
                                         <span class="p">[</span>  <span class="mf">9.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]]</span>

<span class="n">slice_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">],</span>
                                         <span class="p">[</span>  <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">],</span>
                                         <span class="p">[</span>  <span class="mf">9.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">]]</span>

<span class="n">slice_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">begin</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span> <span class="n">end</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">],</span>
                                           <span class="p">[</span>  <span class="mf">6.</span><span class="p">,</span>   <span class="mf">7.</span><span class="p">],</span>
                                           <span class="p">[</span> <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L596</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Source input</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>required</em>) – Axis along which to be sliced, supports negative indexes.</li>
<li><strong>begin</strong> (<em>int</em><em>, </em><em>required</em>) – The beginning index along the axis to be sliced,  supports negative indexes.</li>
<li><strong>end</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>required</em>) – The ending index along the axis to be sliced,  supports negative indexes.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.slice_like">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">slice_like</code><span class="sig-paren">(</span><em>data=None</em>, <em>shape_like=None</em>, <em>axes=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.slice_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Slices a region of the array like the shape of another array.</p>
<p>This function is similar to <code class="docutils literal"><span class="pre">slice</span></code>, however, the <cite>begin</cite> are always <cite>0`s
and `end</cite> of specific axes are inferred from the second input <cite>shape_like</cite>.</p>
<p>Given the second <cite>shape_like</cite> input of <code class="docutils literal"><span class="pre">shape=(d_0,</span> <span class="pre">d_1,</span> <span class="pre">...,</span> <span class="pre">d_n-1)</span></code>,
a <code class="docutils literal"><span class="pre">slice_like</span></code> operator with default empty <cite>axes</cite>, it performs the
following operation:</p>
<p>`` out = slice(input, begin=(0, 0, ..., 0), end=(d_0, d_1, ..., d_n-1))``.</p>
<p>When <cite>axes</cite> is not empty, it is used to speficy which axes are being sliced.</p>
<p>Given a 4-d input data, <code class="docutils literal"><span class="pre">slice_like</span></code> operator with <code class="docutils literal"><span class="pre">axes=(0,</span> <span class="pre">2,</span> <span class="pre">-1)</span></code>
will perform the following operation:</p>
<p>`` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.</p>
<p>Note that it is allowed to have first and second input with different dimensions,
however, you have to make sure the <cite>axes</cite> are specified and not exceeding the
dimension limits.</p>
<p>For example, given <cite>input_1</cite> with <code class="docutils literal"><span class="pre">shape=(2,3,4,5)</span></code> and <cite>input_2</cite> with
<code class="docutils literal"><span class="pre">shape=(1,2,3)</span></code>, it is not allowed to use:</p>
<p>`` out = slice_like(a, b)`` because ndim of <cite>input_1</cite> is 4, and ndim of <cite>input_2</cite>
is 3.</p>
<p>The following is allowed in this situation:</p>
<p>`` out = slice_like(a, b, axes=(0, 2))``</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">,</span>   <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">,</span>   <span class="mf">7.</span><span class="p">,</span>   <span class="mf">8.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">9.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">,</span>  <span class="mf">12.</span><span class="p">]]</span>

<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">0.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">],</span>
     <span class="p">[</span>  <span class="mf">0.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">,</span>   <span class="mf">0.</span><span class="p">]]</span>

<span class="n">slice_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">]</span>
                    <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">]]</span>
<span class="n">slice_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">]</span>
                                 <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">]]</span>
<span class="n">slice_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]</span>
                              <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]</span>
<span class="n">slice_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span>  <span class="mf">1.</span><span class="p">,</span>   <span class="mf">2.</span><span class="p">,</span>   <span class="mf">3.</span><span class="p">]</span>
                               <span class="p">[</span>  <span class="mf">5.</span><span class="p">,</span>   <span class="mf">6.</span><span class="p">,</span>   <span class="mf">7.</span><span class="p">]</span>
                               <span class="p">[</span>  <span class="mf">9.</span><span class="p">,</span>  <span class="mf">10.</span><span class="p">,</span>  <span class="mf">11.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L665</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Source input</li>
<li><strong>shape_like</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Shape like input</li>
<li><strong>axes</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – List of axes on which input data will be sliced according to the corresponding size of the second input. By default will slice on all axes. Negative axes are supported.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.smooth_l1">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">smooth_l1</code><span class="sig-paren">(</span><em>data=None</em>, <em>scalar=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.smooth_l1" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Smooth L1 Loss(lhs, scalar) by summing</p>
<div class="math">
\[\begin{split}f(x) =
\begin{cases}
(\sigma x)^2/2,&amp; \text{if }x < 1/\sigma^2\\
|x|-0.5/\sigma^2,&amp; \text{otherwise}
\end{cases}\end{split}\]</div>
<p>where <span class="math">\(x\)</span> is an element of the tensor <em>lhs</em> and <span class="math">\(\sigma\)</span> is the scalar.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">smooth_l1</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">]</span>
<span class="n">smooth_l1</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">scalar</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_binary_scalar_op_extended.cc:L104</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – source input</li>
<li><strong>scalar</strong> (<em>float</em>) – scalar input</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.softmax">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">softmax</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>temperature=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the softmax function.</p>
<p>The resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.</p>
<div class="math">
\[softmax(\mathbf{z/t})_j = \frac{e^{z_j/t}}{\sum_{k=1}^K e^{z_k/t}}\]</div>
<p>for <span class="math">\(j = 1, ..., K\)</span></p>
<p>t is the temperature parameter in softmax function. By default, t equals 1.0</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]</span>
     <span class="p">[</span> <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">softmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.5</span>  <span class="mf">0.5</span>  <span class="mf">0.5</span><span class="p">]</span>
                     <span class="p">[</span> <span class="mf">0.5</span>  <span class="mf">0.5</span>  <span class="mf">0.5</span><span class="p">]]</span>

<span class="n">softmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.33333334</span><span class="p">,</span>  <span class="mf">0.33333334</span><span class="p">,</span>  <span class="mf">0.33333334</span><span class="p">],</span>
                     <span class="p">[</span> <span class="mf">0.33333334</span><span class="p">,</span>  <span class="mf">0.33333334</span><span class="p">,</span>  <span class="mf">0.33333334</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/nn/softmax.cc:L93</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='-1'</em>) – The axis along which to compute softmax.</li>
<li><strong>temperature</strong> (<em>double</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Temperature parameter in softmax</li>
<li><strong>dtype</strong> (<em>{None</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to the same as input’s dtype if not defined (dtype=None).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.softmax_cross_entropy">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">softmax_cross_entropy</code><span class="sig-paren">(</span><em>data=None</em>, <em>label=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.softmax_cross_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate cross entropy of softmax output and one-hot label.</p>
<ul>
<li><p class="first">This operator computes the cross entropy in two steps:
- Applies softmax function on the input array.
- Computes and returns the cross entropy loss between the softmax output and the labels.</p>
</li>
<li><p class="first">The softmax function and cross entropy loss is given by:</p>
<ul class="simple">
<li>Softmax Function:</li>
</ul>
<div class="math">
\[\text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}\]</div>
<ul class="simple">
<li>Cross Entropy Function:</li>
</ul>
<div class="math">
\[\text{CE(label, output)} = - \sum_i \text{label}_i \log(\text{output}_i)\]</div>
</li>
</ul>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>

<span class="n">label</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="n">softmax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.09003057</span><span class="p">,</span> <span class="mf">0.24472848</span><span class="p">,</span> <span class="mf">0.66524094</span><span class="p">],</span>
              <span class="p">[</span><span class="mf">0.97962922</span><span class="p">,</span> <span class="mf">0.01794253</span><span class="p">,</span> <span class="mf">0.00242826</span><span class="p">]]</span>

<span class="n">softmax_cross_entropy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="mf">0.66524084</span><span class="p">)</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="mf">0.97962922</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.4281871</span>
</pre></div>
</div>
<p>Defined in src/operator/loss_binary_op.cc:L59</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data</li>
<li><strong>label</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input label</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.softmin">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">softmin</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>temperature=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.softmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the softmin function.</p>
<p>The resulting array contains elements in the range (0,1) and the elements along the given axis sum
up to 1.</p>
<div class="math">
\[softmin(\mathbf{z/t})_j = \frac{e^{-z_j/t}}{\sum_{k=1}^K e^{-z_k/t}}\]</div>
<p>for <span class="math">\(j = 1, ..., K\)</span></p>
<p>t is the temperature parameter in softmax function. By default, t equals 1.0</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span>  <span class="mf">2.</span>  <span class="mf">3.</span><span class="p">]</span>
     <span class="p">[</span> <span class="mf">3.</span>  <span class="mf">2.</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">softmin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.88079703</span><span class="p">,</span>  <span class="mf">0.5</span><span class="p">,</span>  <span class="mf">0.11920292</span><span class="p">],</span>
                     <span class="p">[</span> <span class="mf">0.11920292</span><span class="p">,</span>  <span class="mf">0.5</span><span class="p">,</span>  <span class="mf">0.88079703</span><span class="p">]]</span>

<span class="n">softmin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.66524094</span><span class="p">,</span>  <span class="mf">0.24472848</span><span class="p">,</span>  <span class="mf">0.09003057</span><span class="p">],</span>
                     <span class="p">[</span> <span class="mf">0.09003057</span><span class="p">,</span>  <span class="mf">0.24472848</span><span class="p">,</span>  <span class="mf">0.66524094</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/nn/softmax.cc:L153</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='-1'</em>) – The axis along which to compute softmax.</li>
<li><strong>temperature</strong> (<em>double</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Temperature parameter in softmax</li>
<li><strong>dtype</strong> (<em>{None</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to the same as input’s dtype if not defined (dtype=None).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.softsign">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">softsign</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.softsign" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes softsign of x element-wise.</p>
<div class="math">
\[y = x / (1 + abs(x))\]</div>
<p>The storage type of <code class="docutils literal"><span class="pre">softsign</span></code> output is always dense</p>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L163</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sort">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sort</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>is_ascend=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sorted copy of an input array along the given axis.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
     <span class="p">[</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">sorts</span> <span class="n">along</span> <span class="n">the</span> <span class="n">last</span> <span class="n">axis</span>
<span class="n">sort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
           <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">flattens</span> <span class="ow">and</span> <span class="n">then</span> <span class="n">sorts</span>
<span class="n">sort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]</span>

<span class="o">//</span> <span class="n">sorts</span> <span class="n">along</span> <span class="n">the</span> <span class="n">first</span> <span class="n">axis</span>
<span class="n">sort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                   <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>

<span class="o">//</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">descend</span> <span class="n">order</span>
<span class="n">sort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">is_ascend</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/ordering_op.cc:L127</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array</li>
<li><strong>axis</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default='-1'</em>) – Axis along which to choose sort the input tensor. If not given, the flattened array is used. Default is -1.</li>
<li><strong>is_ascend</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Whether to sort in ascending or descending order.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.space_to_depth">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">space_to_depth</code><span class="sig-paren">(</span><em>data=None</em>, <em>block_size=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.space_to_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Rearranges(permutes) blocks of spatial data into depth.
Similar to ONNX SpaceToDepth operator:
<a class="reference external" href="https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth">https://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth</a></p>
<p>The output is a new tensor where the values from height and width dimension are
moved to the depth dimension. The reverse of this operation is <code class="docutils literal"><span class="pre">depth_to_space</span></code>.</p>
<div class="math">
\[\begin{split}\begin{gather*}
x \prime = reshape(x, [N, C, H / block\_size, block\_size, W / block\_size, block\_size]) \\
x \prime \prime = transpose(x \prime, [0, 3, 5, 1, 2, 4]) \\
y = reshape(x \prime \prime, [N, C * (block\_size ^ 2), H / block\_size, W / block\_size])
\end{gather*}\end{split}\]</div>
<p>where <span class="math">\(x\)</span> is an input tensor with default layout as <span class="math">\([N, C, H, W]\)</span>: [batch, channels, height, width]
and <span class="math">\(y\)</span> is the output tensor of layout <span class="math">\([N, C * (block\_size ^ 2), H / block\_size, W / block\_size]\)</span></p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">23</span><span class="p">]]]]</span>


<span class="n">space_to_depth</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span>
                         <span class="p">[[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]],</span>
                         <span class="p">[[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">]],</span>
                         <span class="p">[[</span><span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">]]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L1104</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input ndarray</li>
<li><strong>block_size</strong> (<em>int</em><em>, </em><em>required</em>) – Blocks of [block_size. block_size] are moved</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.split">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">split</code><span class="sig-paren">(</span><em>data=None</em>, <em>num_outputs=_Null</em>, <em>axis=_Null</em>, <em>squeeze_axis=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits an array along a particular axis into multiple sub-arrays.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">SliceChannel</span></code> is deprecated. Use <code class="docutils literal"><span class="pre">split</span></code> instead.</p>
</div>
<p><strong>Note</strong> that <cite>num_outputs</cite> should evenly divide the length of the axis
along which to split the array.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span>  <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">]</span>
       <span class="p">[</span> <span class="mf">2.</span><span class="p">]]</span>
      <span class="p">[[</span> <span class="mf">3.</span><span class="p">]</span>
       <span class="p">[</span> <span class="mf">4.</span><span class="p">]]</span>
      <span class="p">[[</span> <span class="mf">5.</span><span class="p">]</span>
       <span class="p">[</span> <span class="mf">6.</span><span class="p">]]]</span>
<span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="mi">2</span> <span class="n">arrays</span> <span class="k">with</span> <span class="n">shape</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">]]</span>
     <span class="p">[[</span> <span class="mf">3.</span><span class="p">]]</span>
     <span class="p">[[</span> <span class="mf">5.</span><span class="p">]]]</span>

    <span class="p">[[[</span> <span class="mf">2.</span><span class="p">]]</span>
     <span class="p">[[</span> <span class="mf">4.</span><span class="p">]]</span>
     <span class="p">[[</span> <span class="mf">6.</span><span class="p">]]]</span>

<span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">//</span> <span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="mi">3</span> <span class="n">arrays</span> <span class="k">with</span> <span class="n">shape</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">]</span>
      <span class="p">[</span> <span class="mf">2.</span><span class="p">]]]</span>

    <span class="p">[[[</span> <span class="mf">3.</span><span class="p">]</span>
      <span class="p">[</span> <span class="mf">4.</span><span class="p">]]]</span>

    <span class="p">[[[</span> <span class="mf">5.</span><span class="p">]</span>
      <span class="p">[</span> <span class="mf">6.</span><span class="p">]]]</span>

<span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><cite>squeeze_axis=1</cite> removes the axis with length 1 from the shapes of the output arrays.
<strong>Note</strong> that setting <cite>squeeze_axis</cite> to <code class="docutils literal"><span class="pre">1</span></code> removes axis with length 1 only
along the <cite>axis</cite> which it is split.
Also <cite>squeeze_axis</cite> can be set to true only if <code class="docutils literal"><span class="pre">input.shape[axis]</span> <span class="pre">==</span> <span class="pre">num_outputs</span></code>.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">squeeze_axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="mi">3</span> <span class="n">arrays</span> <span class="k">with</span> <span class="n">shape</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">]</span>
     <span class="p">[</span> <span class="mf">2.</span><span class="p">]]</span>

    <span class="p">[[</span> <span class="mf">3.</span><span class="p">]</span>
     <span class="p">[</span> <span class="mf">4.</span><span class="p">]]</span>

    <span class="p">[[</span> <span class="mf">5.</span><span class="p">]</span>
     <span class="p">[</span> <span class="mf">6.</span><span class="p">]]</span>
<span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="p">,</span><span class="mi">1</span> <span class="p">)</span>
</pre></div>
</div>
<p>Defined in src/operator/slice_channel.cc:L107</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>num_outputs</strong> (<em>int</em><em>, </em><em>required</em>) – Number of splits. Note that this should evenly divide the length of the <cite>axis</cite>.</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='1'</em>) – Axis along which to split.</li>
<li><strong>squeeze_axis</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If true, Removes the axis with length 1 from the shapes of the output arrays. <strong>Note</strong> that setting <cite>squeeze_axis</cite> to <code class="docutils literal"><span class="pre">true</span></code> removes axis with length 1 only along the <cite>axis</cite> which it is split. Also <cite>squeeze_axis</cite> can be set to <code class="docutils literal"><span class="pre">true</span></code> only if <code class="docutils literal"><span class="pre">input.shape[axis]</span> <span class="pre">==</span> <span class="pre">num_outputs</span></code>.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sqrt">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sqrt</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise square-root value of the input.</p>
<div class="math">
\[\textrm{sqrt}(x) = \sqrt{x}\]</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">sqrt</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">sqrt</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>sqrt(default) = default</li>
<li>sqrt(row_sparse) = row_sparse</li>
<li>sqrt(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L907</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.square">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">square</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.square" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise squared value of the input.</p>
<div class="math">
\[square(x) = x^2\]</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">square</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">]</span>
</pre></div>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">square</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>square(default) = default</li>
<li>square(row_sparse) = row_sparse</li>
<li>square(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L883</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.squeeze">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">squeeze</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove single-dimensional entries from the shape of an array.
Same behavior of defining the output tensor shape as numpy.squeeze for the most of cases.
See the following note for exception.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]]]</span>
<span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
<span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The output of this operator will keep at least one dimension not removed. For example,
squeeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>[</em><em>]</em>) – data to squeeze</li>
<li><strong>axis</strong> (<em>Shape</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.stack">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">stack</code><span class="sig-paren">(</span><em>*data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Join a sequence of arrays along a new axis.</p>
<p>The axis parameter specifies the index of the new axis in the dimensions of the
result. For example, if axis=0 it will be the first dimension and if axis=-1 it
will be the last dimension.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="n">stack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="n">stack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
                       <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>[</em><em>]</em>) – List of arrays to stack</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='0'</em>) – The axis in the result array along which the input arrays are stacked.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.stop_gradient">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">stop_gradient</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.stop_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Stops gradient computation.</p>
<p>Stops the accumulated gradient of the inputs from flowing through this operator
in the backward direction. In other words, this operator prevents the contribution
of its inputs to be taken into account for computing gradients.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">v1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">v2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="n">b_stop_grad</span> <span class="o">=</span> <span class="n">stop_gradient</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
<span class="n">loss</span> <span class="o">=</span> <span class="n">MakeLoss</span><span class="p">(</span><span class="n">b_stop_grad</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span>

<span class="n">executor</span> <span class="o">=</span> <span class="n">loss</span><span class="o">.</span><span class="n">simple_bind</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">a</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">executor</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">is_train</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">v1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">v2</span><span class="p">)</span>
<span class="n">executor</span><span class="o">.</span><span class="n">outputs</span>
<span class="p">[</span> <span class="mf">1.</span>  <span class="mf">5.</span><span class="p">]</span>

<span class="n">executor</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="n">executor</span><span class="o">.</span><span class="n">grad_arrays</span>
<span class="p">[</span> <span class="mf">0.</span>  <span class="mf">0.</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L299</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sum">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sum</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the sum of array elements over given axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>sum</cite> and <cite>sum_axis</cite> are equivalent.
For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
Setting keepdims or exclude to True will cause a fallback to dense operator.</p>
</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span>
        <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
        <span class="p">[[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]]</span>

<span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="p">[[</span>  <span class="mf">4.</span>   <span class="mf">8.</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">10.</span>   <span class="mf">9.</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">21.</span>   <span class="mf">6.</span><span class="p">]]</span>

<span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="p">[</span> <span class="mf">12.</span>  <span class="mf">19.</span>  <span class="mf">27.</span><span class="p">]</span>

<span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

<span class="n">csr</span> <span class="o">=</span> <span class="n">cast_storage</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">'csr'</span><span class="p">)</span>

<span class="nb">sum</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="p">[</span> <span class="mf">8.</span>  <span class="mf">3.</span>  <span class="mf">1.</span><span class="p">]</span>

<span class="nb">sum</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="p">[</span> <span class="mf">3.</span>  <span class="mf">4.</span>  <span class="mf">5.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L116</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – <p>The axis or axes along which to perform the reduction.</p>
<blockquote>
<div>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</div></blockquote>
</li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.sum_axis">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">sum_axis</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>keepdims=_Null</em>, <em>exclude=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.sum_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the sum of array elements over given axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>sum</cite> and <cite>sum_axis</cite> are equivalent.
For ndarray of csr storage type summation along axis 0 and axis 1 is supported.
Setting keepdims or exclude to True will cause a fallback to dense operator.</p>
</div>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span>
        <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
        <span class="p">[[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]]</span>

<span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="p">[[</span>  <span class="mf">4.</span>   <span class="mf">8.</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">10.</span>   <span class="mf">9.</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">21.</span>   <span class="mf">6.</span><span class="p">]]</span>

<span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="p">[</span> <span class="mf">12.</span>  <span class="mf">19.</span>  <span class="mf">27.</span><span class="p">]</span>

<span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

<span class="n">csr</span> <span class="o">=</span> <span class="n">cast_storage</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">'csr'</span><span class="p">)</span>

<span class="nb">sum</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="p">[</span> <span class="mf">8.</span>  <span class="mf">3.</span>  <span class="mf">1.</span><span class="p">]</span>

<span class="nb">sum</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="p">[</span> <span class="mf">3.</span>  <span class="mf">4.</span>  <span class="mf">5.</span><span class="p">]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/broadcast_reduce_op_value.cc:L116</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>axis</strong> (<em>Shape</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – <p>The axis or axes along which to perform the reduction.</p>
<blockquote>
<div>The default, <cite>axis=()</cite>, will compute over all elements into a
scalar array with shape <cite>(1,)</cite>.<p>If <cite>axis</cite> is int, a reduction is performed on a particular axis.</p>
<p>If <cite>axis</cite> is a tuple of ints, a reduction is performed on all the axes
specified in the tuple.</p>
<p>If <cite>exclude</cite> is true, reduction will be performed on the axes that are
NOT in axis instead.</p>
<p>Negative values means indexing from right to left.</p>
</div></blockquote>
</li>
<li><strong>keepdims</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – If this is set to <cite>True</cite>, the reduced axes are left in the result as dimension with size one.</li>
<li><strong>exclude</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to perform reduction on axis that are NOT in axis instead.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.swapaxes">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">swapaxes</code><span class="sig-paren">(</span><em>data=None</em>, <em>dim1=_Null</em>, <em>dim2=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Interchanges two axes of an array.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span> <span class="n">x</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
 <span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mi">1</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mi">2</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mi">3</span><span class="p">]]</span>

 <span class="n">x</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span>
      <span class="p">[[</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]]</span>  <span class="o">//</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="n">array</span>

<span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span>
                     <span class="p">[[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/swapaxis.cc:L70</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input array.</li>
<li><strong>dim1</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – the first axis to be swapped.</li>
<li><strong>dim2</strong> (<em>int</em><em> (</em><em>non-negative</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – the second axis to be swapped.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.take">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">take</code><span class="sig-paren">(</span><em>a=None</em>, <em>indices=None</em>, <em>axis=_Null</em>, <em>mode=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes elements from an input array along the given axis.</p>
<p>This function slices the input array along a particular axis with the provided indices.</p>
<p>Given data tensor of rank r >= 1, and indices tensor of rank q, gather entries of the axis
dimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them
in an output tensor of rank q + (r - 1).</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mf">4.</span>  <span class="mf">5.</span>  <span class="mf">6.</span><span class="p">]</span>

<span class="o">//</span> <span class="n">Trivial</span> <span class="n">case</span><span class="p">,</span> <span class="n">take</span> <span class="n">the</span> <span class="n">second</span> <span class="n">element</span> <span class="n">along</span> <span class="n">the</span> <span class="n">first</span> <span class="n">axis</span><span class="o">.</span>

<span class="n">take</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">5.</span> <span class="p">]</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">other</span> <span class="n">trivial</span> <span class="n">case</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">take</span> <span class="n">the</span> <span class="n">third</span> <span class="n">element</span> <span class="n">along</span> <span class="n">the</span> <span class="n">first</span> <span class="n">axis</span>

<span class="n">take</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'clip'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">6.</span> <span class="p">]</span>

<span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">In</span> <span class="n">this</span> <span class="n">case</span> <span class="n">we</span> <span class="n">will</span> <span class="n">get</span> <span class="n">rows</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">1</span><span class="p">,</span> <span class="n">then</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mf">2.</span> <span class="n">Along</span> <span class="n">axis</span> <span class="mi">0</span>

<span class="n">take</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                           <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]],</span>

                          <span class="p">[[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                           <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">]]]</span>

<span class="o">//</span> <span class="n">In</span> <span class="n">this</span> <span class="n">case</span> <span class="n">we</span> <span class="n">will</span> <span class="n">get</span> <span class="n">rows</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">1</span><span class="p">,</span> <span class="n">then</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">2</span> <span class="p">(</span><span class="n">calculated</span> <span class="n">by</span> <span class="n">wrapping</span> <span class="n">around</span><span class="p">)</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Along</span> <span class="n">axis</span> <span class="mi">1</span>

<span class="n">take</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'wrap'</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span>  <span class="mf">2.</span><span class="p">]</span>
                                                     <span class="p">[</span> <span class="mf">2.</span>  <span class="mf">1.</span><span class="p">]]</span>

                                                    <span class="p">[[</span> <span class="mf">3.</span>  <span class="mf">4.</span><span class="p">]</span>
                                                     <span class="p">[</span> <span class="mf">4.</span>  <span class="mf">3.</span><span class="p">]]</span>

                                                    <span class="p">[[</span> <span class="mf">5.</span>  <span class="mf">6.</span><span class="p">]</span>
                                                     <span class="p">[</span> <span class="mf">6.</span>  <span class="mf">5.</span><span class="p">]]]</span>
</pre></div>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">take</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>take(default, default) = default</li>
<li>take(csr, default, axis=0) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/indexing_op.cc:L695</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>indices</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The indices of the values to be extracted.</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='0'</em>) – The axis of input array to be taken.For input tensor of rank r, it could be in the range of [-r, r-1]</li>
<li><strong>mode</strong> (<em>{'clip'</em><em>, </em><em>'raise'</em><em>, </em><em>'wrap'}</em><em>,</em><em>optional</em><em>, </em><em>default='clip'</em>) – Specify how out-of-bound indices bahave. Default is “clip”. “clip” means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  “wrap” means to wrap around.  “raise” means to raise an error, not supported yet.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.tan">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">tan</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.tan" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the element-wise tangent of the input array.</p>
<p>The input should be in radians (<span class="math">\(2\pi\)</span> rad equals 360 degrees).</p>
<div class="math">
\[tan([0, \pi/4, \pi/2]) = [0, 1, -inf]\]</div>
<p>The storage type of <code class="docutils literal"><span class="pre">tan</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>tan(default) = default</li>
<li>tan(row_sparse) = row_sparse</li>
<li>tan(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L139</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.tanh">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">tanh</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.tanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the hyperbolic tangent of the input array, computed element-wise.</p>
<div class="math">
\[tanh(x) = sinh(x) / cosh(x)\]</div>
<p>The storage type of <code class="docutils literal"><span class="pre">tanh</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>tanh(default) = default</li>
<li>tanh(row_sparse) = row_sparse</li>
<li>tanh(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_trig.cc:L290</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.tile">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">tile</code><span class="sig-paren">(</span><em>data=None</em>, <em>reps=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeats the whole array multiple times.</p>
<p>If <code class="docutils literal"><span class="pre">reps</span></code> has length <em>d</em>, and input array has dimension of <em>n</em>. There are
three cases:</p>
<ul>
<li><p class="first"><strong>n=d</strong>. Repeat <em>i</em>-th dimension of the input by <code class="docutils literal"><span class="pre">reps[i]</span></code> times:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
     <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>

<span class="n">tile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                       <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>n>d</strong>. <code class="docutils literal"><span class="pre">reps</span></code> is promoted to length <em>n</em> by pre-pending 1’s to it. Thus for
an input shape <code class="docutils literal"><span class="pre">(2,3)</span></code>, <code class="docutils literal"><span class="pre">repos=(2,)</span></code> is treated as <code class="docutils literal"><span class="pre">(1,2)</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">tile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>n<d</strong>. The input is promoted to be d-dimensional by prepending new axes. So a
shape <code class="docutils literal"><span class="pre">(2,2)</span></code> array is promoted to <code class="docutils literal"><span class="pre">(1,2,2)</span></code> for 3-D replication:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">tile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]],</span>

                         <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                          <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]]</span>
</pre></div>
</div>
</li>
</ul>
<p>Defined in src/operator/tensor/matrix_op.cc:L857</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data array</li>
<li><strong>reps</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>required</em>) – The number of times for repeating the tensor a. Each dim size of reps must be a positive integer. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim < d, a is promoted to be d-dimensional by prepending new axes. If a.ndim > d, reps is promoted to a.ndim by pre-pending 1’s to it.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.topk">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">topk</code><span class="sig-paren">(</span><em>data=None</em>, <em>axis=_Null</em>, <em>k=_Null</em>, <em>ret_typ=_Null</em>, <em>is_ascend=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.topk" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns the top <em>k</em> elements in an input array along the given axis.</dt>
<dd>The returned elements will be sorted.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.3</span><span class="p">,</span>  <span class="mf">0.2</span><span class="p">,</span>  <span class="mf">0.4</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">0.1</span><span class="p">,</span>  <span class="mf">0.3</span><span class="p">,</span>  <span class="mf">0.2</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">returns</span> <span class="n">an</span> <span class="n">index</span> <span class="n">of</span> <span class="n">the</span> <span class="n">largest</span> <span class="n">element</span> <span class="n">on</span> <span class="n">last</span> <span class="n">axis</span>
<span class="n">topk</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">2.</span><span class="p">],</span>
           <span class="p">[</span> <span class="mf">1.</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">top</span><span class="o">-</span><span class="mi">2</span> <span class="n">largest</span> <span class="n">elements</span> <span class="n">on</span> <span class="n">last</span> <span class="n">axis</span>
<span class="n">topk</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ret_typ</span><span class="o">=</span><span class="s1">'value'</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.4</span><span class="p">,</span>  <span class="mf">0.3</span><span class="p">],</span>
                                 <span class="p">[</span> <span class="mf">0.3</span><span class="p">,</span>  <span class="mf">0.2</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">top</span><span class="o">-</span><span class="mi">2</span> <span class="n">smallest</span> <span class="n">elements</span> <span class="n">on</span> <span class="n">last</span> <span class="n">axis</span>
<span class="n">topk</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ret_typ</span><span class="o">=</span><span class="s1">'value'</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">is_ascend</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.2</span> <span class="p">,</span>  <span class="mf">0.3</span><span class="p">],</span>
                                             <span class="p">[</span> <span class="mf">0.1</span> <span class="p">,</span>  <span class="mf">0.2</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">top</span><span class="o">-</span><span class="mi">2</span> <span class="n">largest</span> <span class="n">elements</span> <span class="n">on</span> <span class="n">axis</span> <span class="mi">0</span>
<span class="n">topk</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ret_typ</span><span class="o">=</span><span class="s1">'value'</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.3</span><span class="p">,</span>  <span class="mf">0.3</span><span class="p">,</span>  <span class="mf">0.4</span><span class="p">],</span>
                                         <span class="p">[</span> <span class="mf">0.1</span><span class="p">,</span>  <span class="mf">0.2</span><span class="p">,</span>  <span class="mf">0.2</span><span class="p">]]</span>

<span class="o">//</span> <span class="n">flattens</span> <span class="ow">and</span> <span class="n">then</span> <span class="n">returns</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">both</span> <span class="n">values</span> <span class="ow">and</span> <span class="n">indices</span>
<span class="n">topk</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ret_typ</span><span class="o">=</span><span class="s1">'both'</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">0.4</span><span class="p">,</span>  <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span> <span class="mf">0.3</span><span class="p">,</span>  <span class="mf">0.2</span><span class="p">]]</span> <span class="p">,</span>  <span class="p">[[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/ordering_op.cc:L64</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array</li>
<li><strong>axis</strong> (<em>int</em><em> or </em><em>None</em><em>, </em><em>optional</em><em>, </em><em>default='-1'</em>) – Axis along which to choose the top k indices. If not given, the flattened array is used. Default is -1.</li>
<li><strong>k</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default='1'</em>) – Number of top elements to select, should be always smaller than or equal to the element number in the given axis. A global sort is performed if set k < 1.</li>
<li><strong>ret_typ</strong> (<em>{'both'</em><em>, </em><em>'indices'</em><em>, </em><em>'mask'</em><em>, </em><em>'value'}</em><em>,</em><em>optional</em><em>, </em><em>default='indices'</em>) – The return type.
“value” means to return the top k values, “indices” means to return the indices of the top k values, “mask” means to return a mask array containing 0 and 1. 1 means the top k values. “both” means to return a list of both values and indices of top k elements.</li>
<li><strong>is_ascend</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Whether to choose k largest or k smallest elements. Top K largest elements will be chosen if set to false.</li>
<li><strong>dtype</strong> (<em>{'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'</em><em>, </em><em>'int32'</em><em>, </em><em>'uint8'}</em><em>,</em><em>optional</em><em>, </em><em>default='float32'</em>) – DType of the output indices when ret_typ is “indices” or “both”. An error will be raised if the selected data type cannot precisely represent the indices.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.transpose">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">transpose</code><span class="sig-paren">(</span><em>data=None</em>, <em>axes=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Permutes the dimensions of an array.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
     <span class="p">[</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>

<span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">],</span>
                <span class="p">[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]]</span>

<span class="n">x</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">]],</span>

     <span class="p">[[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">],</span>
      <span class="p">[</span> <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]]</span>

<span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">],</span>
                 <span class="p">[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">7.</span><span class="p">]],</span>

                <span class="p">[[</span> <span class="mf">2.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">],</span>
                 <span class="p">[</span> <span class="mf">4.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]]</span>

<span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
                               <span class="p">[</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">6.</span><span class="p">]],</span>

                              <span class="p">[[</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">4.</span><span class="p">],</span>
                               <span class="p">[</span> <span class="mf">7.</span><span class="p">,</span>  <span class="mf">8.</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/matrix_op.cc:L375</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Source input</li>
<li><strong>axes</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=</em><em>[</em><em>]</em>) – Target axis order. By default the axes will be inverted.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.trunc">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">trunc</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.trunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the element-wise truncated value of the input.</p>
<p>The truncated value of the scalar x is the nearest integer i which is closer to
zero than x is. In short, the fractional part of the signed number x is discarded.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">trunc</span><span class="p">([</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.9</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">])</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">]</span>
</pre></div>
</div>
<p>The storage type of <code class="docutils literal"><span class="pre">trunc</span></code> output depends upon the input storage type:</p>
<blockquote>
<div><ul class="simple">
<li>trunc(default) = default</li>
<li>trunc(row_sparse) = row_sparse</li>
<li>trunc(csr) = csr</li>
</ul>
</div></blockquote>
<p>Defined in src/operator/tensor/elemwise_unary_op_basic.cc:L825</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input array.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.uniform">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">uniform</code><span class="sig-paren">(</span><em>low=_Null</em>, <em>high=_Null</em>, <em>shape=_Null</em>, <em>ctx=_Null</em>, <em>dtype=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw random samples from a uniform distribution.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The existing alias <code class="docutils literal"><span class="pre">uniform</span></code> is deprecated.</p>
</div>
<p>Samples are uniformly distributed over the half-open interval <em>[low, high)</em>
(includes <em>low</em>, but excludes <em>high</em>).</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.60276335</span><span class="p">,</span>  <span class="mf">0.85794562</span><span class="p">],</span>
                                       <span class="p">[</span> <span class="mf">0.54488319</span><span class="p">,</span>  <span class="mf">0.84725171</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/random/sample_op.cc:L96</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>low</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=0</em>) – Lower bound of the distribution.</li>
<li><strong>high</strong> (<em>float</em><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Upper bound of the distribution.</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape of the output.</li>
<li><strong>ctx</strong> (<em>string</em><em>, </em><em>optional</em><em>, </em><em>default=''</em>) – Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls.</li>
<li><strong>dtype</strong> (<em>{'None'</em><em>, </em><em>'float16'</em><em>, </em><em>'float32'</em><em>, </em><em>'float64'}</em><em>,</em><em>optional</em><em>, </em><em>default='None'</em>) – DType of the output in case this can’t be inferred. Defaults to float32 if not defined (dtype=None).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.unravel_index">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">unravel_index</code><span class="sig-paren">(</span><em>data=None</em>, <em>shape=_Null</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.unravel_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix. The leading dimension may be left unspecified by using -1 as placeholder.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">22</span><span class="p">,</span><span class="mi">41</span><span class="p">,</span><span class="mi">37</span><span class="p">]</span>
<span class="n">unravel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">unravel</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/ravel.cc:L67</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Array of flat indices</li>
<li><strong>shape</strong> (<em>Shape</em><em>(</em><em>tuple</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Shape of the array into which the multi-indices apply.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.where">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">where</code><span class="sig-paren">(</span><em>condition=None</em>, <em>x=None</em>, <em>y=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.where" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the elements, either from x or y, depending on the condition.</p>
<p>Given three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,
depending on the elements from condition are true or false. x and y must have the same shape.
If condition has the same shape as x, each element in the output array is from x if the
corresponding element in the condition is true, and from y if false.</p>
<p>If condition does not have the same shape as x, it must be a 1D array whose size is
the same as x’s first dimension size. Each row of the output array is from x’s row
if the corresponding element from condition is true, and from y’s row if false.</p>
<p>Note that all non-zero values are interpreted as <code class="docutils literal"><span class="pre">True</span></code> in condition.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>
<span class="n">cond</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

<span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>

<span class="n">csr_cond</span> <span class="o">=</span> <span class="n">cast_storage</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="s1">'csr'</span><span class="p">)</span>

<span class="n">where</span><span class="p">(</span><span class="n">csr_cond</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]</span>
</pre></div>
</div>
<p>Defined in src/operator/tensor/control_flow_op.cc:L57</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>condition</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – condition array</li>
<li><strong>x</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – </li>
<li><strong>y</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – </li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.zeros_like">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">zeros_like</code><span class="sig-paren">(</span><em>data=None</em>, <em>out=None</em>, <em>name=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mxnet.ndarray.zeros_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of zeros with the same shape, type and storage type
as the input array.</p>
<p>The storage type of <code class="docutils literal"><span class="pre">zeros_like</span></code> output depends on the storage type of the input</p>
<ul class="simple">
<li>zeros_like(row_sparse) = row_sparse</li>
<li>zeros_like(csr) = csr</li>
<li>zeros_like(default) = default</li>
</ul>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
     <span class="p">[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">],</span>
                 <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">]]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The input</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray to hold the result.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The output of this function.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a> or list of NDArrays</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.concatenate">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">concatenate</code><span class="sig-paren">(</span><em>arrays</em>, <em>axis=0</em>, <em>always_copy=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#concatenate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>DEPRECATED, use <code class="docutils literal"><span class="pre">concat</span></code> instead</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>arrays</strong> (list of <cite>NDArray</cite>) – Arrays to be concatenate. They must have identical shape except
the first dimension. They also must have the same data type.</li>
<li><strong>axis</strong> (<em>int</em>) – The axis along which to concatenate.</li>
<li><strong>always_copy</strong> (<em>bool</em>) – Default <cite>True</cite>. When not <cite>True</cite>, if the arrays only contain one
<cite>NDArray</cite>, that element will be returned directly, avoid copying.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An <cite>NDArray</cite> that lives on the same context as <cite>arrays[0].context</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.ones">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">ones</code><span class="sig-paren">(</span><em>shape</em>, <em>ctx=None</em>, <em>dtype=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#ones"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new array filled with all ones, with the given shape and type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>shape</strong> (<em>int</em><em> or </em><em>tuple of int</em><em> or </em><em>list of int</em>) – The shape of the empty array.</li>
<li><strong>ctx</strong> (<em>Context</em><em>, </em><em>optional</em>) – An optional device context.
Defaults to the current default context (<code class="docutils literal"><span class="pre">mxnet.context.current_context()</span></code>).</li>
<li><strong>dtype</strong> (<em>str</em><em> or </em><em>numpy.dtype</em><em>, </em><em>optional</em>) – An optional value type (default is <cite>float32</cite>).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray (default is <cite>None</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new array of the specified shape filled with all ones.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 1.], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go"><NDArray 1x2 @gpu(0)></span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'float16'</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.]], dtype=float16)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.add">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">add</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise sum of the input arrays with broadcasting.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">+</span> <span class="pre">rhs</span></code>, <code class="docutils literal"><span class="pre">mx.nd.broadcast_add(lhs,</span> <span class="pre">rhs)</span></code> and
<code class="docutils literal"><span class="pre">mx.nd.broadcast_plus(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First array to be added.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second array to be added.
If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The element-wise sum of the input arrays.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 3.,  3.,  3.],</span>
<span class="go">       [ 3.,  3.,  3.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.],</span>
<span class="go">       [ 1.,  2.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.arange">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">arange</code><span class="sig-paren">(</span><em>start</em>, <em>stop=None</em>, <em>step=1.0</em>, <em>repeat=1</em>, <em>infer_range=None</em>, <em>ctx=None</em>, <em>dtype=<type 'numpy.float32'></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#arange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns evenly spaced values within a given interval.</p>
<p>Values are generated within the half-open interval [<cite>start</cite>, <cite>stop</cite>). In other
words, the interval includes <cite>start</cite> but excludes <cite>stop</cite>. The function is
similar to the built-in Python function <cite>range</cite> and to <cite>numpy.arange</cite>,
but returns an <cite>NDArray</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> (<em>number</em><em>, </em><em>optional</em>) – Start of interval. The default start value is 0.</li>
<li><strong>stop</strong> (<em>number</em>) – End of interval.</li>
<li><strong>step</strong> (<em>number</em><em>, </em><em>optional</em>) – Spacing between values. The default step size is 1.</li>
<li><strong>repeat</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of times to repeat each element. The default repeat count is 1.</li>
<li><strong>infer_range</strong> (<em>boolean</em><em>, </em><em>optional</em>) – When set to True, infer the stop position from the start, step,
repeat, and output tensor size.</li>
<li><strong>ctx</strong> (<em>Context</em><em>, </em><em>optional</em>) – Device context. Default context is the current default context.</li>
<li><strong>dtype</strong> (<em>str</em><em> or </em><em>numpy.dtype</em><em>, </em><em>optional</em>) – The data type of the <cite>NDArray</cite>. The default datatype is <cite>np.float32</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><cite>NDArray</cite> of evenly spaced values in the specified range.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 0.,  1.,  2.], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 2.,  3.,  4.,  5.], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 2.,  4.], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 2. ,  2. ,  3.5,  3.5,  5. ,  5. ], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'int32'</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([2, 2, 2, 4, 4, 4], dtype=int32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.linspace">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">linspace</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em>, <em>num</em>, <em>endpoint=True</em>, <em>ctx=None</em>, <em>dtype=<type 'numpy.float32'></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#linspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.linspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return evenly spaced numbers within a specified interval.</p>
<p>Values are generated within the half-open interval [<cite>start</cite>, <cite>stop</cite>) or
closed interval [start, stop] depending on whether <cite>endpoint</cite> is True or
False. The function is similar to <cite>numpy.linspace</cite>, but returns an <cite>NDArray</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> (<em>number</em>) – Start of interval.</li>
<li><strong>stop</strong> (<em>number</em>) – End of interval, unless endpoint is set to False.  In that case,
the sequence consists of all but the last of <cite>num + 1</cite> evenly spaced
samples, so that stop is excluded. Note that the step size changes
when endpoint is False.</li>
<li><strong>num</strong> (<em>number</em>) – Number of samples to generate. Must be non-negative.</li>
<li><strong>endpoint</strong> (<em>bool</em>) – If True, stop is the last sample. Otherwise, it is not included.
The default is True.</li>
<li><strong>ctx</strong> (<em>Context</em><em>, </em><em>optional</em>) – Device context. Default context is the current default context.</li>
<li><strong>dtype</strong> (<em>str</em><em> or </em><em>numpy.dtype</em><em>, </em><em>optional</em>) – The data type of the <cite>NDArray</cite>. The default datatype is <cite>np.float32</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><cite>NDArray</cite> of evenly spaced values in the specified range.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 2.,  2.25.,  2.5,  2.75,  3.], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 2.,  2.2.,  2.4,  2.6,  2.8], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.eye">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">eye</code><span class="sig-paren">(</span><em>N</em>, <em>M=0</em>, <em>k=0</em>, <em>ctx=None</em>, <em>dtype=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#eye"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.eye" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>N</strong> (<em>int</em>) – Number of rows in the output.</li>
<li><strong>M</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of columns in the output. If 0, defaults to N.</li>
<li><strong>k</strong> (<em>int</em><em>, </em><em>optional</em>) – Index of the diagonal: 0 (the default) refers to the main diagonal,
a positive value refers to an upper diagonal,
and a negative value to a lower diagonal.</li>
<li><strong>ctx</strong> (<em>Context</em><em>, </em><em>optional</em>) – An optional device context (default is the current default context)</li>
<li><strong>dtype</strong> (<em>str</em><em> or </em><em>numpy.dtype</em><em>, </em><em>optional</em>) – An optional value type (default is <cite>float32</cite>)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A created array</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[[ 1.  0.]</span>
<span class="go"> [ 0.  1.]]</span>
<span class="go"><NDArray 2x2 @cpu(0)></span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[[ 0.  1.  0.]</span>
<span class="go"> [ 0.  0.  1.]]</span>
<span class="go"><NDArray 2x3 @cpu(0)></span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.divide">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">divide</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#divide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.divide" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise division of the input arrays with broadcasting.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">/</span> <span class="pre">rhs</span></code> and <code class="docutils literal"><span class="pre">mx.nd.broadcast_div(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First array in division.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second array in division.
The arrays to be divided. If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The element-wise division of the input arrays.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">*</span><span class="mi">6</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 6.,  6.,  6.],</span>
<span class="go">       [ 6.,  6.,  6.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 2.],</span>
<span class="go">       [ 2.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">/</span><span class="mi">2</span>
<span class="go"><NDArray 2x3 @cpu(0)></span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 2.,  2.,  2.],</span>
<span class="go">       [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 3.,  3.,  3.],</span>
<span class="go">       [ 3.,  3.,  3.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 3.,  3.,  3.],</span>
<span class="go">       [ 3.,  3.,  3.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.equal">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">equal</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>equal to</strong> (==) comparison operation with
broadcasting.</p>
<p>For each element in input arrays, return 1(true) if corresponding elements are same,
otherwise return 0(false).</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">==</span> <span class="pre">rhs</span></code> and <code class="docutils literal"><span class="pre">mx.nd.broadcast_equal(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First array to be compared.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second array to be compared. If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Output array of boolean values.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  0.],</span>
<span class="go">       [ 0.,  1.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.full">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">full</code><span class="sig-paren">(</span><em>shape</em>, <em>val</em>, <em>ctx=None</em>, <em>dtype=<type 'numpy.float32'></em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#full"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new array of given shape and type, filled with the given value <cite>val</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>shape</strong> (<em>int</em><em> or </em><em>tuple of int</em>) – The shape of the new array.</li>
<li><strong>val</strong> (<em>scalar</em>) – Fill value.</li>
<li><strong>ctx</strong> (<em>Context</em><em>, </em><em>optional</em>) – Device context (default is the current default context).</li>
<li><strong>dtype</strong> (<cite>str</cite> or <cite>numpy.dtype</cite>, optional) – The data type of the returned <cite>NDArray</cite>. The default datatype is <cite>float32</cite>.</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><em>optional</em>) – The output NDArray (default is <cite>None</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><cite>NDArray</cite> filled with <cite>val</cite>, with the given shape, ctx, and dtype.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([ 2.], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go"><NDArray 1x2 @gpu(0)></span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'float16'</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 2.,  2.]], dtype=float16)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.greater">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">greater</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#greater"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.greater" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>greater than</strong> (>) comparison operation
with broadcasting.</p>
<p>For each element in input arrays, return 1(true) if lhs elements are greater than rhs,
otherwise return 0(false).</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">></span> <span class="pre">rhs</span></code> and <code class="docutils literal"><span class="pre">mx.nd.broadcast_greater(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First array to be compared.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second array to be compared. If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Output array of boolean values.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span> <span class="o">></span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span> <span class="o">></span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">z</span> <span class="o">></span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.],</span>
<span class="go">       [ 0.,  0.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.greater_equal">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">greater_equal</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#greater_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.greater_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>greater than or equal to</strong> (>=) comparison
operation with broadcasting.</p>
<p>For each element in input arrays, return 1(true) if lhs elements are greater than equal to rhs,
otherwise return 0(false).</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">>=</span> <span class="pre">rhs</span></code> and <code class="docutils literal"><span class="pre">mx.nd.broadcast_greater_equal(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First array to be compared.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second array to be compared. If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Output array of boolean values.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span> <span class="o">>=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span> <span class="o">>=</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">z</span> <span class="o">>=</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.],</span>
<span class="go">       [ 0.,  1.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.imdecode">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">imdecode</code><span class="sig-paren">(</span><em>str_img</em>, <em>clip_rect=(0</em>, <em>0</em>, <em>0</em>, <em>0)</em>, <em>out=None</em>, <em>index=0</em>, <em>channels=3</em>, <em>mean=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#imdecode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.imdecode" title="Permalink to this definition">¶</a></dt>
<dd><p>DEPRECATED, use mx.img instead</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>str_img</strong> (<em>str</em>) – Binary image data</li>
<li><strong>clip_rect</strong> (<em>iterable of 4 int</em>) – Clip decoded image to rectangle (x0, y0, x1, y1).</li>
<li><strong>out</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Output buffer. Can be 3 dimensional (c, h, w) or 4 dimensional (n, c, h, w).</li>
<li><strong>index</strong> (<em>int</em>) – Output decoded image to i-th slice of 4 dimensional buffer.</li>
<li><strong>channels</strong> (<em>int</em>) – Number of channels to output. Decode to grey scale when channels = 1.</li>
<li><strong>mean</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Subtract mean from decode image before outputing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.lesser">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">lesser</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#lesser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.lesser" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>lesser than</strong> (<) comparison operation
with broadcasting.</p>
<p>For each element in input arrays, return 1(true) if lhs elements are less than rhs,
otherwise return 0(false).</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">lhs</span> <span class="pre"><</span> <span class="pre">rhs</span></code> and <code class="docutils literal"><span class="pre">mx.nd.broadcast_lesser(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First array to be compared.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second array to be compared. If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Output array of boolean values.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span> <span class="o"><</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span> <span class="o"><</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">lesser</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">z</span> <span class="o"><</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.],</span>
<span class="go">       [ 1.,  0.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.lesser_equal">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">lesser_equal</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#lesser_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.lesser_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>lesser than or equal to</strong> (<=) comparison
operation with broadcasting.</p>
<p>For each element in input arrays, return 1(true) if lhs elements are
lesser than equal to rhs, otherwise return 0(false).</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">lhs</span> <span class="pre"><=</span> <span class="pre">rhs</span></code> and <code class="docutils literal"><span class="pre">mx.nd.broadcast_lesser_equal(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First array to be compared.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second array to be compared. If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Output array of boolean values.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span> <span class="o"><=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span> <span class="o"><=</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">lesser_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">z</span> <span class="o"><=</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  0.],</span>
<span class="go">       [ 1.,  1.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.logical_and">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">logical_and</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#logical_and"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.logical_and" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>logical and</strong> comparison
operation with broadcasting.</p>
<p>For each element in input arrays, return 1(true) if lhs elements and rhs elements
are true, otherwise return 0(false).</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">and</span> <span class="pre">rhs</span></code> and <code class="docutils literal"><span class="pre">mx.nd.broadcast_logical_and(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First input of the function.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second input of the function. If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Output array of boolean values.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.],</span>
<span class="go">       [ 0.,  1.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.logical_or">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">logical_or</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#logical_or"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.logical_or" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>logical or</strong> comparison
operation with broadcasting.</p>
<p>For each element in input arrays, return 1(true) if lhs elements or rhs elements
are true, otherwise return 0(false).</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">or</span> <span class="pre">rhs</span></code> and <code class="docutils literal"><span class="pre">mx.nd.broadcast_logical_or(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First input of the function.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second input of the function. If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Output array of boolean values.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.],</span>
<span class="go">       [ 1.,  1.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.logical_xor">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">logical_xor</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#logical_xor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.logical_xor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>logical xor</strong> comparison
operation with broadcasting.</p>
<p>For each element in input arrays, return 1(true) if lhs elements or rhs elements
are true, otherwise return 0(false).</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">bool(lhs)</span> <span class="pre">^</span> <span class="pre">bool(rhs)</span></code> and <code class="docutils literal"><span class="pre">mx.nd.broadcast_logical_xor(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First input of the function.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second input of the function. If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Output array of boolean values.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 0.,  0.,  0.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.maximum">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">maximum</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#maximum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise maximum of the input arrays with broadcasting.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">mx.nd.broadcast_maximum(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First array to be compared.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second array to be compared. If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The element-wise maximum of the input arrays.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 2.,  2.,  2.],</span>
<span class="go">       [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.],</span>
<span class="go">       [ 1.,  1.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.minimum">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">minimum</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#minimum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise minimum of the input arrays with broadcasting.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">mx.nd.broadcast_minimum(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First array to be compared.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second array to be compared. If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The element-wise minimum of the input arrays.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.],</span>
<span class="go">       [ 0.,  1.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.moveaxis">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">moveaxis</code><span class="sig-paren">(</span><em>tensor</em>, <em>source</em>, <em>destination</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#moveaxis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.moveaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Moves the <cite>source</cite> axis into the <cite>destination</cite> position
while leaving the other axes in their original order</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tensor</strong> (<em>mx.nd.array</em>) – The array which axes should be reordered</li>
<li><strong>source</strong> (<em>int</em><em> or </em><em>sequence of int</em>) – Original position of the axes to move. Can be negative but must be unique.</li>
<li><strong>destination</strong> (<em>int</em><em> or </em><em>sequence of int</em>) – Destination position for each of the original axes. Can be negative but must be unique.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> – Array with moved axes.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">mx.nd.array</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">X</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3L, 2L)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">X</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 4, 3)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.modulo">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">modulo</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#modulo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.modulo" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise modulo of the input arrays with broadcasting.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">%</span> <span class="pre">rhs</span></code> and <code class="docutils literal"><span class="pre">mx.nd.broadcast_mod(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First array in modulo.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second array in modulo.
The arrays to be taken modulo. If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The element-wise modulo of the input arrays.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">*</span><span class="mi">6</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="mi">4</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 6.,  6.,  6.],</span>
<span class="go">       [ 6.,  6.,  6.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 4.],</span>
<span class="go">       [ 4.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">%</span><span class="mi">5</span>
<span class="go"><NDArray 2x3 @cpu(0)></span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span><span class="o">%</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span><span class="o">%</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 2.,  2.,  2.],</span>
<span class="go">       [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">modulo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 2.,  2.,  2.],</span>
<span class="go">       [ 2.,  2.,  2.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.multiply">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">multiply</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#multiply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise product of the input arrays with broadcasting.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">*</span> <span class="pre">rhs</span></code> and <code class="docutils literal"><span class="pre">mx.nd.broadcast_mul(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First array to be multiplied.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second array to be multiplied.
If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The element-wise multiplication of the input arrays.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 2.,  2.,  2.],</span>
<span class="go">       [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.],</span>
<span class="go">       [ 0.,  1.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.not_equal">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">not_equal</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#not_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.not_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of element-wise <strong>not equal to</strong> (!=) comparison operation
with broadcasting.</p>
<p>For each element in input arrays, return 1(true) if corresponding elements are different,
otherwise return 0(false).</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">!=</span> <span class="pre">rhs</span></code> and <code class="docutils literal"><span class="pre">mx.nd.broadcast_not_equal(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First array to be compared.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second array to be compared. If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Output array of boolean values.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  0.],</span>
<span class="go">       [ 0.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">z</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.],</span>
<span class="go">       [ 1.,  0.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.onehot_encode">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">onehot_encode</code><span class="sig-paren">(</span><em>indices</em>, <em>out</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#onehot_encode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.onehot_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>One-hot encoding indices into matrix out.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>onehot_encode</cite> is deprecated. Use <cite>one_hot</cite> instead.</p>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.power">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">power</code><span class="sig-paren">(</span><em>base</em>, <em>exp</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#power"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.power" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns result of first array elements raised to powers from second array, element-wise
with broadcasting.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">base</span> <span class="pre">**</span> <span class="pre">exp</span></code> and <code class="docutils literal"><span class="pre">mx.nd.broadcast_power(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>base</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The base array</li>
<li><strong>exp</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – The exponent array. If <code class="docutils literal"><span class="pre">base.shape</span> <span class="pre">!=</span> <span class="pre">exp.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The bases in x raised to the exponents in y.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 2.,  2.,  2.],</span>
<span class="go">       [ 2.,  2.,  2.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.],</span>
<span class="go">       [ 2.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.],</span>
<span class="go">       [ 2.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 4.,  4.,  4.],</span>
<span class="go">       [ 4.,  4.,  4.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 2.,  2.,  2.],</span>
<span class="go">       [ 4.,  4.,  4.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 2.,  2.,  2.],</span>
<span class="go">       [ 4.,  4.,  4.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.],</span>
<span class="go">       [ 4.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.subtract">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">subtract</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#subtract"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.subtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise difference of the input arrays with broadcasting.</p>
<p>Equivalent to <code class="docutils literal"><span class="pre">lhs</span> <span class="pre">-</span> <span class="pre">rhs</span></code>, <code class="docutils literal"><span class="pre">mx.nd.broadcast_sub(lhs,</span> <span class="pre">rhs)</span></code> and
<code class="docutils literal"><span class="pre">mx.nd.broadcast_minus(lhs,</span> <span class="pre">rhs)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the corresponding dimensions of two arrays have the same size or one of them has size 1,
then the arrays are broadcastable to a common shape.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – First array to be subtracted.</li>
<li><strong>rhs</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#mxnet.ndarray.array" title="mxnet.ndarray.array"><em>mxnet.ndarray.array</em></a>) – Second array to be subtracted.
If <code class="docutils literal"><span class="pre">lhs.shape</span> <span class="pre">!=</span> <span class="pre">rhs.shape</span></code>, they must be
broadcastable to a common shape.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The element-wise difference of the input arrays.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">x</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">y</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">z</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[-1., -1., -1.],</span>
<span class="go">       [-1., -1., -1.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 1.,  1.,  1.],</span>
<span class="go">       [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="gp">>>> </span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  1.],</span>
<span class="go">       [-1.,  0.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.true_divide">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">true_divide</code><span class="sig-paren">(</span><em>lhs</em>, <em>rhs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#true_divide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.true_divide" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is similar to <a class="reference internal" href="#mxnet.ndarray.divide" title="mxnet.ndarray.divide"><code class="xref py py-meth docutils literal"><span class="pre">divide()</span></code></a>.</p>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.waitall">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">waitall</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#waitall"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.waitall" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for all async operations to finish in MXNet.</p>
<p>This function is used for benchmarking only.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If your mxnet code throws an exception, then waitall can cause performance impact.</p>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.histogram">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">histogram</code><span class="sig-paren">(</span><em>a</em>, <em>bins=10</em>, <em>range=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#histogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the histogram of the input data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Input data. The histogram is computed over the flattened array.</li>
<li><strong>bins</strong> (<em>int</em><em> or </em><em>sequence of scalars</em>) – If bins is an int, it defines the number of equal-width bins in the
given range (10, by default). If bins is a sequence, it defines the bin edges,
including the rightmost edge, allowing for non-uniform bin widths.</li>
<li><strong>range</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The lower and upper range of the bins. If not provided, range is simply (a.min(), a.max()).
Values outside the range are ignored. The first element of the range must be less than or
equal to the second. range affects the automatic bin computation as well, the range will
be equally divided by the number of bins.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A created array.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.split_v2">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">split_v2</code><span class="sig-paren">(</span><em>ary</em>, <em>indices_or_sections</em>, <em>axis=0</em>, <em>squeeze_axis=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#split_v2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.split_v2" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an array into multiple sub-arrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ary</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – Array to be divided into sub-arrays.</li>
<li><strong>indices_or_sections</strong> (<em>int</em><em> or </em><em>tuple of ints</em>) – If <cite>indices_or_sections</cite> is an integer, N, the array will be divided
into N equal arrays along <cite>axis</cite>.  If such a split is not possible,
an error is raised.
If <cite>indices_or_sections</cite> is a 1-D array of sorted integers, the entries
indicate where along <cite>axis</cite> the array is split.  For example,
<code class="docutils literal"><span class="pre">[2,</span> <span class="pre">3]</span></code> would, for <code class="docutils literal"><span class="pre">axis=0</span></code>, result in
- ary[:2]
- ary[2:3]
- ary[3:]
If an index exceeds the dimension of the array along <cite>axis</cite>,
an empty sub-array is returned correspondingly.</li>
<li><strong>axis</strong> (<em>int</em><em>, </em><em>optional</em>) – The axis along which to split, default is 0.</li>
<li><strong>squeeze_axis</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Whether to squeeze the axis of sub-arrays or not, only useful when size
of the sub-arrays are 1 on the <cite>axis</cite>. Default is False.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A created array.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.to_dlpack_for_read">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">to_dlpack_for_read</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#to_dlpack_for_read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.to_dlpack_for_read" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns a reference view of NDArray that represents as DLManagedTensor until</dt>
<dd>all previous write operations on the current array are finished.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – input data.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a reference view of NDArray that represents as DLManagedTensor.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">PyCapsule (the pointer of DLManagedTensor)</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">to_dlpack_for_read</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">>>> </span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go"><class 'PyCapsule'></span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">from_dlpack</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">z</span>
<span class="go">[[1. 1. 1.]</span>
<span class="go"> [1. 1. 1.]]</span>
<span class="go"><NDArray 2x3 @cpu(0)></span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.to_dlpack_for_write">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">to_dlpack_for_write</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#to_dlpack_for_write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.to_dlpack_for_write" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns a reference view of NDArray that represents as DLManagedTensor until</dt>
<dd>all previous read/write operations on the current array are finished.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a>) – input data.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a reference view of NDArray that represents as DLManagedTensor.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">PyCapsule (the pointer of DLManagedTensor)</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">w</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">to_dlpack_for_write</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">>>> </span><span class="nb">type</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go"><class 'PyCapsule'></span>
<span class="gp">>>> </span><span class="n">u</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">from_dlpack</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">u</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">>>> </span><span class="n">x</span>
<span class="go">[[2. 2. 2.]</span>
<span class="go"> [2. 2. 2.]]</span>
<span class="go"><NDArray 2x3 @cpu(0)></span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.from_dlpack">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">from_dlpack</code><span class="sig-paren">(</span><em>dlpack</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#from_dlpack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.from_dlpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a NDArray backed by a dlpack tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dlpack</strong> (<em>PyCapsule</em><em> (</em><em>the pointer of DLManagedTensor</em><em>)</em>) – input data</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a NDArray backed by a dlpack tensor</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">to_dlpack_for_read</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">>>> </span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go"><class 'PyCapsule'></span>
<span class="gp">>>> </span><span class="n">z</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">from_dlpack</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">>>> </span><span class="nb">type</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go"><class 'mxnet.ndarray.ndarray.NDArray'></span>
<span class="gp">>>> </span><span class="n">z</span>
<span class="go">[[ 1.  1.  1.]</span>
<span class="go"> [ 1.  1.  1.]]</span>
<span class="go"><NDArray 2x3 @cpu(0)></span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">w</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">to_dlpack_for_write</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">>>> </span><span class="nb">type</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go"><class 'PyCapsule'></span>
<span class="gp">>>> </span><span class="n">u</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">from_dlpack</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="gp">>>> </span><span class="n">u</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">>>> </span><span class="n">x</span>
<span class="go">[[2. 2. 2.]</span>
<span class="go"> [2. 2. 2.]]</span>
<span class="go"><NDArray 2x3 @cpu(0)></span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.from_numpy">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">from_numpy</code><span class="sig-paren">(</span><em>ndarray</em>, <em>zero_copy=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/ndarray.html#from_numpy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.from_numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an MXNet’s ndarray backed by numpy’s ndarray.
When <cite>zero_copy</cite> is set to be true,
this API consumes numpy’s ndarray and produces MXNet’s ndarray
without having to copy the content. In this case, we disallow
users to modify the given numpy ndarray, and it is suggested
not to read the numpy ndarray as well for internal correctness.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ndarray</strong> (<em>numpy.ndarray</em>) – input data</li>
<li><strong>zero_copy</strong> (<em>bool</em>) – Whether we use DLPack’s zero-copy conversion to convert to MXNet’s NDArray.
This is only available for c-contiguous arrays, i.e. array.flags[C_CONTIGUOUS] == True.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a NDArray backed by a dlpack tensor</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.zeros">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">zeros</code><span class="sig-paren">(</span><em>shape</em>, <em>ctx=None</em>, <em>dtype=None</em>, <em>stype=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/utils.html#zeros"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, filled with zeros.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>shape</strong> (<em>int</em><em> or </em><em>tuple of int</em>) – The shape of the empty array</li>
<li><strong>ctx</strong> (<em>Context</em><em>, </em><em>optional</em>) – An optional device context (default is the current default context)</li>
<li><strong>dtype</strong> (<em>str</em><em> or </em><em>numpy.dtype</em><em>, </em><em>optional</em>) – An optional value type (default is <cite>float32</cite>)</li>
<li><strong>stype</strong> (<em>string</em><em>, </em><em>optional</em>) – The storage type of the empty array, such as ‘row_sparse’, ‘csr’, etc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A created array</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a>, <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray">CSRNDArray</a> or <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray">RowSparseNDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">mx</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="n">stype</span><span class="o">=</span><span class="s1">'csr'</span><span class="p">)</span>
<span class="go"><CSRNDArray 1x2 @cpu(0)></span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">mx</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span> <span class="s1">'float16'</span><span class="p">,</span> <span class="n">stype</span><span class="o">=</span><span class="s1">'row_sparse'</span><span class="p">)</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span>
<span class="go">array([[ 0.,  0.]], dtype=float16)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.empty">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">empty</code><span class="sig-paren">(</span><em>shape</em>, <em>ctx=None</em>, <em>dtype=None</em>, <em>stype=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/utils.html#empty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new array of given shape and type, without initializing entries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>shape</strong> (<em>int</em><em> or </em><em>tuple of int</em>) – The shape of the empty array.</li>
<li><strong>ctx</strong> (<em>Context</em><em>, </em><em>optional</em>) – An optional device context (default is the current default context).</li>
<li><strong>dtype</strong> (<em>str</em><em> or </em><em>numpy.dtype</em><em>, </em><em>optional</em>) – An optional value type (default is <cite>float32</cite>).</li>
<li><strong>stype</strong> (<em>str</em><em>, </em><em>optional</em>) – An optional storage type (default is <cite>default</cite>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A created array.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a>, <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray">CSRNDArray</a> or <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray">RowSparseNDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go"><NDArray 1 @cpu(0)></span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go"><NDArray 1x2 @gpu(0)></span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s1">'float16'</span><span class="p">)</span>
<span class="go"><NDArray 1x2 @gpu(0)></span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">stype</span><span class="o">=</span><span class="s1">'csr'</span><span class="p">)</span>
<span class="go"><CSRNDArray 1x2 @cpu(0)></span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.array">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">array</code><span class="sig-paren">(</span><em>source_array</em>, <em>ctx=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/utils.html#array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.array" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an array from any object exposing the array interface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_array</strong> (<em>array_like</em>) – An object exposing the array interface, an object whose <cite>__array__</cite>
method returns an array, or any (nested) sequence.</li>
<li><strong>ctx</strong> (<em>Context</em><em>, </em><em>optional</em>) – Device context (default is the current default context).</li>
<li><strong>dtype</strong> (<em>str</em><em> or </em><em>numpy.dtype</em><em>, </em><em>optional</em>) – The data type of the output array. The default dtype is <code class="docutils literal"><span class="pre">source_array.dtype</span></code>
if <cite>source_array</cite> is an <cite>NDArray</cite>, <cite>float32</cite> otherwise.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An array with the same contents as the <cite>source_array</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray">NDArray</a>, <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray">RowSparseNDArray</a> or <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray">CSRNDArray</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go"><NDArray 3 @cpu(0)></span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="go"><NDArray 2x2 @cpu(0)></span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="go"><NDArray 3x2 @cpu(0)></span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go"><NDArray 3x2 @gpu(0)></span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">stype</span><span class="o">=</span><span class="s1">'row_sparse'</span><span class="p">))</span>
<span class="go"><RowSparseNDArray 3x2 @cpu(0)></span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="mxnet.ndarray.load_frombuffer">
<code class="descclassname">mxnet.ndarray.</code><code class="descname">load_frombuffer</code><span class="sig-paren">(</span><em>buf</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/utils.html#load_frombuffer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mxnet.ndarray.load_frombuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads an array dictionary or list from a buffer</p>
<p>See more details in <code class="docutils literal"><span class="pre">save</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>buf</strong> (<em>str</em>) – Buffer containing contents of a file as a string or bytes.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Loaded data.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of NDArray, <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray">RowSparseNDArray</a> or <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray">CSRNDArray</a>, or     dict of str to NDArray, <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray">RowSparseNDArray</a> or <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray">CSRNDArray</a></td>
</tr>
</tbody>
</table>
</dd></dl>
<p>NDArray API of MXNet.</p>
<dl class="function">
<dt>
<code class="descclassname">mxnet.ndarray.</code><code class="descname">save</code><span class="sig-paren">(</span><em>fname</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/utils.html#save"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Saves a list of arrays or a dict of str->array to file.</p>
<p>Examples of filenames:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">/path/to/file</span></code></li>
<li><code class="docutils literal"><span class="pre">s3://my-bucket/path/to/file</span></code> (if compiled with AWS S3 supports)</li>
<li><code class="docutils literal"><span class="pre">hdfs://path/to/file</span></code> (if compiled with HDFS supports)</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fname</strong> (<em>str</em>) – The filename.</li>
<li><strong>data</strong> (<a class="reference internal" href="#mxnet.ndarray.NDArray" title="mxnet.ndarray.NDArray"><em>NDArray</em></a><em>, </em><a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray"><em>RowSparseNDArray</em></a><em> or </em><a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray"><em>CSRNDArray</em></a><em>,            or </em><em>list of NDArray</em><em>, </em><a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray"><em>RowSparseNDArray</em></a><em> or </em><a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray"><em>CSRNDArray</em></a><em>,            or </em><em>dict of str to NDArray</em><em>, </em><a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray"><em>RowSparseNDArray</em></a><em> or </em><a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray"><em>CSRNDArray</em></a>) – The data to save.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="n">x</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">y</span> <span class="o">=</span> <span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">'my_list'</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">'my_dict'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'x'</span><span class="p">:</span><span class="n">x</span><span class="p">,</span> <span class="s1">'y'</span><span class="p">:</span><span class="n">y</span><span class="p">})</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">'my_list'</span><span class="p">)</span>
<span class="go">[<NDArray 2x3 @cpu(0)>, <NDArray 1x4 @cpu(0)>]</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">'my_dict'</span><span class="p">)</span>
<span class="go">{'y': <NDArray 1x4 @cpu(0)>, 'x': <NDArray 2x3 @cpu(0)>}</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt>
<code class="descclassname">mxnet.ndarray.</code><code class="descname">load</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/ndarray/utils.html#load"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Loads an array from file.</p>
<p>See more details in <code class="docutils literal"><span class="pre">save</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fname</strong> (<em>str</em>) – The filename.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Loaded data.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of NDArray, <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray">RowSparseNDArray</a> or <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray">CSRNDArray</a>, or     dict of str to NDArray, <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.RowSparseNDArray" title="mxnet.ndarray.sparse.RowSparseNDArray">RowSparseNDArray</a> or <a class="reference internal" href="sparse.html#mxnet.ndarray.sparse.CSRNDArray" title="mxnet.ndarray.sparse.CSRNDArray">CSRNDArray</a></td>
</tr>
</tbody>
</table>
</dd></dl>
<p>Random number interface of MXNet.</p>
<dl class="function">
<dt>
<code class="descclassname">mxnet.random.</code><code class="descname">seed</code><span class="sig-paren">(</span><em>seed_state</em>, <em>ctx='all'</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/mxnet/random.html#seed"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Seeds the random number generators in MXNet.</p>
<p>This affects the behavior of modules in MXNet that uses random number generators,
like the dropout operator and <cite>NDArray</cite>‘s random sampling operators.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>seed_state</strong> (<em>int</em>) – The random number seed.</li>
<li><strong>ctx</strong> (<em>Context</em>) – The device context of the generator. The default is “all” which means seeding random
number generators of all devices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Random number generators in MXNet are device specific.
<cite>mx.random.seed(seed_state)</cite> sets the state of each generator using <cite>seed_state</cite> and the
device id. Therefore, random numbers generated from different devices can be different
even if they are seeded using the same seed.</p>
<p>To produce identical random number sequences independent of the device id,
set optional <cite>ctx</cite> argument. This produces the same sequence of random numbers independent
of the device id, but the sequence can be different on different kind of devices as MXNet’s
random number generators for CPU and GPU use different algorithms.</p>
<p class="rubric">Example</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">>>> </span><span class="nb">print</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
<span class="go">[[ 1.36481571 -0.62203991]</span>
<span class="go"> [-1.4962182  -0.08511394]]</span>
<span class="gp">>>> </span><span class="nb">print</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
<span class="go">[[ 1.09544981 -0.20014545]</span>
<span class="go"> [-0.20808885  0.2527658 ]]</span>
<span class="go"># Same results on the same device with the same seed</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="gp">>>> </span><span class="nb">print</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
<span class="go">[[ 0.47400656 -0.75213492]</span>
<span class="go"> [ 0.20251541  0.95352972]]</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="gp">>>> </span><span class="nb">print</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
<span class="go">[[ 0.47400656 -0.75213492]</span>
<span class="go"> [ 0.20251541  0.95352972]]</span>
<span class="go"># Different results on gpu(0) and gpu(1) with the same seed</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="gp">>>> </span><span class="nb">print</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">ctx</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
<span class="go">[[ 2.5020072 -1.6884501]</span>
<span class="go"> [-0.7931333 -1.4218881]]</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
<span class="gp">>>> </span><span class="nb">print</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">ctx</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
<span class="go">[[ 0.24336822 -1.664805  ]</span>
<span class="go"> [-1.0223296   1.253198  ]]</span>
<span class="go"># Seeding with `ctx` argument produces identical results on gpu(0) and gpu(1)</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">>>> </span><span class="nb">print</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">ctx</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
<span class="go">[[ 2.5020072 -1.6884501]</span>
<span class="go"> [-0.7931333 -1.4218881]]</span>
<span class="gp">>>> </span><span class="n">mx</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">>>> </span><span class="nb">print</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">ctx</span><span class="o">=</span><span class="n">mx</span><span class="o">.</span><span class="n">gpu</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>
<span class="go">[[ 2.5020072 -1.6884501]</span>
<span class="go"> [-0.7931333 -1.4218881]]</span>
</pre></div>
</div>
</dd></dl>
<script>auto_index("api-reference");</script></div>
</div>
</div>
</div>
<div aria-label="main navigation" class="sphinxsidebar rightsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
<h3><a href="../../../index.html">Table Of Contents</a></h3>
<ul>
<li><a class="reference internal" href="#">NDArray API</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#the-ndarray-class">The <code class="docutils literal"><span class="pre">NDArray</span></code> class</a><ul>
<li><a class="reference internal" href="#array-attributes">Array attributes</a></li>
<li><a class="reference internal" href="#array-conversion">Array conversion</a></li>
<li><a class="reference internal" href="#array-creation">Array creation</a></li>
<li><a class="reference internal" href="#array-change-shape">Array change shape</a></li>
<li><a class="reference internal" href="#array-expand-elements">Array expand elements</a></li>
<li><a class="reference internal" href="#array-rearrange-elements">Array rearrange elements</a></li>
<li><a class="reference internal" href="#array-reduction">Array reduction</a></li>
<li><a class="reference internal" href="#array-rounding">Array rounding</a></li>
<li><a class="reference internal" href="#array-sorting-and-searching">Array sorting and searching</a></li>
<li><a class="reference internal" href="#arithmetic-operations">Arithmetic operations</a></li>
<li><a class="reference internal" href="#trigonometric-functions">Trigonometric functions</a></li>
<li><a class="reference internal" href="#hyperbolic-functions">Hyperbolic functions</a></li>
<li><a class="reference internal" href="#exponents-and-logarithms">Exponents and logarithms</a></li>
<li><a class="reference internal" href="#powers">Powers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#basic-neural-network-functions">Basic neural network functions</a><ul>
<li><a class="reference internal" href="#in-place-arithmetic-operations">In-place arithmetic operations</a></li>
<li><a class="reference internal" href="#comparison-operators">Comparison operators</a></li>
<li><a class="reference internal" href="#indexing">Indexing</a></li>
<li><a class="reference internal" href="#lazy-evaluation">Lazy evaluation</a></li>
<li><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
<li><a class="reference internal" href="#array-creation-routines">Array creation routines</a></li>
<li><a class="reference internal" href="#array-manipulation-routines">Array manipulation routines</a><ul>
<li><a class="reference internal" href="#changing-array-shape-and-type">Changing array shape and type</a></li>
<li><a class="reference internal" href="#expanding-array-elements">Expanding array elements</a></li>
<li><a class="reference internal" href="#rearranging-elements">Rearranging elements</a></li>
<li><a class="reference internal" href="#joining-and-splitting-arrays">Joining and splitting arrays</a></li>
<li><a class="reference internal" href="#indexing-routines">Indexing routines</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mathematical-functions">Mathematical functions</a><ul>
<li><a class="reference internal" href="#arithmetic-operations">Arithmetic operations</a></li>
<li><a class="reference internal" href="#trigonometric-functions">Trigonometric functions</a></li>
<li><a class="reference internal" href="#hyperbolic-functions">Hyperbolic functions</a></li>
<li><a class="reference internal" href="#reduce-functions">Reduce functions</a></li>
<li><a class="reference internal" href="#rounding">Rounding</a></li>
<li><a class="reference internal" href="#exponents-and-logarithms">Exponents and logarithms</a></li>
<li><a class="reference internal" href="#powers">Powers</a></li>
<li><a class="reference internal" href="#comparison">Comparison</a></li>
<li><a class="reference internal" href="#logical-operators">Logical operators</a></li>
<li><a class="reference internal" href="#random-sampling">Random sampling</a></li>
<li><a class="reference internal" href="#sorting-and-searching">Sorting and searching</a></li>
<li><a class="reference internal" href="#sequence-operation">Sequence operation</a></li>
<li><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
<li><a class="reference internal" href="#neural-network">Neural network</a><ul>
<li><a class="reference internal" href="#basic">Basic</a></li>
<li><a class="reference internal" href="#more">More</a></li>
</ul>
</li>
<li><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div><div class="footer">
<div class="section-disclaimer">
<div class="container">
<div>
<img height="60" src="https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/apache_incubator_logo.png"/>
<p>
            Apache MXNet is an effort undergoing incubation at The Apache Software Foundation (ASF), <strong>sponsored by the <i>Apache Incubator</i></strong>. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.
        </p>
<p>
            "Copyright © 2017-2018, The Apache Software Foundation
            Apache MXNet, MXNet, Apache, the Apache feather, and the Apache MXNet project logo are either registered trademarks or trademarks of the Apache Software Foundation."
        </p>
</div>
</div>
</div>
</div> <!-- pagename != index -->
</div>
<script crossorigin="anonymous" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
<script src="../../../_static/js/sidebar.js" type="text/javascript"></script>
<script src="../../../_static/js/search.js" type="text/javascript"></script>
<script src="../../../_static/js/navbar.js" type="text/javascript"></script>
<script src="../../../_static/js/clipboard.min.js" type="text/javascript"></script>
<script src="../../../_static/js/copycode.js" type="text/javascript"></script>
<script src="../../../_static/js/page.js" type="text/javascript"></script>
<script src="../../../_static/js/docversion.js" type="text/javascript"></script>
<script type="text/javascript">
        $('body').ready(function () {
            $('body').css('visibility', 'visible');
        });
    </script>
</body>
</html>